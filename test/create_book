#!/usr/bin/env ruby
#encoding: utf-8

# TODO: нахождение первого ключа и создание firstkey. Добавить определение firstkey в sty.

require 'redcarpet'
require 'strscan'

module Redcarpet; module Render;

  class Krugloff < Base

    # Блочные элементы.

    def normal_text(text)
      text = escape(text)
    end

    def paragraph(text)
      "#{text}\n\n"
    end

    def list( content, list_type )
      case list_type
      when :ordered
        "\\begin{enumerate}\n"  +
        "#{content}"            +
        "\\end{enumerate}\n\n"
      when :unordered
        "\\begin{itemize}\n"  +
        "#{content}"          +
        "\\end{itemize}\n\n"
      end
    end

    def list_item( content, list_type )
      "\\item #{content}"
    end

    def block_code( code, language )
      case language

      # Warn! No indent here! Indent from code.
      when 'ruby'
        "\\begin{verbatim}\n" +
        "#{code}"             +
        "\\end{verbatim}\n\n"
=begin

``` longtable
Добавить прибавление \\ \hline в конец каждой отдельной строки?
Улучшить синтаксис.
```
# Возможо стоит ввести только одно окружение - latex.
=end
      # when "longtable"
      #   "\\begin{longtable}" +
      #   "#{code}"            +
      #   "\\end{longtable}\n\n"

      # when "table"
      #   "\\begin{tabular}"  +
      #   "#{code}"           +
      #   "\\end{tabular}\n\n"

      when "note"
        "\\begin{note}" +
        "#{code}"       +
        "\\end{note}\n\n"

      else
        "\\begin{verbatim}\n" +
        "#{code}"             +
        "\\end{verbatim}\n\n"
      end
    end

    # > Это сказал Дональд.
    # > Дональд
    def block_quote(quote)
      quote = quote.rstrip.sub( /(.+)\Z/, '}{\1' )
      "\\epigraph{#{quote}}\n\n"
    end

    # Конец списка ключей.
    def hrule
      "\\end{keylist}\n\n"
    end

    # Строчные элементы.

    def link( link, title, content )
      case link

      # [content]() - создание метки.
      when nil
        "\\hypertarget{#{content}}{}"

      else # обработка внутренних ссылок.
        "\\hyperlink{#{link}}{\\underline{#{content}}}"
      end
    end

    # <link>
    def autolink(link, link_type)
      "\\href{#{link}}{\\underline{#{link}}}"
    end

    def header( title, level )
      case level

      # # Заголовок главы.
      when 1
        "\\chapter{#{title}}\n\n"

      # ## Заголовок подглавы.
      when 2
        "\\section{#{title}}\n\n"

      # ### Заголовок подподглавы
      when 3
        "\\subsection{#{title}}\n\n"

      # #### Заголовок пункта
      when 4
        "\\subsubsection*{#{title}}\n\n"

      # ##### Начало списка ключей:
      when 5
        "\\begin{keylist}{#{title}}\n\n"

      # ###### Небольшой резервный заголовок
      when 6
        "\\itemtitle{\\textbf{#{title}}}\n\n"
      end
    end

    def codespan(code)

      # Declare method hack.
      # `.method(params) {block} # -> return`
      def_method = /^
        (?<name>    [\.:]{1,2} \w+? [=!\?]?)
        (?<params>  \(.+\))?
        (?<block>   \s \{.+?\})?
        (?<ret>     \s \#\s->\s \S+)?
        $/x

      return code.gsub(def_method) do |match|
        name   = Regexp.last_match(:name)
        params = escape_method( Regexp.last_match(:params) )
        block  = escape_method( Regexp.last_match(:block) )
        ret    = escape_method( Regexp.last_match(:ret) )

        return "\\verb`#{name}`" unless params || block || ret

        "\\declare{#{name}#{params}#{block}}{#{ret}}"
      end if code =~ def_method

      # verbatim: `text`
      if code.include? '`'
        "\\verb\'#{code}\'"
      else
        "\\verb\`#{code}\`"
      end
    end

    # _text_ or *text*
    def emphasis(text)
      "\\italy{#{text}}"
    end

    # __text__ or **text**
    def double_emphasis(text)
      "\\textbf{#{text}}"
    end

    # Если вы хотите закончить строку, а не параграф,
    # то в конце строки ставится два пробела.
    def linebreak
      "\n\\\\*"
    end

    # Предварительная и завершающая обработка.

    # `key` в начале параграфа считается элементом списка ключей.
    def preprocess(full_document)
      keylist = /\#{5,5}
                 .+?
                 \*{5,5}/mx

      full_document.gsub(keylist) do |list|
        list.gsub(/\n\n(`{1,2})([^`].*?)\1/) do |key|
          match = $2.gsub( /\\(\S)/, '\textbackslash \1' )
            .gsub( /--/, '\twominus ' )
            .gsub( '{', '\\\\\\{')
            .gsub( '}', '\\\\\\}')

          "\n\n" + "\\key{#{match}}"
        end
      end
    end

#     def block_html(html)
#       html
#     end

#     def raw_html(html)
#       html
#     end

    private

      # Fix: вместо нескольких проходов .gsub, использовать один .map.
      def escape(text)
        return unless text
        text
          .gsub( '\n', '\textbackslash n')
          .gsub( '\r', '\textbackslash r')
          .gsub( '~', '\textasciitilde ' )
          .gsub( '$', '\$' )
          .gsub( '^', '\textasciicircum ')
          .gsub( '#', '\#' )
          .gsub( '%', '\%' )
          .gsub( '&', '\\\\\\&' )
      end

      def escape_method(text)
        return unless text
        escape text .gsub( /\\/, '\textbackslash\-, ' )
                    .gsub('{','\{')
                    .gsub('}','\}')
      end

  end
end; end

markdown = Redcarpet::Markdown.new(Redcarpet::Render::Krugloff,
  no_intra_emphasis: true,
  fenced_code_blocks: true,
  lax_spacing: true)
puts markdown.render(ARGF.read)