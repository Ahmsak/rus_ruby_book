\chapter{Обработка аргументов}

Аргументы, переданные при запуске программы, сохраняются в массиве ARGV.

\section{Файлы}

Программы, работающие с файлами, могут принимать как по одному файлу, так и сразу несколько. Для работы с одним файлом используется массив ARGV, а для работы с несколькими файлами - поток ARGF.

\subsection{ARGV}

Для чтения файла используются частные методы экземпляров из модуля Kernel.

\begin{methodlist}
  \declare{.gets( sep = \$/, bytesize = nil )}{\# -> string}
  Чтение следующей строки из файла, найденного в ARGV (размер строки может быть ограничен). Переданный разделитель обрабатывается в качестве символа перевода строки (если передается пустой текст, то обрабатывается "/n/n"). Если достигнут конец файла, то возвращается nil (если в массиве ARGV больше нет файлов).

  Полученная в результате строка связывается с глобальной переменной \$_. 
 
  \declare{.readline( sep = \$/, bytesize = nil )}{\# -> string}
  Версия метода вызывающая ошибку при достижении конца файла. 
\end{methodlist}

\subsection{ARGF}

ARGF (\verb!$<!) - это поток, открываемый для файлов, содержащихся в ARGV. При этом подразумевается, что ARGV содержит только пути к файлам. 

Файлы обрабатываются в том порядке, в котором они содержатся в ARGV. После обработки путь к файлу удаляется автоматически.

Файлы обрабатываются последовательно в качестве одного виртуального файла. Концом файла считается конец всех объединяемых файлов, а не конец отдельных элементов. 

Если ARGV ссылается на пустой массив, то ARGF ссылается на стандартный поток для ввода.

Добавленные модули: Enumerable

\subsubsection{Управление потоком}

\begin{methodlist}
  \declare{::binmode}{\# -> self} 
  Переключение в двоичный режим. Возврат в текстовый режим после этого невозможен. Преобразование кодировок и символа перевода строки отменяется, а содержимое потока обрабатывается в ASCII кодировке. 

  \declare{::close}{\# -> self} 
  Завершение обработки текущего файла и переход к следующему. Если все файлы уже обработаны, то вызывается ошибка \error{IOError}. 

  \declare{::skip}{\# -> self}
  Пропуск обработки текущего файла и переход к следующему. При отсутствии файлов ничего не выполняется.

  \declare{::argv}{\# -> ARGV}

  \declare{::binmode?}{} 
  Проверяет используется ли двоичный режим. 

  \declare{::closed?}{} 
  Проверяет завершена ли обработка текущего файла. 

  \declare{::eof?}{} 
  \alias{eof} 
  Проверяет достигнут ли конец текущего файла. 

  \declare{::filename}{\# -> path}
  \alias{path} 
  Возвращает относительный путь к обрабатываемому файлу. При взаимодействии с стандартным потоком для ввода возвращается \verb!"-"!. Аналогично использованию \verb!$FILENAME!. 
\end{methodlist}

\subsubsection{Кодировка}

\begin{methodlist}
  \declare{::external_encoding}{\# -> encoding} 
  Возвращает внешнюю кодировку.
 
  \declare{::internal_encoding}{\# -> encoding} 
  Возвращает внутреннюю кодировку если она указана. В другом случае возвращает nil. 

  \declare{::set_encoding( *encoding, options = nil )}{\# -> self} 
  Объявление внешней и внутренней кодировок (объекты или текст). Дополнительный аргумент используется при \hyperlink{appencode}{\underline{преобразовании данных}}. 
\end{methodlist}

\subsubsection{Приведение типов}

\begin{methodlist}
  \declare{::to_io}{\# -> io}
  \alias{file}  
  Возвращает файл или поток для обрабатываемого файла (или стандартного потока для ввода).

  \declare{::to_i}{\# -> integer} 
  \alias{fileno} 
  Возвращает дескриптор обрабатываемого файла. При отсутствии файлов вызывается ошибка \error{ArgumentError}.

  \declare{::to_s}{\# -> "ARGF"}

  \declare{::to_a( sep = \$/, size = nil )}{\# -> array} 
  \alias{readlines}  
  Чтение строк и сохранение их в индексном массиве (размер массива может быть ограничен). Переданный разделитель обрабатывается в качестве символа перевода строки (если передается пустой текст, то обрабатывается "/n/n").
 
  \declare{::to_write_io}{\# -> io} 
  Интерпретатор возвращает поток, доступный для записи (только если используется режим редактирования файлов - ключ \verb!-i!).
\end{methodlist}

\subsubsection{Чтение данных}

{\bf Фрагмент}

\begin{methodlist}
  \declare{::read( bytesize = nil, buffer = nil )}{\# -> buffer}
  Чтение данных из потока (по умолчанию полностью). Если размер фрагмента ограничен, то чтение выполняется в двоичном режиме. Дополнительный аргумент служит для хранения полученных данных.
  \begin{itemize}
    \item Если передается ноль, то возвращается пустой текст;
    \item Если в начале чтения достигнут конца файла, то возвращается ссылка nil (если размер фрагмента ограничен). В другом случае возвращается пустой текст. 
  \end{itemize}

  \declare{::read_nonblock( bytesize, buffer = nil )}{\# -> buffer}
  Чтение данных, не блокирующее процесс выполнения. В этом случае при ошибке чтения, она будет вызвана немедленно.
 
  \declare{::readpartial( bytesize, buffer = nil )}{\# -> buffer}
  Чтение данных блокирующее процесс выполнения:
  \begin{itemize}
    \item если буфер пуст;
    \item если поток пуст;
    \item если поток не достиг конца файла;
  \end{itemize}
  
  После блокировки ожидается получение данных или вызов сообщения о достижении конца файла.
\end{methodlist}

{\bf Строки}

\begin{methodlist}
  \declare{::gets( sep = \$/, bytesize = nil )}{\# -> string}
  Чтение следующей строки из потока (размер строки может быть ограничен). Переданный разделитель обрабатывается в качестве символа перевода строки (если передается пустой текст, то обрабатывается "/n/n"). Если достигнут конец файла, то возвращается nil.

  Полученная в результате строка связывается с глобальной переменной \$_. 
 
  \declare{::readline( sep = \$/, bytesize = nil )}{\# -> string}
  Версия метода вызывающая ошибку при достижении конца файла. 
 
  \declare{::lineno}{\# -> integer}
  Возвращает позицию (порядковый номер) извлекаемой строки. Вызов метода аналогичен вызову глобальной переменной \$. 
 
  \declare{::lineno=(pos)}{\# -> integer}
  Объявление позиции (порядкового номера) извлекаемой строки. Позиция обновляется при последующем чтении данных из потока.  
 
  \declare{::seek( offset, object = IO::SEEK_SET )}{\# -> 0} 
  Объявление позиции (порядкового номера) извлекаемой строки относительно текущего положения и переданного смещения.

  Константы:
  \begin{description}
    \item[IO::SEEK_CUR] -> новая_позиция = текущая_позиция + offset
    \item[IO::SEEK_END] -> новая_позиция = конец_файла + offset
    \item[IO::SEEK_SET] -> новая_позиция = offset
  \end{description}   

  \declare{::rewind}{\# -> 0} 
  Сброс позиции (порядковый номер) извлекаемой строки.
\end{methodlist}

{\bf Символы}

\begin{methodlist}
  \declare{::getc}{\# -> string}
  Чтение следующего символа из потока. Если достигнут конец файла, возвращается nil.

  \declare{::readchar}{\# -> string}
  Версия метода вызывающая ошибку при достижении конца файла.
\end{methodlist}

{\bf Байты}

\begin{methodlist}
  \declare{::getbyte}{\# -> integer} 
  Чтение следующего байта из потока. Если достигнут конец файла, возвращается nil. 
 
  \declare{::readbyte}{\# -> integer} 
  Версия метода вызывающая ошибку при достижении конца файла. 
 
  \declare{::pos}{\# -> integer} 
  \alias{tell} 
  Возвращает позицию (порядковый номер) извлекаемого байта. 
 
  \declare{::pos=(pos)}{\# -> integer} 
  Объявление позиции (порядкового номера) извлекаемого байта. Позиция обновляется при последующем чтении данных из потока.
\end{methodlist}

{\bf Итераторы}

\begin{methodlist}
  \declare{::each( sep = \$/ ) \{ |string| \}}{\# -> self} 
  \verb!(size) { |string| } # -> self!
  \\\verb!( sep, size) { |string| } # -> self!

  \alias{each_line, lines} 
  Последовательный перебор строк для каждого файла в потоке. Количество строк может быть ограничено. Переданный разделитель обрабатывается в качестве символа перевода строки.
 
  \declare{::bytes \{ |byte| \}}{\# -> self}
  \alias{each_byte} 
  Последовательно перебирает байты для каждого файла в потоке. 

  \declare{::chars \{ |char| \}}{\# -> self}
  \alias{each_char} 
  Последовательно перебирает символы для каждого файла в потоке.
\end{methodlist}

\subsubsection{Запись данных}

Запись данных с помощью ARGF возможна только при запуске программы с ключом \verb!-i!.

\begin{methodlist}
  \declare{::inplace_mode}{\# -> string} 
  Возвращает расширение, используемое для создания резервных копий изменяемых файлов.

  \declare{::inplace_mode=(ext)}{\# -> self}
  Изменяет расширение, используемое для создания резервных копий изменяемых файлов.

  \declare{::write(object)}{\# -> object.to_s.bytesize}
  Запись \verb!object.to_s! в обрабатываемый файл.

  \declare{::print( *object = \$_ )}{\# -> nil}
  Запись \verb!object.to_s! в обрабатываемый файл для всех переданных аргументов.
  \begin{itemize}
    \item Если глобальная переменная \$,, отвечающая за разделение элементов, не ссылается на nil, то она будет использоваться для разделения аргументов. 
    \item Если глобальная переменная \$\textbackslash, отвечающая за разделение данных, не ссылается на nil, то она будет использована после записи всех объектов. 
  \end{itemize}
 
  \declare{::printf( format, *object = nil )}{\# -> nil}
  Запись отформатированных объектов в обрабатываемый файл: \\* \verb!string % [*object]!. 
   
  \declare{::putc(object)}{\# -> object}
  Запись \verb!object.to_s! в обрабатываемый файл. Переданное число считается кодовой позицией.
 
  \declare{::puts( *object = \$\\ )}{\# -> nil}
  Запись \verb!object.to_s! в обрабатываемый файл. Аргументы разделяются с помощью перевода строки. Из индексного массива извлекаются все элементы.
\end{methodlist}