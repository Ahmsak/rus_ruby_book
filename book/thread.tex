\chapter{Многопоточность и параллелизм}

Процесс - максимальная единица планирования ядра ОС. Ресурсы для процессов выделяются системой (каждый процесс использует отдельные ресурсы). При запуске программы создается новый процесс, в пространстве которого она выполняется. В связи с этим процессом также иногда называют непосредственное выполнение кода программы.

Поток выполнения - это минимальная единица планирования. Внутри каждого процесса существует по крайней мере один поток выполнения. Потоки выполнения, находящиеся внутри одного процесса совместно используют его адресное пространство и состояние выполнения.

Идея распараллеливания вычислений основана на том, что большинство задач (процессов) может быть разделено на набор меньших задач (потоков выполнения), которые могут быть выполнены одновременно.

Параллельные вычисления стали доминирующей парадигмой после появления многоядерных процессоров.

Создание программ для параллельного выполнения сложнее, чем для последовательного из-за возникновения конкуренции за ресурсы. Взаимодействие и синхронизация между процессами повышают сложность проектирования параллельных программ.

Использование потоков облегчает распараллеливание так как переключение между потоками легче, чем переключение между процессами и потоки, в отличии от процессов, используют единое адресное пространство и единое состояние.

В Ruby реализована поддержка потоков, но при этом используется глобальная блокировка интерпретатора (GIL), запрещающая выполнение двух или более потоков одновременно, фактически ограничивая параллелизм на многоядерных системах, заменяя его многопоточностью.

Многопоточность - это широко распространенная модель проектирования и выполнения кода, позволяющая нескольким потокам выполняться в рамках одного процесса. Процессор переключается между разными потоками выполнения. Это переключение выполняется достаточно часто, чтобы восприниматься как одновременное выполнение.

Реализация многопоточности в Ruby позволяет реагировать на ввод данных. Если основной поток выполнения заблокирован, то выполнение программы останавливается. Вместо этого, после блокировки основного потока, позволяется переключаться на выполнение производного потока, избегая ожидания реакции системы.

\section{Потоки выполнения}

\epigraph
{Хотя кажется, что потоки выполнения — это небольшой шаг от последовательных вычислений, по сути они представляют собой огромный скачок. Они отказываются от наиболее важных и привлекательных свойств последовательных вычислений: понятности, предсказуемости и детерминизма. Потоки выполнения, как модель вычислений, являются потрясающе недетерминированными, и работа программиста становится одним из обрезков этого недетерминизма.}
{Edward A. Lee}

Для создания и управления потоками выполнения используется класс Thread. Однако многопоточность также может быть реализована с помощью класса Fiber.

Поток выполнения, создаваемый при запуске программы, называется основным, а потоки выполнения, создаваемые программой - производными.

После завершения основного потока выполнения, процесс выполнения программы прекращается, даже если производные потоки еще не выполнены.

Производные потоки используют ту же глобальную область видимости, что и основной процесс, но многие глобальные переменные отличаются для разных процессов.

Состояние потоков:
\begin{description}
  \item[Выполняющийся] - поток, выполнение которого еще не завершено; 
  \item[Ожидающий] - поток, бездействующий до выполнения определенного условия (ограничения по времени, получения ответа от системы);
  \item[Выполненный] - поток, выполнение которого завершено. Выполнение может быть завершено нормально, с ошибкой или преждевременно.
\end{description}

Потоки выполнения создаются в состоянии выполнения. Текущий поток выполняется до тех пор пока не будет переведен в режим ожидания или выполнен. После этого начинается выполнение следующего потока. Переключение между потоками совершается при выполнении системных вызовов (например ввода/вывода). 

\subsection{Thread}

Класс Thread реализует стандарт POSIX для реализации потоков выполнения.

\begin{methodlist}
  \declare{::start(*arg) \{ |*arg| \}}{\# -> thread} 
  \alias{fork, new} 
  Создание нового потока.
  \\\verb!Thread.start { } # -> #<Thread:0x962817c run>!

  \declare{::list}{\# -> array} 
  Возвращает массив, содержащий все созданные потоки выполнения. 
  \\\verb!Thread.list # -> [#<Thread:0x94da0a4 run>, #<Thread:0x964b4d8 sleep>]!

  \declare{::current}{\# -> thread} 
  Возвращает ссылку на текущий поток выполнения. 
  \\\verb!Thread.current # -> #<Thread:0x94da0a4 run>!
 
  \declare{::main}{\# -> thread} 
  Возвращает ссылку на основной поток выполнения. 
  \\\verb!Thread.main # -> #<Thread:0x94da0a4 run>!
\end{methodlist}

\subsubsection*{Управление текущим потоком}

\begin{methodlist}
  \declare{::pass}{\# -> nil}
  Интерпретатору передается сообщение о необходимости переключения потока. Переключение выполняется в зависимости от операционной системы и процессора (т.е. не обязателен). 
  \\\verb!Thread.start { Thread.pass } # -> #<Thread:0x962e554 run>!

  \declare{::stop}{\# -> nil} 
  Перевод текущего потока выполнения в режим ожидания.

  \declare{::exit}{\# -> thread} 
  \alias{kill}
  Завершение выполнения текущего потока. Если выполнение уже завершено, то возвращается ссылка на класс Thread.
\end{methodlist}

\subsubsection*{Управление произвольным потоком}

\begin{methodlist}
  \declare{.join( sec = nil )}{\# -> thread}
  Блокировка текущего потока до тех пор пока не будет выполнен поток, для которого метод был вызван (выполнение потока может быть приостановлено через переданное количество секунд - в этом случае возвращается nil).
  \begin{verbatim}
  a = Thread.new { print ?a; sleep(10); print ?b; print ?c } 
  x = Thread.new { print ?x; Thread.pass; print ?y; print ?z } 
  x.join 
  # -> "axyz" 
  y = Thread.new { 4.times { sleep 0.1; puts 'tick... ' } } 
  puts "Waiting" until y.join 0.15 
  # -> 
  "tick... 
  Waiting 
  tick... 
  Waiting 
  tick... 
  tick..."\
  \end{verbatim}

  \declare{.value}{\# -> object} 
  Выполняет поток (с помощью метода \method{.join}) и возвращает результат выполнения (результат последнего выполненного выражения) .

  \declare{.run }{\#-> self} 
  Переключение потока в режим выполнения. Текущий процесс при этом переводится в режим ожидания, после чего начинается выполнение процесса, для которого метод был вызван. 

  \declare{.wakeup}{\# -> self} 
  Переключение потока в режим выполнения (при этом процесс может быть заблокирован).

  \declare{.exit(status)}{\# -> self} 
  \alias{kill, terminate}
  Завершение выполнения потока с переданным статусом. Если выполнение уже завершено, то возвращается ссылка на класс Thread. 
 
  \declare{.priority}{\# -> integer}
  Возвращает приоритет выполнения поток. Основной поток выполняется с нулевым приоритетом. Производные потоки, наследуют приоритет от базовых. 

  Потоки выполнения с большим приоритетом выполняются раньше, чем потоки с меньшим приоритетом. Работа данного метода зависит от операционной системы. 

  \declare{.priority= (integer)}{\# -> self} 
  Изменяет приоритет выполнения для потока.

  \declare{.add_trace_func( proc = nil )}{\# -> proc} 
  \alias{set_trace_func} 
  Объявление замыкания для перехвата выполнения при изменении состояния потока. Если передается nil, то перехват выполнения прекращается.
\end{methodlist}

\subsubsection*{Локальные переменные}

\begin{methodlist}
  \declare{thread[name]= (object)}{\# -> object} 
  Инициализирует локальную переменную для потока выполнения.
  \\\verb!Thread.main[:local] = 4 # -> 4!
 
  \declare{thread[name]}{\# -> object}
  Возвращает значение локальной переменной. Если переменная не существует, то возвращается nil.
  \\\verb!Thread.main[:local] # -> 4!
 
  \declare{.keys}{\# -> array}
  Возвращает массив идентификаторов всех локальных переменных.
  \\\verb!Thread.main.keys # -> [:local]!
 
  \declare{.key?(name)}{} 
  Проверяет существование локальной переменной.
  \\\verb!Thread.main.key? :global # -> false!
\end{methodlist}

\subsubsection*{Обработка ошибок}

\begin{methodlist}
  \declare{::abort_on_exception}{\# -> bool} 
  Возвращает глобальные настройки по обработке ошибок. По умолчанию - false. 
 
  \declare{::abort_on_exception= (bool)}{\# -> bool}
  При вызове ошибки в любом из производных потоков, выполнение основного потока прекращается. Подобное поведение также применяется если глобальная переменная \verb!$DEBUG! ссылается на true (программа запущена с ключом \verb!-d!). Основной поток завершается с помощью выражения \verb!Thread.main.exit(0)!. 

  \declare{.abort_on_exception}{\# -> bool} 
  Возвращает глобальные настройки по обработке ошибок. По умолчанию - false. 
 
  \declare{.abort_on_exception= (bool)}{\# -> bool} 
  При вызове ошибки в производном потоке, выполнение основного процесса прекращается. Подобное поведение также применяется если глобальная переменная \verb!$DEBUG! ссылается на true (программа запущена с ключом \verb!-d!). Основной поток завершается с помощью выражения \verb!Thread.main.exit(0)!.

  \declare{.raise( message = nil )}{}
  \verb!( exc, message = nil, pos = nil )!

  Вызов ошибки для потока. Метод не может быть вызван для текущего потока выполнения. По умолчанию вызов ошибки в производном потоке не приводит к завершению основного потока.
\end{methodlist}

\subsubsection*{Остальное}

\begin{methodlist}
  \declare{.group}{\# -> thgroup} 
  Возвращает группу, в которую входит поток выполнения. Если поток не входит ни в одну из существующих групп, то возвращается nil.
  \\\verb!Thread.main.group # -> #<ThreadGroup:0x94d9d98>!

  \declare{.inspect}{\# -> string} 
  Возвращает информацию об объекте. 
  \\\verb!Thread.main.inspect -> "#<Thread:0x94da0a4 run>"!

  \declare{.status}{\# -> object}
  Возвращает статус выполнения потока.
  \begin{itemize}
    \item Для выполняющихся потоков возвращается "run";
    \item Для ожидающих потоков возвращается "sleep";
    \item Для потоков, завершенных нормально возвращается false;
    \item Для потоков, завершенных с ошибкой возвращается nil;
    \item Для потоков, завершенных преждевременно возвращается "aborting".
  \end{itemize}   
  \verb!Thread.main.status -> "run"!

  \declare{.alive?}{} 
  Проверяет будет ли выполняться поток (выполнение потока еще не завершено).
  \\\verb!Thread.main.alive? -> true!

  \declare{.stop?}{} 
  Проверяет остановлено ли выполнение потока (поток не находится в режиме выполнения). 
  \\\verb!Thread.main.stop? -> false!
 
  \declare{.safe_level}{\# -> int} 
  Возвращает уровень безопасности. 
  \\\verb!Thread.main.safe_level -> 0!

  \declare{.backtrace}{\# -> array} 
  Возвращает состояние выполнения потока.
\end{methodlist}

\subsection{Группировка потоков}

Для группировки потоков выполнения в Ruby предоставлен класс ThreadGroup. 

Каждый поток выполнения может одновременно входить только в одну группу. При добавлении потока в другую группу, он автоматически удаляется из текущей группы. Производные потоки выполнения входят в ту же группу, что и базовые.

\begin{methodlist}
  \declare{::Default}{\# -> thgroup}
  Группа, создаваемая по умолчанию. Основной поток выполнения будет относиться к этой группе.

  \declare{::new}{\# -> thgroup}
  Создание новой группы.
  \\\verb!ThreadGroup.new # -> #<ThreadGroup:0x9711728>!

  \declare{.add(thread)}{\# -> thgroup}
  Добавляет поток выполнения в группу, удаляя его из текущей группы.
  \begin{verbatim}
  Thread.main.group # -> #<ThreadGroup:0x94d9d98>
  ThreadGroup.new.add Thread.main # -> #<ThreadGroup:0x96f0154>
  Thread.main.group # -> #<ThreadGroup:0x96f0154>\
  \end{verbatim}

  \declare{.enclose}{\# -> thgroup}
  Блокирует группу, запрещая добавлять или удалять содержащиеся в ней потоки выполнения.
  \begin{verbatim}
  Thread.main.group.enclose # -> #<ThreadGroup:0x96f0154>
  ThreadGroup.new.add Thread.main # -> error\
  \end{verbatim}

  \declare{.enclosed?}{}
  Проверяет заблокирована ли группа.
  \\\verb!Thread.main.group.enclosed? # -> true!

  \declare{.list}{\# -> array}
  Возвращает массив потоков выполнения, входящих в группу.
  \begin{verbatim}
  Thread.main # -> #<Thread:0x94da0a4 run>
  Thread.main.group.list # -> [#<Thread:0x94da0a4 run>]\
  \end{verbatim}
\end{methodlist}

\subsection{Синхронизация потоков}

Синхронизация потоков требуется, чтобы избежать ошибок при использовании потоками одних и тех же данных или устройств (состояние гонки при обновлении данных).

Простейшая синхронизация выполняется с помощью экземпляров класса Mutex.

Поток выполнения, который в настоящее время работает с данными, блокирует экземпляр класса Mutex. После выполнения работы, блокировка снимается. В зависимости от наличия блокировки изменяется реакция конкурирующих потоков.

\begin{methodlist}
  \declare{::new}{\# -> mutex} 
  Создание нового объекта. 

  \declare{.lock}{\# -> mutex}
  Блокировка объекта. Если объект уже заблокирован текущим потоком, то вызывается ошибка \error{ThreadError}. 

  \declare{.try_lock}{\# -> bool}
  Попытка блокировки объекта. Возвращается результат блокировки.

  \declare{.locked?}{} 
  Проверяет заблокирован ли объект. 

  \declare{.unlock}{\# -> mutex} 
  Снятие блокировки. Если объект заблокирован другим потоком выполнения, то вызывается ошибка \error{ThreadError}.

  \declare{.sleep( sec = nil )}{\# -> sec} 
  Снятие блокировки и переключение в режим ожидания. Если объект заблокирован другим потоком выполнения, то вызывается ошибка \error{ThreadError}. 
\end{methodlist}

\section{Процессы}

Процесс - это программа в стадии ее выполнения. Ruby позволяет манипулировать процессами, используя низкоуровневые возможности системы.

Характеристики процессов:
\begin{description}
  \item[PID] - идентификатор процесса;
  \item[PPID] - идентификатор базового процесса;
  \item[]имя владельца процесса;
  \item[UID] - реальный идентификатор владельца;
  \item[EUID] - действующий идентификатор владельца;
  \item[GUID] - реальный идентификатор группы владельцев;
  \item[EGUID] - действующий идентификатор группы владельцев;
  \item[]приоритет;
  \item[]терминал.
\end{description}

Для манипуляции процессами используются модуль Process и модуль Kernel. Также управление процессами происходит с помощью передачи сигналов.

\begin{methodlist}
  \declare{fork \{nil\}}{\# -> status}
  Создание нового подпроцесса, который является копией процесса, выполняющего этот вызов. Подпроцессы обычно используются для выполнения системных вызовов, загружающих в пространство подпроцесса новую программу. Однако ничто не мешает использовать подпроцессы для выполнение параллельных задач.

  Для производного процесса создается собственная таблица файловых дескрипторов, копирующая таблицу базового процесса. Изменения не синхронизируются.

  В Linux страницы памяти базового процесса копируются производным, только после их изменения. Это позволяет уменьшить время создания процессов и количество потребляемой памяти.

  Для производного процесса копируется только текущий поток выполнения.

  Переданный блок выполняется в теле производного процесса. После выполнения производного процесса блок закрывается и возвращается 0.

  В другом случае код программы после вызова метода, выполняется дважды - для базового процесса и для производного процесса:

  \begin{itemize}
    \item Для базового процесса в результате вызова метода возвращается идентификатор производного процесса;
    \item Для производного процесса в результате вызова метода возвращается nil.
  \end{itemize}

  Базовый процесс должен обрабатывать статусы завершения производных процессов с помощью методов \method{::wait} или \method{::detach}, иначе процессы могут превратиться в зомби.

  Если создание подпроцессов не реализовано для ОС, то выполнение \verb!Process.respond_to?(:fork)! вернет false.

  \declare{fork \{nil\}}{\# -> status}
  Частный метод экземпляров из модуля Kernel, аналогичный предыдущему.
\end{methodlist}

\section{Обработка сигналов}

Сигналы - это способ передачи сообщений между процессами.

Для работы с сигналами используется модуль Signal.

\begin{methodlist}
  \declare{::list}{\# -> hash}
  Возвращает массив названий сигналов, ассоциируемых с цифровыми кодами.

  \declare{::trap( name, command )}{\# -> object}
  \verb!(name) { } # -> object!

  Обработка сигнала после его получения. Метод принимает либо название сигнала (приставка SIG может быть пропущена), либо его цифровой код. В результате возвращается предыдущий обработчик.

  command:
  \begin{itemize}
    \item блок, выполняемый при получении сигнала;
    
    \item текст:
    \begin{description}
      \item["IGNORE" ("SIG_IGN")] - полученный сигнал игнорируется;
      \item["DEFAULT" ("SIG_DFL")] - сигнал обрабатывается как обычно;
      \item["SYSTEM_DEFAULT"] - сигнал обрабатывается в зависимости от операционной системы;
      \item["EXIT" (0)] - завершение выполнения программы. 
    \end{description}

    \item системный вызов:
    \begin{description}
      \item[string] - текст команды для используемой оболочки: по умолчанию в Unix - это \verb!"/bin/sh"!, а в Windows - \verb!ENV["RUBYSHELL"]! или \verb!ENV["COMSPEC"]!;
      \item[string, *arg] - текст команды и передаваемые аргументы;
      \item[{[ string, first_arg ], *arg}] - текст команды, первый аргумент и остальные аргументы. 
  \end{description}
  \end{itemize}

  \declare{trap( name, command )}{\# -> object}
  \verb!(name) { } # -> object!

  Частный метод экземпляров из модуля Kernel, аналогичный предыдущему.
\end{methodlist}