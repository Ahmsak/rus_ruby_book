\chapter{Текст}

\section{String}

Добавленные модули: Comparable

При работе с текстом следует помнить, что интерпретатор на стадии создания объекта не анализирует его значение. Поэтому для любого текста, всегда создается новый объект, даже если объект с таким же значением уже существует.

\begin{methodlist}
  \declare{::new( string = "" )}{\# -> string}
  Cоздает новый объект.
  \\\verb!String.new # -> ""!
\end{methodlist}

\subsection*{Приведение типов}

\begin{methodlist}
  \declare{::try_convert(object)}{\# -> string}
  Преобразует объект в текст, вызывая метод \method{.to_str}. Если для объекта этот метод не определен, то возвращается nil.
  \\\verb!String.try_convert [1] # -> nil!

  \declare{.to_s}{\# -> string}
  Синонимы: \method{to_str}

  \declare{.to_sym}{\# -> sym}
  Преобразует текст в объект-идентификатор.
  \begin{verbatim}
  "abc".to_sym # -> :abc
  "123a".to_sym # -> :"123a"
  \end{verbatim}  

  \declare{.to_i( numeral_system = 10 )}{\# -> integer}
  Преобразует текст в целое число, обрабатывая его в заданной системе счисления. Обработка продолжается до первого символа, не относящегося к цифрам. Если текст начинается с такого символа или преобразование невозможно, то возвращается 0.

  \declare{.to_r}{\# -> rational}
  Преобразует текст в рациональную дробь. Обработка продолжается до первого символа, не относящегося к цифрам. Если текст начинается с такого символа или преобразование невозможно, то возвращается (0/1). 

  \declare{.to_f}{\# -> float}
  Преобразует текст в десятичную дробь. Обработка продолжается до первого символа, не относящегося к цифрам. Если текст начинается с такого символа или преобразование невозможно, то возвращается 0.0. 

  \declare{.to_c}{\# -> complex}
  Преобразует текст в комплексное число. Обработка продолжается до первого символа, не относящегося к цифрам. Если текст начинается с такого символа или преобразование невозможно, то возвращается (0+0i).

  \declare{.hex}{\# -> integer}
  Преобразует текст, обрабатывая его как число в шестнадцатеричной системе счисления. Обработка продолжается до первого символа, не относящегося к цифрам. Если текст начинается с такого символа или преобразование невозможно, то возвращается 0.

  \declare{.oct}{\# -> integer}
  Преобразует текст, обрабатывая его как число в шестнадцатеричной системе счисления. Обработка продолжается до первого символа, не относящегося к цифрам. Если текст начинается с такого символа или преобразование невозможно, то возвращается 0.
{\noindent
\begin{Parallel}{\textwidth}{0.55\textwidth}
\ParallelLText{
\begin{alltt}
"1".to_i # -> 1
"1a".to_i # -> 1
"1x".to_i # -> 1
"1.2" .to_i # -> 1
"4/2" .to_i # -> 4
"1 + 2".to_i # -> 1
"1   2".to_i # -> 1
"1e2".to_i # -> 1
"1_2".to_i # -> 12
"0b01 ax".to_i # -> 0
"0x01 ax".to_i # -> 0
"1+1i".to_i # -> 1\
\end{alltt} }
\ParallelRText{
\begin{alltt}
"1".to_f # -> 1.0
"1a".to_f # -> 1.0
"1x".to_f # -> 1.0
"1.2" .to_f # -> 1.2
"4/2" .to_f # -> 4.0
"1 + 2".to_f # -> 1.0
"1   2".to_f # -> 1.0
"1e2".to_f # -> 100.0
"1_2".to_f # -> 12.0
"0b01 ax".to_f # -> 0.0
"0x01 ax".to_f # -> 0.0
"1+1i".to_f # -> 1.0\
\end{alltt} }
\ParallelPar
\ParallelLText{
\begin{alltt}
"1".hex # -> 1
"1a".hex # -> 26
"1x".hex# -> 1
"1.2".hex # -> 1
"4/2".hex # -> 4
"1 + 2".hex # -> 1
"1   2".hex # -> 1
"1e2".hex # -> 482
"1_2".hex # -> 18
"0b01 ax".hex # -> 2817
"0x01 ax".hex # -> 1
"1+1i".hex # -> 1\
\end{alltt} }
\ParallelRText{
\begin{alltt}
"1".oct # -> 1
"1a".oct # -> 1
"1x".oct # -> 1
"1.2" .oct # -> 1
"4/2" .oct # -> 4
"1 + 2".oct # -> 1
"1   2".oct # -> 1
"1e2".oct # -> 1
"1_2".oct # -> 10
"0b01 ax".oct # -> 1
"0x01 ax".oct # -> 1
"1+1i".oct # -> 1\
\end{alltt} }
\ParallelPar
\ParallelLText{
\begin{alltt}
"1".to_r # -> 1/1
"1a".to_r # -> 1/1
"1x".to_r # -> 1/1
"1.2" .to_r # -> 6/5
"4/2" .to_r # -> 2/1
"1 + 2".to_r # -> 1/1
"1   2".to_r # -> 1/1
"1e2".to_r # -> 100/1
"1_2".to_r # -> 12/1
"0b01 ax".to_r # -> 0/1
"0x01 ax".to_r # -> 0/1
"1+1i".to_r # -> 1/1\
\end{alltt} }
\ParallelRText{
\begin{alltt}
"1".to_c # -> 1+0i
"1a".to_c # -> 1+0i
"1x".to_c # -> 1+0i
"1.2" .to_c # -> 1.2+0i
"4/2" .to_c # -> 2/1+0i
"1 + 2".to_c # -> 1+0i
"1   2".to_c # -> 1+0i
"1e2".to_c # -> 100.0 + 0i
"1_2".to_c # -> 12+0i
"0b01 ax".to_c # -> 0+0i
"0x01 ax".to_c # -> 0+0i
"1+1i".to_c # -> 1+1i\
\end{alltt} }
\end{Parallel}}
\end{methodlist}

\subsection*{Элементы текста}

Любой текст может быть обработан как индексный массив, содержащий отдельные символы в качестве элементов. 

В классе String определены операторы \method{[]} и \method{[]=}, использующиеся для получения и изменения части текста. Индексация символов начинается с нуля. Если индекс отрицательный, то отсчет символов ведется справа налево, начиная с -1.

\subsubsection*{string.[*object]}

\alias{slice(*object)}

\begin{methodlist}
  \declare{string[integer]}{\# -> string2}
  Возвращает символ с указанным индексом. Если индекс выходит за пределы текста, то возвращается nil.
  \begin{verbatim}
  "abc"[2] # -> "c"
  "abc"[4] # -> nil
  \end{verbatim}

  \declare{string[ start, length ]}{\# -> string2}
  Возвращает часть текста (длиной length), начиная с символа с переданным индексом (start). 
  \begin{itemize}
    \item Если количество символов выходит за пределы текста, то возвращается текст до последнего символа;
    \item Если количество символов равно нулю, то возвращается пустой текст ("");
    \item Если количество символов отрицательно, то возвращается nil;
    \item Если индекс выходит за пределы текста, то возвращается пустой текст ("");
  \end{itemize}
  \begin{verbatim}
  "abc"[ 2, 1 ] # -> "c"
  "abc"[ 2, 2 ] # -> "c"
  "abc"[ 2, 0 ] # -> ""
  "abc"[ 2, -1 ] # -> nil
  "abc"[ 3, 1 ] # -> ""
  \end{verbatim}

  \declare{string[range]}{\# -> string2}
  Возвращает символы между индексами, заданными в качестве границ диапазона. 
  \begin{itemize}
    \item Если конечная граница выходит за пределы текста, то возвращается текст до последнего символа;

    \item Если конечная граница меньше, чем начальная, то возвращается пустой текст ("");

    \item Если начальная граница выходит за пределы текста, то возвращается nil.
  \end{itemize}
  \begin{verbatim}
  "abc"[ 1..3 ] # -> "bc"
  "abc"[ 1...3 ] # -> "bc"
  "abc"[ 1...5 ] # -> "bc"
  "abc"[ 1...0 ] # -> ""
  "abc"[ 5...9 ] # -> nil
  \end{verbatim}

  \declare{string[template]}{\# -> string2}
  Возвращает часть текста, совпадающую с образцом. Если совпадений не найдено, то возвращается nil.
  \begin{verbatim}
  "abc"[ /[b-z]+/ ] # -> "bc"
  "abc"[ /b-z+/ ] # -> nil
  \end{verbatim}

  \declare{string[ reg, group ]}{\# -> string2}
  Возвращает часть текста, совпадающую с группой в теле регулярного выражения (передается идентификатор группы). Если совпадений не найдено, то возвращается nil.
  \begin{verbatim}
  "abc"[ /(b)c/, 1 ] # -> "b"
  "abc"[ /(b)c/, 3 ] # -> nil
  \end{verbatim}
\end{methodlist}

\subsubsection*{string.[*object]=}

Метод изменяет объект, для которого был вызван. В результате вызова возвращается заменяемый фрагмент.

\begin{methodlist}
  \declare{string[integer] = string2}{\# -> string2}
  Изменяет символ с указанным индексом. Если индекс выходит за пределы текста, то вызывается ошибка.
  \begin{verbatim}
  "abc"[2] = "d" # -> "d"
  "abc"[4] = "d"  # -> error!
  \end{verbatim}

  \declare{string[ start, length ] = string2}{\# -> string2}
  Изменяет часть текста (длиной length), начиная с символа с переданным индексом (start).
  \begin{itemize}
    \item Если индекс выходит за пределы текста, то вызывается ошибка;
    \item Если количество символов выходит за пределы текста, то заменяются символы до конца текста;
    \item Если количество символов равно нулю, то выполняется вставка текста;
    \item Если количество символов отрицательно, то вызывается ошибка.
  \end{itemize}
  \begin{verbatim}
  "abc"[ 4, 1 ] = "d" # -> error!
  "abc"[ 3, 1 ] = "d" # -> "d"
  string # -> "abdc"
  "abc"[ 2, 1 ] = "d" # -> "d"
  string # -> "abd"
  "abc"[ 2, 2 ] = "d" # -> "d"
  string # -> "abd"
  "abc"[ 2, 0 ] = "d" # -> "d"
  string # -> "abdc"
  "abc"[ 2, -1 ] = "d" # -> error!
  \end{verbatim}

  \declare{string[range] = string2}{\# -> string2}
  Изменяет символы между индексами, заданными в качестве границ диапазона. 
  \begin{itemize}
    \item Если конечная граница выходит за пределы текста, то заменяются символы до конца текста;
    \item Если конечная граница меньше, чем начальная, то текст вставляется перед символом с индексом, заданным начальной границей диапазона;
    \item Если начальная граница выходит за пределы текста, то вызывается ошибка.
  \end{itemize}
  \begin{verbatim}
  "abc"[ 1...2 ] = "d" # -> "d"
  string # -> "adc"
  "abc"[1...5] = "d" # -> "d"
  string # -> "ad"
  "abc"[ 1...0 ] = "d" # -> "d"
  string # -> "adbc"
  "abc"[ 5...9 ] = "d" # -> error!
  \end{verbatim}

  \declare{string[template] = string2}{\# -> string2}
  Изменяет часть текста, совпадающую с образцом. Если совпадений не найдено, то вызывается ошибка.
  \begin{verbatim}
  "abc"[ /[b-z]+/ ] = "d" # -> "d"
  string # -> "ad"
  "abc"[ /b-z+/ ] = "d" # -> error!
  \end{verbatim}

  \declare{string[ reg, group ]}{\# -> string2}
  Изменяет часть текста, совпадающую с группой в теле регулярного выражения (передается идентификатор группы). Если совпадений не найдено, то вызывается ошибка.
  \begin{verbatim}
  "abc"[ /(b)c/, 1 ] = "d" # -> "d"
  a # -> "adc"
  "abc"[ /(b)c/, 3 ] = "d" # -> error!
  \end{verbatim}
\end{methodlist}

\subsubsection*{Остальное}

\begin{methodlist}
  \declare{.binslice( start, length = nil)}{\# -> string}
  \verb!(range) # -> string!

  Действие метода аналогично вызову \method{.slice}, но вместо индекса символа передается порядковый номер байта.

  \declare{.length}{\# -> integer}
  \alias{size}
  Возвращает количество символов в тексте.
  \\\verb!"abc".length # -> 3!

  \declare{.bytesize}{\# -> integer}
  Возвращает количество байтов, занимаемых текстом.
  \\\verb!"abc".bytesize # -> 3!

  \declare{.getbyte(index)}{\# -> integer}
  Возвращает байт с переданым индексом. Если индекс байта выходит за пределы текста, то возвращается nil.
  \\\verb!"abc".getbyte 0 # -> 97!

  \declare{.setbyte( index, byte )}{\# -> integer}
  Изменяет байт с переданным индексом. Если индекс байта выходит за пределы текста, то вызывается ошибка.
  \begin{verbatim}
  "abc".setbyte 0, 120 # -> 120
  string # -> "xbc"
  \end{verbatim}
\end{methodlist}


\subsection*{Операторы}

\begin{methodlist}
  \declare{string \% object}{\# -> string2}
  Форматирование объекта.

  \declare{string * integer}{\# -> string2}
  Копирование текста.

  \declare{string + string2}{\# -> string3}
  Объединение текста.

  \declare{string \twoless string2}{\# -> string}
  Добавление текста.

  \declare{string <=> object}{}
  Сравнение объектов.

  \declare{string =\textasciitilde\-, template}{\# -> integer}
  Выполняется поиск совпадений с образцом и возвращает индекс символа, с которого совпадение начинается. Если совпадений не найдено, то возвращается nil.

  Если переданный объект не относится к регулярным выражениям, то интерпретатор выполняет \verb!object =~ string! и возвращает результат выполнения.
\end{methodlist}

\subsection*{Изменение текста}

\subsubsection*{Изменение регистра}

\begin{methodlist}
  \declare{.capitalize}{\# -> string}
  Изменяет первый символ в тексте на прописной, а остальные символы - на строчные. Обрабатываются только ASCII символы.
  \\\verb!"aBc".capitalize # -> "Abc"!

  \declare{.capitalize!}{\# -> self}
  Версия предыдущего метода, изменяющая значение объекта.

  \declare{.upcase}{\# -> string}
  Изменяет все символы в тексте на прописные. Обрабатываются только ASCII символы.
  \\\verb!"aBc".upcase # -> "ABC"!

  \declare{.upcase!}{\# -> self}
  Версия предыдущего метода, изменяющая значение объекта.

  \declare{.downcase}{\# -> string}
  Изменяет все символы в тексте на строчные. Обрабатываются только ASCII символы.
  \\\verb!"aBc".downcase # -> "abc"!

  \declare{.downcase!}{\# -> self}
  Версия предыдущего метода, изменяющая значение объекта.

  \declare{.swapcase}{\# -> string}
  Изменяет регистр всех символов в тексте на противоположный. Обрабатываются только ASCII символы.
  \\\verb!"aBc".swapcase # -> "AbC"!

  \declare{.swapcase!}{\# -> self}
  Версия предыдущего метода, изменяющая значение объекта, для которого метод был вызван.
\end{methodlist}

\subsubsection*{Удаление символов}

\begin{methodlist}
  \declare{.clear}{\# -> self}
  Изменяет значение объекта, удаляя из текста все символы.
  \\\verb!"abc".clear # -> ""!

  \declare{.slice!(*object)}{\# -> string}
  Аналогично выполнению \verb!self[*object] = ""!. В результате возвращается удаленная часть текста.
  \begin{verbatim}
  "abc".slice! 2 # -> "c"
  string # -> "ab"
  \end{verbatim}

  \declare{.chomp( last = \$/ )}{\# -> string}
  Удаляет один символ из конца текста (по умолчанию - символ перевода строки).
  \\\verb!"abc".chomp ?c # -> "ab"!

  \declare{.chomp!( string = \$/ )}{\# -> self}
  Версия предыдущего метода, изменяющая значение объекта. Если ни один символ не был удален, то возвращается nil.

  \declare{.chop}{\# -> string}
  Удаляет последний символ в тексте.
  \\\verb!"abc".chop # -> "ab"!

  \declare{.chop!}{\# -> self}
  Версия предыдущего метода, изменяющая значение объекта. Если ни один символ не был удален, то возвращается nil.

  \declare{.strip}{\# -> string}
  Удаляет все пробельные символы (пробел, отступ, перевод строки) из начала и конца текста.
  \\\verb!" abc ".strip # -> "abc"!

  \declare{.strip!}{\# -> self}
  Версия предыдущего метода, изменяющая значение объекта. Если ни один символ не был удален, то возвращается nil.

  \declare{.lstrip}{\# -> string}
  Удаляет все пробельные символы (пробел, отступ, перевод строки) из начала текста.
  \\\verb!" abc ".lstrip # -> "abc "!

  \declare{.lstrip!}{\# -> self}
  Версия предыдущего метода, изменяющая значение объекта. Если ни один символ не был удален, то возвращается nil.

  \declare{.rstrip}{\# -> string}
  Удаляет все пробельные символы (пробел, отступ, перевод строки) из конца текста.
  \\\verb!" abc ".rstrip # -> " abc"!

  \declare{.rstrip!}{\# -> self}
  Версия предыдущего метода, изменяющая значение объекта. Если ни один символ не был удален, то возвращается nil.
\end{methodlist}

\subsubsection*{Добавление символов}

\begin{methodlist}
  \declare{.insert( index, string )}{\# -> self}
  Аналогично выполнению \verb!self[index] = string!.
  \begin{verbatim}
  "abc".insert 2, ?d # -> "abdc"
  string # -> "abdc"
  \end{verbatim}

  \declare{.prepend(string)}{\# -> self}
  Изменяет значение объекта, добавляя в начало переданный методу текст.
  \\\verb!"Ruby".prepend "Pure " # -> "Pure Ruby"!

  \declare{.center( length, string = "~" )}{\# -> string2}
  Добавляет в начало и конец текста недостающее количество символов (до length). Если ни один символ не был добавлен, то возвращается ссылка на объект, для которого метод был вызван.
  \\\verb|"abc".center 6, ?! # -> "!abc!!"|

  \declare{.ljust( length, string = "~" )}{\# -> string2}
  Добавляет в конец текста недостающее количество символов (до length). Если ни один символ не был добавлен, то возвращается ссылка на объект, для которого метод был вызван.
  \\\verb|"abc".ljust 6, ?! # -> "abc!!!"|

  \declare{.rjust( length, string = "~" )}{\# -> string2}
  Добавляет в начало текста недостающее количество символов (до length). Если ни один символ не был добавлен, то возвращается ссылка на объект, для которого метод был вызван.
  \\\verb|"abc".rjust 6, ?! # -> "!!!abc"|
\end{methodlist}

\subsubsection*{Экранирование символов}

\begin{methodlist}
  \declare{.dump}{\# -> string}
  Экранирует все спецсимволы. Сам текст при этом экранируется двойными кавычками. Символы, не относящиеся к ASCII кодировке заменяются на их кодовые позиции.
  \begin{verbatim}
  "3\\n/2".dump # -> "\"3\\\\n/2\""
  "3\\n/2л".dump # -> "\"3\\\\n/2\\u{43b}\""
  \end{verbatim}

  \declare{.inspect}{\# -> string}
  Экранирует все спецсимволы. Сам текст при этом экранируется двойными кавычками.
  \begin{verbatim}
  "3\verb!\n!/2".inspect # -> "\"3\\verb!\\n!/2\""
  "3\verb!\n!/2л".inspect # -> "\"3\\verb!\\n!/2л\""
  \end{verbatim}
\end{methodlist}

\subsubsection*{Остальное}

\begin{methodlist}
  \declare{.next}{\# -> string}
  \alias{succ}

  Увеличивает кодовую позицию последнего символа на единицу. При этом возможна цепная реакция.
  \\\verb!"xyz".next # -> "xza"!

  \declare{.next!}{\# -> self}
  Синонимы: \method{succ!}

  Версия предыдущего метода, изменяющая значение объекта.

  \declare{.reverse}{\# -> string}
  Переставляет символы в обратном порядке.
  \\\verb!"abc".reverse # -> "cba"!

  \declare{.reverse!}{\# -> self}
  Версия предыдущего метода, изменяющая значение объекта.

  \declare{.replace(string)}{\# -> self}
  Синонимы: \method{initialize_copy}

  Изменяет значение объекта на переданное.
  \\\verb!"abc".replace ?? # -> "?"!

  \declare{.unpack(string)}{\# -> array}
  Интерпретатор распаковывает двоичный текст, используя переданную \hyperlink{apppack}{\underline{форматную строку}}.
  \\\verb!"\xFF\xFE\xFD".unpack "C*" # -> [ 255, 254, 253 ]!
\end{methodlist}

\subsection*{Поиск совпадений}

\subsubsection*{Поиск}

\begin{methodlist}
  \declare{.count(*template)}{\# -> integer}
  Возвращает количество найденных символов. Для образца позволяется использовать спецсимволы \textasciicircum\-, (отрицание) и - (диапазон). 

  Если методу передается несколько объектов, то выполняется пересечения множеств.
  \\\verb!"abc".count "a-z", "^c" # -> 2!

  \declare{.index( template, start = 0 )}{\# -> integer}
  Возвращает индекс символа, с которого начинается совпадение. Поиск совпадений выполняется начиная с символа, имеющего переданный индекс.

  Если совпадений не найдено, то возвращается nil.
  \\\verb!"abbc".index /b/ # -> 1!

  \declare{.rindex( template, start = 0 )}{\# -> integer}
  Возвращает индекс символа, с которого начинается совпадение. Поиск совпадений выполняется справа налево, до символа с переданным индексом (start).

  Если совпадений не найдено, то возвращается nil.
  \\\verb!"abbc".rindex /b/ # -> 2!

  \declare{.match( template, start = 0 )}{\# -> match}
  \verb!( template, start = 0 ) { |match| } # -> object!

  Возвращает экземпляр класса MatchData, содержащий информацию о найденных совпадениях. Поиск совпадений начинается с символа, имеющего переданный индекс (start). Если совпадений не найдено, то возвращается nil.

  \declare{.partition(template)}{\# -> array}
  Возвращает индексный массив, состоящий из трех элементов: части текста до совпадения, части текста, совпадающей с образцом, и части текста, после совпадения.

  Если совпадений не найдено, то в качестве первого элемента возвращается весь текст, а вместо остальных элементов - пустой текст ("").
  \\\verb!"abbc".partition /b/ # -> [ "a", "b", "bc" ]!

  \declare{.rpartition(template)}{\# -> array}
  Возвращает индексный массив, состоящий из трех элементов: части текста до совпадения, части текста, совпадающей с образцом и части текста, после совпадения. Поиск совпадений происходит справа налево.

  Если совпадений не найдено, то в качестве первого элемента возвращается весь текст, а вместо остальных элементов - пустой текст ("").
  \\\verb!"abbc".rpartition /b/ # -> [ "ab", "b", "c" ]!

  \declare{.split( sep = \$;, size = nil )}{\# -> array}
  Возвращает индексный массив, состоящий из частей текста. Деление на фрагменты выполняется на основе переданного разделителя (по умолчанию пробел). Несколько пробельных символов в тексте при этом игнорируются.

  Если методу передается пустое регулярное выражение, то текст делится на фрагменты посимвольно.

  Также возможно ограничит размер массива.
  \begin{verbatim}
  "a  b  c".split # -> [ "a", "b", "c" ]
  "a  b  c".split // # -> [ "a", " ", " ", "b", " ", " ", "c" ]
  "a  b  c".split //, 2 # -> [ "a", "  b  c" ]
  \end{verbatim}
\end{methodlist}

\subsubsection*{Удаление совпадений}

\begin{methodlist}
  \declare{.delete(*template)}{\# -> string}
  Удаляет из текста все найденные символы. Для образца позволяется использовать спецсимволы \textasciicircum\-, (отрицание) и - (диапазон).

  Если методу передается несколько объектов, то выполняется пересечение множеств. 
  \\\verb!"abc".delete "a-z", "^A-Z" # -> ""!

  \declare{.delete!(*template)}{\# -> self}
  Версия предыдущего метода, изменяющая значение объекта. Если ни один символ не был удален, то возвращается nil.

  \declare{.squeeze(*template)}{\# -> string}
  Удаляет все найденные рядом стоящие дублированные символы. Для образца позволяется использовать спецсимволы \textasciicircum\-, (отрицание) и - (диапазон).

  Если методу передается несколько объектов, то выполняется пересечение множеств.
  \\\verb!"aabbcc".squeeze "a-z", "^A-Z" # -> "abc"!

  \declare{.squeeze!(*template)}{\# -> self}
  Версия предыдущего метода, изменяющая значение объекта. Если ни один символ не был удален, то возвращается nil.
\end{methodlist}

\subsubsection*{Замена совпадений}

\begin{methodlist}
  \declare{.gsub( template, replace )}{\# -> string}
  \verb!(template) { |match| } # -> string!

  Изменяет в тексте все найденные совпадения. При этом совпадающие фрагменты либо передаются в блок (и заменяются на результат выполнения блока), либо заменяются на объекты, ассоциируемые с соответствующими ключами (идентификаторами групп), либо заменяются на переданный методу текст, где текст также может иметь вид \verb!'\1'! или \verb!'\K <идентификатор>'!.
  \begin{verbatim}
  "abcab".gsub /(a)b/, '\1' # -> "aca"
  "abcab".gsub /(a)b/, 'ab' => ?y  # -> "ycy"
  "abcab".gsub( /(a)b/ ) \{ |match| match.next \} # -> "accac"
  \end{verbatim}

  \declare{.gsub!( template, replace )}{\# -> self}
  \verb!(template) { |match| } # -> self!

  Версия предыдущего метода, изменяющая значение объекта. Если ни один символ не был изменен, то возвращается nil.

  \declare{.sub( template, replace )}{\# -> string}
  \verb!(template) { |match| } # -> string!

  Изменяет в тексте первое найденное совпадение. При этом совпавший фрагменты либо передаются в блок (и заменяются на результат выполнения блока), либо заменяются на объекты, ассоциируемые с соответствующими ключами (идентификаторами групп), либо заменяются на переданный методу текст, где текст также может иметь вид \verb!'\1'! или \verb!'\K <идентификатор>'!.
  \begin{verbatim}
  "abcab".sub /(a)b/, '\1'  # -> "acab"
  "abcab".sub /(a)b/, 'ab' => ?y # -> "ycab"
  "abcab".sub( /(a)b/ ) \{ |match| match.next \} # -> "accab"
  \end{verbatim}

  \declare{.sub!( template, replace )}{\# -> self}
  \verb!(template) { |match| } # -> self!

  Версия предыдущего метода, изменяющая значение объекта. Если ни один символ не был изменен, то возвращается nil.

  \declare{.tr( template, replace )}{\# -> string}
  Изменяет все найденные символы. Для образца позволяется использовать спецсимволы \textasciicircum\-, (отрицание) и - (диапазон), а в заменяющем фрагменте только -.
  \\\verb!"abc".tr "^x-z", "X-Z" # -> "ZZZ"!

  \declare{.tr!( template, replace )}{\# -> self}
  Версия предыдущего метода, изменяющая значение объекта. Если ни один символ не был изменен, то возвращается nil.

  \declare{.tr_s( template, replace )}{\# -> string}
  Изменяет все найденные символы. При этом удаляются рядом стоящие дублированные символы. Для образца позволяется использовать спецсимволы \textasciicircum\-, (отрицание) и - (диапазон), а в заменяющем фрагменте только -.
  \\\verb!"aabbcc".tr_s "^x-z", "X-Z" # -> "Z"!

  \declare{.tr_s!( template, replace )}{\# -> self}
  Версия предыдущего метода, изменяющая значение объекта. Если ни один символ не был изменен, то возвращается nil.
\end{methodlist}

\subsection*{Предикаты}

\begin{methodlist}
  \declare{.empty?}{}
  Проверяет является ли текст пустым (\mono{""}).
  \\\verb!"abc".empty? # -> false!

  \declare{.ascii_only?}{}
  Проверяет содержит ли текст только ASCII символы.
  \\\verb!"Heлlo".ascii_only? # -> false!

  \declare{.include?(template)}{}
  Проверяет в тексте наличие совпадений. 
  \\\verb!"abc".include? "ab" # -> true!

  \declare{.end_with?(*template)}{}
  Проверяет наличие суффикса. 

  Если методу передается несколько объектов, то выполняется пересечение множеств.
  \\\verb!"abc".end_with? "a", "c" # -> true!

  \declare{.start_with?(*template)}{}
  Проверяет наличие приставки. 

  Если методу передается несколько объектов, то выполняется пересечение множеств.
  \\\verb!"abc".start_with? "a", "c" # -> true!
\end{methodlist}

\subsection*{Итераторы}

\begin{methodlist}
  \declare{.each_byte \{|byte|\}}{\# -> self}
  Синонимы: \method{bytes}

  Последовательно перебирает каждый байт текста.

  \declare{.each_char \{|char|\}}{\# -> self}
  Синонимы: \method{chars}

  Последовательно перебирает каждый символ в тексте.

  \declare{.each_line( sep = \$/ ) \{|line|\}}{\# -> self}
  Синонимы: \method{lines}

  Последовательно перебирает каждую строку в тексте. Также принимается произвольный разделитель для строк (по умолчанию - символ перевода строки).

  \declare{.each_codepoint \{|point|\}}{\# -> self}
  Синонимы: \method{codepoints}

  Последовательно перебирает кодовую позицию каждого символа в тексте.

  \declare{.upto( last, ending = false ) \{|string|\}}{\# -> self}
  Последовательно перебирает либо элементы диапазона \verb!self..last!, либо элементы диапазона \verb!self...last! (если методу передается логическая величина true).
\end{methodlist}

\subsection*{Кодировка символов}

\begin{methodlist}
  \declare{.valid_encoding?}{}
  Проверяет корректна ли информация о кодировке текста.

  \declare{.encoding}{\# -> encoding}
  Возвращает экземпляр класса Encoding, содержащий информацию о кодировке текста.
  \\\verb!"абв".encoding # ->  #<Encoding:UTF-8>!

  \declare{.force_encoding(encoding)}{\# -> self}
  Изменяет информацию о кодировке текста.

  \declare{.encode( encoding = Encoding.default_internal, options = \{\} )}{\# -> string}
  \verb!( encoding, result, options = {} ) # -> string!

  Перекодирует текст либо в переданную кодировку, либо из одной кодировки в другую. Элементы ассоциативного массива описаны в \hyperlink{appenocde}{\underline{приложении}}.

  \declare{.encode!( encoding = Encoding.default_internal, options = \{\} )}{\# -> self}
  \verb!( encoding, result, options = {} ) # -> self!

  Версия предыдущего метода, изменяющая значение объекта.
\end{methodlist}

\subsection*{Остальное}

\begin{methodlist}
  \declare{.ord}{\# -> integer}
  Возвращает первый байт в тексте. Если текст пуст, то вызывается ошибка.
  \\\verb!"abc".ord # -> 97!

  \declare{.crypt(salt)}{\# -> string}
  Кодирует текст с помощью переданного объекта, подходящего под образец вида \verb!/[\w\d./]{2,2}/!
  \\\verb!"abc".crypt "z1" # -> "z1Pgo5xjkEf8U"!

  \declare{.sum( salt = 16 )}{\# -> integer}
  Возвращает контрольную сумму. Контрольная сумма - это \verb!(сумма всех байт) % 2**salt - 1!.
  \\\verb!"abc".sum # -> 294!

  \declare{.hash}{\# -> integer}
  Возвращает цифровой код объекта.  
  \\\verb!"abc".hash # -> -913021130!

  \declare{.casecmp(object)}{}
  Аналогично выполнению \verb!self <=> object!. Регистр символов при этом не учитывается.
\end{methodlist}

\section{Регулярные выражения}

\subsection{Regexp}

\begin{keylist}{Константы}
  
  \firstkey{\constant{Regexp::IGNORECASE}} - регистр символов игнорируется (модификатор i);
  
  \key{\constant{Regexp::EXTENDED}} - пробельные символы и комментарии игнорируются (модификатор x);
  
  \key{\constant{Regexp::MULTILINE}} - многострочный режим (модификатор m);
  
  \key{\constant{Regexp::FIXEDENCODING}} - другая кодировка;
\end{keylist}

\begin{methodlist}
  \declare{::new( template, object = nil )}{\# -> regexp}
  \alias{compile}
  Создание нового регулярного выражения с помощью текста или другого регулярного выражения. Вторым аргументом передаются константы класса или произвольные объекты:
  \begin{itemize}
    \item если логическое значение аргумента true, то регистр символов будет игнорироваться;

    \item если передаются символы \verb!?n! или \verb!?N!, то в теле регулярного выражения используется ASCII кодировка.
  \end{itemize}
  \verb!Regexp.new "abc", 2 # -> /abc/x!

  \declare{::union( *template или array = nil )}{\# -> regexp}
  Создание регулярного выражения на основе переданных аргументов (выполняется объединение множеств). Без аргументов возвращается /!?/.
  \\\verb!Regexp.union [ ?0, ?1, ?2 ] # -> /0|1|2/!
\end{methodlist}

\subsubsection*{Преобразование типов}

\begin{methodlist}
  \declare{::try_convert(object)}{\# -> regexp}
  Преобразует объект в регулярное выражение с помощью метода \method{.to_regexp}. Если метод для объекта не определен, то возвращается nil.
  \\\verb!Regexp.try_convert "abc" # -> nil!

  \declare{.to_s}{\# -> string}
  Возвращает текст, содержащий тело регулярного выражения и его модификаторы.
  \\\verb!/(a-z)/i.to_s # -> "(?i-mx:(a-z))"!

  \declare{.inspect}{\# -> string}
  Возвращает текст, содержащий регулярное выражение.
  \\\verb!/(a-z)/i.inspect # -> "/(a-z)/i"!

  \declare{.source}{\# -> string}
  Возвращает текст, содержащий тело регулярного выражения c экранированными спецсимволами.
  \\\verb!/(a-z)/i.source # -> "(a-z)"!
\end{methodlist}

\subsubsection*{Операторы}

\begin{methodlist}
  \declare{regexp === string}{\# -> bool}
  Аналогично выполнению regexp =~ string.

  \declare{regexp =\textasciitilde\-, string}{\# -> integer}
  Поиск совпадений.

  \declare{\textasciitilde\-, regexp}{\# -> integer}
  Аналогично выполнению \verb!regexp =~ $_!.
\end{methodlist}

\subsubsection*{Поиск совпадений}

\begin{methodlist}
  \declare{::last_match}{\# -> match}
  \verb!(group) # -> string!

  Возвращается информация о последнем поиске совпадений. Если совпадений не найдено, то возвращается nil. 

  \declare{.match( text, start = 0 )}{\# -> match}
  \verb!( text, start = 0 ) { |match| } # -> object!

  Возвращает экземпляр класса MatchData содержащий информацию о найденных совпадениях. Поиск совпадений начинается с символа имеющего переданный индекс (start). Если совпадений не найдено, то возвращается nil.
\end{methodlist}

\subsubsection*{Кодировка символов}

\begin{methodlist}
  \declare{.encoding}{\# -> encoding}
  Возвращает используемую кодировку.
  \\\verb!/(a-z)/i.encoding # -> #<Encoding:US-ASCII>!

  \declare{.fixed_encoding?}{}
  Проверяет используется ли любая кодировка, кроме ASCII.
  \\\verb!/(a-z)/i.fixed_encoding? # -> false!
\end{methodlist}

\subsubsection*{Остальное}

\begin{methodlist}
  \declare{.casefold?}{}
  Проверяет игнорируется ли регистр символов (модификатор i).
  \\\verb!/(a-z)/i.casefold? # -> true!

  \declare{.named_captures}{\# -> hash}
  Возвращает массив идентификаторов групп, ассоциируемых с их позициями.
  \\\verb!/(?<group>a-z)/i.named_captures # -> {"group" => [1]}!

  \declare{.names}{\# -> array}
  Возвращает индексный массив, содержащий идентификаторы групп.
  \\\verb!/(?<group>a-z)/i.names # -> ["group"]!

  \declare{.options}{\# -> integer}
  Возвращает сумму чисел используемых модификаторов.
  \\\verb!/(a-z)/i.options # -> 1!

  \declare{.hash}{\# -> integer}
  Возвращает цифровой код объекта.  
  \\\verb!/(a-z)/i.hash # -> -145911848!

  \declare{::escape(text)}{\# -> string}
  \alias{quote}
  Экранирует спецсимволы. 
  
  При этом \verb!Regexp.new( Regexp.escape string ) =~ string # -> 0!
  \\\verb!Regexp.escape "'\*?{}.'" # -> "'\\*\\?\\{\\}\\.'"!
\end{methodlist}

\subsection{MatchData}
 
Экземпляры класса содержат полную информацию о найденных совпадениях.

\subsubsection*{Преобразование типов}

\begin{methodlist}
  \declare{.to_s}{\# -> string}
  Возвращает полный текст найденного совпадения.

  \declare{.inspect}{\# -> string}
  Возвращает текст, содержащий информацию об объекте.

  \declare{.to_a}{\# -> array}
  Возвращает индексный массив, содержащий все элементы найденного совпадения.
\end{methodlist}

\subsubsection*{Элементы поиска}

\begin{methodlist}
  \declare{match[index]}{\# -> string}
  Возвращает фрагмент, совпадающий с группой, имеющей переданный индекс (полный  текст совпадения - элемент с индексом 0).

  \declare{match[ first, last ]}{\# -> array}
  Возвращает индексный массив, содержащий фрагменты, совпадающие с группами, индекс которых входит между границами диапазона \verb!first..last!. Если границы диапазона отрицательны, то отсчет групп ведется справа налево.

  \declare{match[range]}{\# -> array}
  Возвращает индексный массив, содержащий фрагменты, совпадающие с группами, индекс которых входит между границами диапазона. Если границы отрицательны, то отсчет групп ведется справа налево.

  \declare{match[name]}{\# -> string}
  Возвращает фрагмент, совпадающий с группой, имеющей переданный идентификатор.

  \declare{.captures}{\# -> array}
  Возвращает индексный массив, содержащий фрагменты, совпадающие со всеми нумерованными группами.

  \declare{.offset(group)}{\# -> array}
  Возвращает индексный массив, содержащий индексы символов, с которых началось и которыми закончилось совпадение фрагмента с группой.

  \declare{.begin(group)}{\# -> integer}
  Возвращает индекс символа, с которого началось совпадение фрагмента с группой.

  \declare{.end(group)}{\# -> integer}
  Возвращает индекс символа, которым заканчивается совпадение фрагмента с группой.

  \declare{.pre_match}{\# -> string}
  Возвращает часть текста перед найденным совпадением.

  \declare{.post_match}{\# -> string}
  Возвращает часть текста после найденного совпадения.
\end{methodlist}

\subsubsection*{Остальное}

\begin{methodlist}
  \declare{.regexp}{\# -> regexp}
  Возвращает регулярное выражение, с которым происходило сравнение.

  \declare{.string}{\# -> string}
  Возвращает неизменяемую копию текста, в котором выполнялся поиск совпадений.

  \declare{.size}{\# -> integer}
  \alias{length} 
  Возвращает количество всех элементов поиска (включая полный текст совпадения).

  \declare{.names}{\# -> array}
  Возвращает индексный массив, содержащий идентификаторы групп регулярного выражения.

  \declare{.hash}{\# -> integer}
  Интерпретатор возвращает цифровой код объекта.
\end{methodlist}

\section{Кодировка}

\subsection{Кодировка текста}

Для работы с кодировками в Ruby предоставлен класс Encoding. Его экземпляры содержат информацию о кодировке, используемой в тексте.

В классе определены константы для каждой поддерживаемой кодировки. Вместо них также могут использоваться заранее определенные синонимы.
\\\verb!Encoding::UTF_8 # -> #<Encoding:UTF-8>! 

\subsubsection*{Поддерживаемые кодировки}

\begin{methodlist}
  \declare{::default_external}{\# -> encoding} 
  Возвращает внешнюю кодировку, используемую по умолчанию. 
 

  \declare{::default_external= (encoding)}{\# -> encoding} 
  Изменяет внешнюю кодировку, используемую по умолчанию. 

  \declare{::default_internal}{\# -> encoding} 
  Возвращает внутреннюю кодировку, используемую по умолчанию. 
 

  \declare{::default_internal= (encoding)}{\# -> encoding} 
  Изменяет внутреннюю кодировку, используемую по умолчанию. Передача nil удаляет информацию о кодировке.

  \declare{::locale_charmap}{\# -> string} 
  Возвращает системную кодировку. 
 
  \declare{::list}{\# -> array} 
  Возвращает массив всех поддерживаемых кодировок. 
 
  \declare{::name_list}{\# -> array} 
  Возвращает массив всех синонимов. 
 
  \declare{::aliases}{\# -> hash} 
  Возвращает массив синонимов, ассоциируемых с экземплярами класса. 
 
  \declare{::find(aliases)}{\# -> encoding} 
  Возвращает кодировку, соответствующую переданному синониму. Передача не поддерживаемого синонима приводит к вызову ошибки (для внутренней кодировки может возвращаться nil).

  Методу также могут быть переданы объекты: 
  \begin{description}
    \item["external"] - внешняя кодировка;
    \item["internal"] - внутренняя кодировка;
    \item["locale"] - локальная кодировка пользователя;
    \item["filesystem"] - кодировка файловой системы.
  \end{description}
 
  \declare{::compatible?( string, string2 )}{\# -> encoding} 
  Проверяет совместимость кодировок в переданных текстах. Если они совместимы, то в результате возвращается кодировка, поддерживаемая обоими. В другом случае возвращается nil. 
  \\\verb!Encoding.compatible? "асции", "utf-8" # -> #<Encoding:UTF-8>!
\end{methodlist}

\subsubsection*{Экземпляры}

\begin{methodlist}
  \declare{.inspect}{\# -> string} 
  Возвращает информацию об объекте. 
  \\\verb!Encoding::UTF_8.inspect # -> "#<Encoding:UTF-8>"!
 
  \declare{.name}{\# -> string} 
  \alias{to_s} 
  Возвращает информацию о кодировке. 
  \\\verb!Encoding::UTF_8.name # -> "UTF-8"!
 
  \declare{.names}{\# -> array} 
  Возвращает массив всех доступных синонимов.
  \begin{verbatim}
  Encoding::UTF_8.names 
  # -> ["UTF-8", "CP65001", "locale", "external", "filesystem"]
  \end{verbatim}  
 
  \declare{.ascii_compatible?}{} 
  Проверяет совместима ли кодировка с ASCII. 
  \\\verb!Encoding::UTF_8.ascii_compatible? # -> true!
 
  \declare{.dummy?}{} 
  Проверяет является ли кодировка фиктивной. Для фиктивных кодировок обработка символов не реализована должным образом. Метод используется для динамичных кодировок. 
  \\\verb!Encoding::UTF_8.dummy? # -> false!

  \declare{.replicate(name)}{\# -> encoding} 
  Создает новый объект, использующий ту же структуру. Использование уже существующего имени приведет к вызову ошибки.
  \\\verb!Encoding::UTF_8.replicate "утф8" # -> #<Encoding:утф8>!
\end{methodlist}

\subsection{Преобразование кодировок}

Для расширенного преобразования между различными кодировками в Ruby предоставлен класс Encoding::Converter.

\begin{keylist}{Константы:}
  
  \firstkey{Encoding::Converter::INVALID_MASK} - возврат ошибки при преобразовании некорректных байтов;
  
  \key{Encoding::Converter::INVALID_REPLACE} - замена символов при преобразовании некорректных байтов; 
  
  \key{Encoding::Converter::UNDEF_MASK} - возврата ошибки при преобразовании неопределенных символов; 
  
  \key{Encoding::Converter::UNDEF_REPLACE} - замена символов при преобразовании неопределенных символов; 
  
  \key{Encoding::Converter::UNDEF_HEX_CHARREF} - замена символов на байты \verb!&xHH! при преобразовании неопределенных символов; 
  
  \key{Encoding::Converter::UNIVERSAL_NEWLINE_DECORATOR} - замена CR (\verb!\r!) и CRLF (\verb!\r\n!) на LF (\verb!\n!); 
  
  \key{Encoding::Converter::CRLF_NEWLINE_DECORATOR} - замена LF (\verb!\n!) на CRLF (\verb!\r\n!); 
  
  \key{Encoding::Converter::CR_NEWLINE_DECORATOR} - замена LF (\verb!\n!) на CR (\verb!\r!); 
  
  \key{Encoding::Converter::XML_TEXT_DECORATOR}
  
  \key{Encoding::Converter::XML_ATTR_CONTENT_DECORATOR}
  
  \key{Encoding::Converter::XML_ATTR_QUOTE_DECORATOR}
  
  \key{Encoding::Converter::PARTIAL_INPUT} - обработка исходного текста как части другого объекта; 
  
  \key{Encoding::Converter::AFTER_OUTPUT} - цикличное преобразование исходного текста.
\end{keylist}

\begin{methodlist}
  \declare{::new( source_enc, dest_enc, options = nil )}{\# -> converter} 
  \verb!(conv_path) # -> converter!

  Создание объекта. Принимаются исходная кодировка и требуемая. Дополнительный объект влияет на \hyperlink{appencode}{\underline{преобразование}}.

  Если передается массив, то он считается путем преобразования и должен содержать двухэлементные подмассивы для каждого отдельного преобразования. Дополнительными элементами могут быть элементы, влияющие на преобразование (ассоциируемые с логической величиной).
\end{methodlist} 
 
\subsubsection*{Поиск необходимых кодировок}

\begin{methodlist}
  \declare{::asciicompat_encoding(encoding)}{\# -> encoding}
  Возвращает кодировку одновременно совместимую с переданной и с ASCII. Если это переданная кодировка, то возвращается nil.
  \begin{verbatim}
  Encoding::Converter.asciicompat_encoding "utf-8" # -> nil 
  Encoding::Converter.asciicompat_encoding "utf-16le" 
  # -> #<Encoding:UTF-8>
  \end{verbatim}

  \declare{::search_convpath( source_enc, dest_enc, options = nil )}{\# -> array}
  Возвращает путь преобразования.
  \begin{verbatim}
  Encoding::Converter.search_convpath "ISO-8859-1", "EUC-JP",
    universal_newline: true 
  # -> [ [ #<Encoding:ISO-8859-1>, #<Encoding:UTF-8> ],
  #   [ #<Encoding:UTF-8>, #<Encoding:EUC-JP> ],
  #   "universal_newline" ]
  \end{verbatim}
\end{methodlist}

\subsubsection*{Статистика}

\begin{methodlist}
  \declare{.inspect}{\# -> string} 
  Возвращает информацию об объекте.
  \begin{verbatim}
  Encoding::Converter.new( "ISO-8859-1", "EUC-JP" ).inspect 
  # -> "#<Encoding::Converter: ISO-8859-1 to EUC-JP>"
  \end{verbatim} 
 
  \declare{.convpath}{\# -> array} 
  Возвращает ссылку путь преобразования.
  \begin{verbatim}
  Encoding::Converter.new( "ISO-8859-1", "EUC-JP" ).convpath 
  # -> [ [ #<Encoding:ISO-8859-1>, #<Encoding:UTF-8> ],
  #   [ #<Encoding:UTF-8>, #<Encoding:EUC-JP> ] ]
  \end{verbatim}
 
  \declare{.source_encoding}{\# -> encoding} 
  Возвращает исходную кодировку.
  \begin{verbatim}
  Encoding::Converter.new("ISO-8859-1",
    "EUC-JP").source_encoding 
  # -> #<Encoding:ISO-8859-1>
  \end{verbatim}
 
  \declare{.destination_encoding}{\# -> encoding} 
  Возвращает требуемую кодировку. 
  \begin{verbatim}
  Encoding::Converter.new("ISO-8859-1",
    "EUC-JP").destination_encoding 
  # -> #<Encoding:EUC-JP>
  \end{verbatim}

  \declare{.replacement}{\# -> string} 
  Возвращает текст для замены некорректных байтов или неопределенных символов. 
  \begin{verbatim}
  Encoding::Converter.new( "ISO-8859-1", "EUC-JP" ).replacement
  # -> "?"
  \end{verbatim}
 
  \declare{.replacement= (string)}{\# -> string} 
  Изменяет текст для замены некорректных байтов или неопределенных символов. 
 
  \declare{.last_error}{\# -> error}
  Возвращает последнюю вызванную ошибку.
\end{methodlist}

\subsubsection*{Преобразование}

\begin{methodlist}
  \declare{.convert(text)}{\# -> string} 
  Преобразование текста. При обработке некорректных байтов или неопределенных символов в любом случае вызывается ошибка. 
 
  \declare{.primitive_convert( text, result, start = nil, bytesize = nil, options = nil )}{\# -> symbol}
  Преобразование из одного текста в другой. Позволяется ограничивать фрагмент, в который сохраняется результат (по умолчанию в конец текста). Дополнительный аргумент влияет на преобразование.

  \begin{keylist}{Дополнительные элементы:}
    
    \firstkey{partial_input: true}, исходный текст может быть частью другого объекта;          
    
    \key{after_output: true}, после получения результата, ожидается новый исходный текст.
  \end{keylist}
 
  Преобразование завершается при выполнении одного из следующих условий (в скобках указан возвращаемый результат):
  \begin{enumerate}
    \item Исходный текст содержит некорректные байты \\* (\verb!:invalid_byte_sequence!);
    \item Неожиданный конец исходного текста. Это возможно, \\* если \verb!:partial_input! не задан (\verb!:incomplete_input!);
    \item Исходный текст содержит неопределенные символы \\* (\verb!:undefined_conversion!);
    \item Данные выводятся до их записи. Это возможно, \\* если ключ \verb!:after_output! не задан (\verb!:after_output!);
    \item Буфер назначенного объекта полон. Это возможно, \\* если bytesize не ссылается nil (\verb!:destination_buffer_full!);
    \item Исходный текст пуст. Это возможно, \\* если \verb!:partial_input! не задан (\verb!:source_buffer_empty!);
    \item Преобразование завершено (\verb!:finished!).
  \end{enumerate}

  \declare{.primitive_errinfo}{\# -> array} 
  Возвращает информацию о последней ошибке преобразования в виде:
  \verb![ symbol, source_enc, dest_enc, ivalid_byte, undef_char ]!, где symbol - результат последнего вызова метода \method{.primitive_convert}. Другие элементы имеют смысл только для :invalid_byte_sequence, :incomplete_input или :undefined_conversion.
 
  \declare{.putback}{\# -> string} 
  Возвращает часть текста, которую будет преобразовывать при следующем вызове \method{.primitive_convert}. 
 
  \declare{.insert_output(string)}{\# -> nil} 
  Переаднный текст будет преобразован после завершения работы с объектом. 
  Если требуемая кодировка сохраняет свое состояние, то текст будет преобразован в соответствии с состоянием, которое будет обновлено после преобразования. Этот метод необходимо использовать только если при преобразовании между кодировками возникает ошибка. 
 
  \declare{.finish}{\# -> string} 
  Заканчивает преобразование и возвращает последний полученный результат. 
\end{methodlist}