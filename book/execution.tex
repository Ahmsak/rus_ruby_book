\chapter{Выполнение программы}

\section{Процесс выполнения}

Процесс выполнения - это непосредственное выполнение кода программы.

Процесс выполнения может быть разделен на три этапа: начало выполнения, выполнение программы и завершение выполнения.

BEGIN и END - это предложения, выполняющиеся в начале выполнения и перед завершением выполнения программы. Тело каждого предложения определяет собственную локальную область видимости и выполняется строго один раз.

\begin{description}
  \item[BEGIN \{ \}] - код выполняется в начале выполнения программы. Если в коде программы используется несколько таких предложений, то они выполняются последовательно в порядке записи;

  \item[END \{ \}] - код выполняется перед завершением выполнения программы. Если в коде программы используется несколько таких предложений, то они выполняются последовательно в обратном порядке. Для выполнения этого предложения используется экземпляр File, на который ссылается константа DATA;

  \item[__END__] - аналогично END; 

  \item[at_exit \{ \}] - аналогично END.
\end{description}

Для запуска программы в теле цикла (бесконечного выполнения программы) существует частный метод экземпляров из модуля Kernel.

\begin{methodlist}
  \declare{loop \{ \}}{}
  Тело блока итерируется до тех пор пока не будет вызвана ошибка \error{StopIteration} или одна из инструкций.
\end{methodlist}

\subsection{Перехват выполнения}

Перехватить выполнения программы можно объявив код (с помощью частных методов экземпляров из модуля Kernel), выполняемый при возникновении определенных событий.

\begin{methodlist}
  \declare{set_trace_func( proc = nil )}{}
  Объявление замыкания для перехвата выполнения. Перехват выполнения в теле замыкания при этом не выполняется.
  
  Замыканию передаются: идентификатор события, имя файла, номер строки кода, цифровой идентификатор объекта, экземпляр класса Binding и идентификатор класса объекта.

  Передача nil отменяет перехват выполнения.
  
  Возможные события:
  \begin{description}
    \item["c-call"] - вызов Си функции;
    \item["c-return"] - завершение выполнения Си функции;
    \item["call"] - вызов Ruby метода;
    \item["return"] - завершение выполнения Ruby метода;
    \item["class"] - начало определения класса или модуля;
    \item["end"] - завершение определения класса или модуля;
    \item["line"] - выполнение новой строки кода;
    \item["raise"] - вызов ошибки. 
  \end{description}

  \declare{trace_var( name, code )}{\# -> nil}
  \verb!(name) { |object| } -> nil!
  
  Объявление кода для перехвата изменения глобальной переменной. В блок передается новое значение.

  \declare{untrace_var( name, code = nil )}{\# -> array}
  Отмена перехвата выполнения при изменении глобальной переменной. Возвращается массив, содержащий выполняемый при перехвате код.
\end{methodlist}

\subsection{Завершение программы}

Для завершения выполнения программы используются частные методы экземпляров из модуля Kernel (методы влияют на любой поток выполнения, в теле которого взываются).

\begin{methodlist}
  \declare{sleep( sec = nil )}{\# -> sec}
  Останавливает выполнение (по умолчанию навсегда). В результате возвращается время фактического ожидания.

  \declare{exit( state = true )}{}
  Завершает выполнение, вызывая ошибку \error{SystemExit}. 

  \declare{exit!( state = false )}{}
  Немедленно завершает выполнение.

  \declare{abort( mesage = nil )}{} 
  Немедленно завершает выполнение. Аргумент записывается в стандартный поток для вывода ошибок. Аналогично выполнению \verb!exit false!.
\end{methodlist}

\section{Вызов системных команд}

На Ruby довольно часто создают небольшие скрипты, облегчающие вызов различных системных команд. Для этого используются частные методы экземпляров из модуля Kernel.

\begin{methodlist}
  \declare{Kernel.`(code)}{\# -> string}
  Текст между двумя "обратными" кавычками (\verb!`ruby --help`!) обрабатывается как составной и передается для выполнения операционной системе. 
  
  Тот же эффект достигается при ограничении текста произвольными разделителями с использованием приставки \verb!%x! (\verb!%x[ruby --help]!).

  \declare{exec( env, command, options )}{}
  Заменяет текущий процесс, выполняя системный вызов. Код, записанный после вызова метода не выполняется. Если команда не может быть выполнена, то вызывается ошибка.

  \begin{keylist}{Принимаемые аргументы:}

    \firstkey{env (hash):} управление переменными окружения.
    \begin{description}
      \item[name:] значение для переменной окружения;
      \item[name:] nil, удаление переменной окружения.
    \end{description}

    \key{command:} системный вызов.
    \begin{description}
      \item[string] - текст команды для используемой оболочки: по умолчанию в Unix - это \verb!"/bin/sh"!, а в Windows - \verb!ENV["RUBYSHELL"]! или \verb!ENV["COMSPEC"]!;
      \item[string, *arg] - текст команды и передаваемые аргументы;
      \item[{[ string, first_arg ], *arg}] - текст команды, первый аргумент и остальные аргументы. 
    \end{description}

    \key{option (hash):} дополнительный аргумент.
    \begin{description}
      \item[unsetenv_others:] true, удаление всех переменных окружения, кроме переданных методу;
      \item[pgroup:] группировка процессов:
        \begin{itemize}
          \item true для создания новой группы;
          \item integer для сохранения процесса в соответствующей группе;
          \item nil для отмены группировки.
        \end{itemize}
      \item[chdir:] путь к текущему рабочему каталогу;
      \item[umask:] права доступа для создаваемых файлов или каталогов. 
    \end{description}
  \end{keylist}

  \declare{syscall( number, *object = nil )}{}
  Вызывает функцию операционной системы с переданным цифровым идентификатором (для Unix систем идентификаторы и функции описаны в файле syscall.h).

  Дополнительно (не более девяти аргументов) методу передаются либо текст, содержащий указатель на последовательность байт, либо размер указателя в битах.

  Если вызов системной функции невозможен, то вызывается ошибка \error{SystemCallEror}.
  Если вызов метода невозможен, то вызывается ошибка \error{NotImplementedError}.

  Метод непереносим и небезопасен в использовании.
\end{methodlist}