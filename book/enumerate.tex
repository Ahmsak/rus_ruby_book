\chapter{Составные объекты}

Все составные объекты добавляют модуль Enumerable, содержащий набор методов, работающих на основе вызова метода \method{.each}.

\section{Array}

Индексные массивы.

Добавленные модули: Enumerable 

\begin{methodlist}
  \declare{::new( size = 0, object = nil )}{\# -> array}
  \verb!(array) # -> array!
  \verb!(size) { |index| } # -> array!

  Создание индексного массива. Размер массива может изменяться в зависимости от переданных аргументов. Элементы определяются в результате выполнения блока или ссылаются на дополнительно переданный методу объект.
  \begin{verbatim}
  Array.new 3, ?R # -> [ "R", "R", "R" ]
  Array.new [ 1, 2 ] # -> [ 1, 2 ]
  Array.new(3) \{ |index| index**2 \} # -> [ 0, 1, 4 ]\
  \end{verbatim}

  \declare{Array[*object]}{\# -> array}
  Возвращает индексный массив, содержащий переданные аргументы. 
  \\\verb!Array[ 1, 2, 3 ] # -> [ 1, 2, 3 ]!
\end{methodlist}

\subsection*{Приведение типов} 

\begin{methodlist}
  \declare{::try_convert(object)}{\# -> array}
  Преобразование объекта в индексный массив с помощью вызова метода \method{.to_ary}. Если для объекта этот метод не определен, то возвращается nil. 
  \\\verb!Array.try_convert 1 # -> nil!

  \declare{.to_s}{\# -> string} 
  \alias{inspect}
  Преобразование массива в текст. 
  \\\verb![ 1, 2, 3 ].to_s # -> "[1, 2, 3]"!

  \declare{.to_a}{\# -> array} 
  \alias{to_ary}

  \declare{.join( sep = \$, )}{\# -> string}
  Преобразует индексный массив в текст, используя переданный разделитель (по умолчанию nil).
  \begin{verbatim}
  [ 1, 2, 3 ].join # -> "123"

  [
     "#{msg}",
     "Class: <#\{e.class\}>",
     "Message: <#\{e.message.inspect\}>",
     "---Backtrace---",
     "#\{MiniTest::filter_backtrace(e.backtrace).join("\textbackslash n")\}",
     "---------------",
    ].join "\textbackslash n"\
  \end{verbatim}  

  \declare{.pack(format)}{\# -> string}
  Интерпретатор упаковывает массив в двоичный текст, используя переданную \hyperlink{apppack}{\underline{форматную строку}}.
  \\\verb![ -1, -2, -3 ].pack "C*" # -> "\xFF\xFE\xFD"!
\end{methodlist}

\subsection*{Элементы массива}

Для доступа к элементам используются операторы \method{[]} и \method{[]=}. Индексация элементов начинается с нуля. Если индекс отрицательный, то отсчет элементов ведется справа налево, начиная с -1. Наиболее частая проблема с массивами - передача индекса, выходящего за пределы массива.

\subsubsection*{array.[*object]} 
\alias{slice(*object)}

\begin{methodlist}
  \declare{array[index]}{\# -> object}
  \alias{at}
  Возвращает элемент с переданным индексом. Если индекс выходит за пределы массива, то возвращается nil.
  \begin{verbatim}
  [ 1, 2, 3 ][2] # -> 3 
  [ 1, 2, 3 ][4] # -> nil\
  \end{verbatim}

  \declare{array[ start, size ]}{\# -> array} 
  Возвращает часть массива.
  \begin{itemize}
    \item Если количество элементов выходит за пределы массива, то возвращается вся часть массива до последнего элемента;
    \item Если количество элементов равно нулю, то возвращается ссылка на пустой массив (\mono{[]});
    \item Если количество элементов отрицательно, то возвращается nil; 
    \item Если индекс выходит за пределы массива, то возвращается пустой массив.
  \end{itemize}
  \begin{verbatim}
  [ 1, 2, 3 ][ 2, 1 ] # -> [3] 
  [ 1, 2, 3 ][ 2, 2 ] # -> [3] 
  [ 1, 2, 3 ][ 2, 0 ] # -> [ ] 
  [ 1, 2, 3 ][ 2, -1 ] # -> nil 
  [ 1, 2, 3 ][ 3, 1 ] # -> [ ]\
  \end{verbatim}  

  \declare{array[range]}{\# -> object} 
  Возвращает элементы между индексами, заданными в качестве границ диапазона.
  \begin{itemize}
    \item Если конечная граница выходит за пределы массива, то возвращается вся часть массива до последнего элемента;
    \item Если конечная граница меньше, чем начальная, то возвращается пустой массив;
    \item Если начальная граница выходит за пределы массива, то возвращается nil. 
   \end{itemize} 
  \begin{verbatim}
  [ 1, 2, 3 ][ 1...3 ] # -> [ 2, 3 ] 
  [ 1, 2, 3 ][ 1...5 ] # -> [ 2, 3 ] 
  [ 1, 2, 3 ][ 1...0 ] # -> [ ] 
  [ 1, 2, 3 ][ 5...9 ] # -> nil\
  \end{verbatim}
\end{methodlist}

\subsubsection*{array.[*object] =}

Вызов метода приведет к изменению значения объекта. В результате возвращается измененный элемент или массив элементов. 

Если индекс выходит за пределы массива, то массив автоматически расширяется. При этом промежуточные элементы ссылаются на nil. 

Если индекс выходит за начало массива, то вызывается ошибка. 

\begin{methodlist}
  \declare{array[index] = object}{\# -> object}
  Изменяет элемент с переданным индексом. 
  \begin{verbatim}
  [ 1, 2, 3 ][2] = "d" # -> "d" 
  array # -> [ 1, 2, "d" ] 
  [ 1, 2, 3 ][4] = "d"  # -> "d" 
  array # -> [ 1, 2, 3, "d" ]\
  \end{verbatim}

  \declare{array[ start, size ] = object}{\# -> object} 
  Изменяет часть массива: если количество элементов равно нулю, то выполняется вставка элементов, а если количество элементов отрицательно, то вызывается ошибка.
  \begin{verbatim}
  [ 1, 2, 3 ][ 4, 1 ] = "d" # -> "d" 
  array # -> [ 1, 2, 3, nil, "d" ] 
  [ 1, 2, 3 ][ 3, 1 ] = "d" # -> "d" 
  array # -> [ 1, 2, 3, "d" ] 
  [ 1, 2, 3 ][ 2, 1 ] = "d" # -> "d" 
  array # -> [ 1, 2, "d" ] 
  [ 1, 2, 3 ][ 2, 2 ] = "d" # -> "d" 
  array # -> [ 1, 2, "d" ] 
  [ 1, 2, 3 ][ 2, 0 ] = "d" # -> "d" 
  array # -> [ 1, 2, "d", 3 ] 
  [ 1, 2, 3 ][ 2, -1 ] = "d" # -> error!\
  \end{verbatim}

  \declare{array[range] = object}{\# -> object} 
  Изменяет элементы между индексами, заданными в качестве границ диапазона. 
  Если конечная граница меньше, чем начальная, то элементы добавляются перед индексом, заданным начальной границей диапазона.
  \begin{verbatim}
  [ 1, 2, 3 ][1...2] = "d" # -> "d" 
  array # ->[ 1, "d", 3 ] 
  [ 1, 2, 3 ][1...5] = "d"# -> "d" 
  array # -> [ 1, "d" ] 
  [ 1, 2, 3 ][1...0] = "d"# -> "d" 
  array # -> [ 1, "d", 2, 3 ] 
  [ 1, 2, 3 ][5...9] = "d"# -> "d" 
  array # -> [ 1, 2, 3, nil, nil, "d" ]\
  \end{verbatim}
\end{methodlist}

\subsubsection*{Остальное}

\begin{methodlist}
  \declare{.fetch(index, object)}{\# -> object2}
  \verb!(index) { |index| } # -> object!

  Аналогично выполнению \verb!array[index]!. Дополнительный аргумент используется, если индекс выходит за пределы массива.
  \\\verb![ 1, 2, 3 ].fetch 3, 4 # -> 4!

  \declare{.values_at(*object)}{\# -> array} 
  Аналогично выполнению \verb!array[*object]! для каждого переданного объекта.
  \\\verb![ 1, 2, 3 ].values_at 1, 1 # -> [ 2, 2 ]!

  \declare{.sample( size = nil )}{\# -> object} 
  Возвращает ссылку на случайный элемент массива (или на массив случайных элементов). Для пустых массивов возвращается соответственно nil или пустой массив. Если аргумент равен или превышает размеры массива, то в результате элементы просто перестраиваются в случайном порядке.
  \\\verb![ 1, 2, 3 ].sample 4 # -> [ 2, 1, 3 ]!

  \declare{.last(size = 1)}{\# -> object}
  Возвращает ссылку либо на последний элемент массива, либо на массив последних элементов.
  \\\verb![ 1, 2, 3 ].last 2 # -> [ 2, 3 ]!

  \declare{.index(object)}{\# -> integer}
  \verb!{ |object| } # -> integer!

  Возвращает индекс элемента либо равного переданному объекту, либо с логическим значением итерации true. 
  \\\verb![ 1, 2, 3 ].index { |elem| elem < 3 } # -> 0!

  \declare{.rindex(object)}{\# -> integer}
  \verb!{ |object| } # -> integer!

  Возвращает индекс элемента либо равного переданному объекту, либо с логическим значением итерации true. Поиск элементов выполняется справа налево. 
  \\\verb![ 1, 2, 3 ].rindex { |elem| elem < 3 } # -> 1!
\end{methodlist}

\subsection*{Операторы}

\begin{methodlist}
  \declare{array * integer}{\# -> array2}
  Копирование. 

  \declare{array * sep}{\# -> string} 
  Преобразует тело массива в текст, используя переданный разделитель. 
  \\\verb![ 1, 2, 3 ] * ?? # -> "1?2?3"!

  \declare{array + array2}{\# -> array3} 
  Объединение элементов. 

  \declare{array - array2}{\# -> array3} 
  Удаление элементов. 

  \declare{array \twoless object}{\# -> array}
  Добавление элемента.  Изменяется значение объекта.

  \declare{array \& array2}{\# -> array3} 
  Пересечение множеств.

  \declare{array | array2}{\# -> array3} 
  Объединение множеств. 
\end{methodlist}

\subsection*{Изменение массивов}

\subsubsection*{Добавление элементов}

\begin{methodlist}
   \declare{.push(object)}{\# -> self}
  Изменяет значение объекта, добавляя в конец массива переданный методу объект.
  \\\verb![ 1, 2, 3 ].push 2 # -> [ 1, 2, 3, 2 ]!

  \declare{.unshift(object)}{\# -> self}
  Изменяет значение объекта, добавляя в начало массива переданный методу объект. 
  \\\verb![ 1, 2, 3 ].unshift 2 # -> [ 2, 1, 2, 3 ]!
\end{methodlist}

\subsubsection*{Удаление элементов} 

\begin{methodlist}
  \declare{.pop( size = 1 )}{\# -> object} 
  Изменяет значение объекта, удаляя элементы из конца массива. В результате возвращается либо удаленный объект, либо массив удаленных объектов. 
  \\\verb![ 1, 2, 3 ].pop 2 # -> [ 2, 3 ]!

  \declare{.shift( size = 1 )}{\# -> object} 
  Изменяет значение объекта, удаляя элементы из начала массива. В результате возвращается либо удаленный объект, либо массив удаленных объектов. 
  \\\verb![ 1, 2, 3 ].shift 2 # -> [ 1, 2 ]!

  \declare{.clear}{\# -> self}
  Изменяет значение объекта, удаляя все элементы.
  \\\verb![ 1, 2, 3 ].clear # -> [ ]!

  \declare{.compact}{\# -> array}
  Удаляет из массива все элементы, ссылающиеся на nil. 
  \\\verb![ 1, 2, 3 ].compact # -> [ 1, 2, 3 ]!

  \declare{.compact!}{\# -> self} 
  Версия предыдущего метода, изменяющая значение объекта. 

  \declare{.uniq}{\# -> array}
  Удаляет из массива все повторяющиеся элементы. 
  \\\verb![ 1, 2, 3, 3, 2, 1 ].uniq # -> [ 1, 2, 3 ]!

  \declare{.uniq!}{\# -> array} 
  Версия предыдущего метода, изменяющая значение объекта. Если ни один элемент не был удален, то возвращается nil. 

  \declare{.slice!(*object)}{\# -> object} 
  Изменяет значение объекта, удаляя из массива элементы \verb!array[*object]!.
  \\\verb|[ 1, 2, 3 ].slice! 1, 1 # -> [ 2 ]|

  \declare{.delete(object) \{ nil \}}{\# -> object}
  Изменяет значение объекта, удаляя из массива все элементы, равные переданному аргументу. В результате возвращается удаленный элемент. 
  Если ни один элемент не был удален, то возвращается либо nil, либо результат выполнения необязательного блока.
  \begin{verbatim}
  [ 1, 2, 3 ].delete(4) \{ "error!" \} # -> "error!"
  [ 1, 2, 3, 1 ].delete 1 # -> 1
  array # -> [ 2, 3 ]
  array = [ 2, 3, 4 ]
  [ 1, 2, 3 ].each { |elem| array.delete elem } # -> [ 1, 2, 3 ]
  array # -> [4]\
  \end{verbatim}

  \declare{.delete_at(index)}{\# -> object} 
  Изменяет значение объекта, удаляя элемент с переданным индексом. В результате возвращается удаленный объект. Если ни один элемент не был удален, то возвращается nil. 
  \begin{verbatim}
  [ 1, 2, 3 ].delete_at 1 # -> 2 
  array # -> [ 1, 3 ]\
  \end{verbatim}

  \declare{.delete_if \{ |object| \}}{\# -> self}
  \alias{reject!}
  Изменяет значение объекта, удаляя из массива все элементы, с логическим значением итерации true. Если ни один элемент не был удален, то возвращается nil.
  \\\verb![ 1, 2, 3 ].delete_if { |elem| elem < 3 } # -> [3]!

  \declare{.select! \{ |object| \}}{\# -> self} 
  Изменяет значение объекта, удаляя из массива все элементы, с логическим значением итерации false. Если ни один элемент не был удален, то возвращается nil.
  \\\verb?[ 1, 2, 3 ].select! { |elem| elem < 3 } # -> [ 1, 2 ]?
\end{methodlist}

\subsubsection*{Замена элементов} 

\begin{methodlist}
  \declare{.replace(array)}{\# -> self}
  \alias{initialize_copy} 
  Изменяет значение объекта, заменяя его переданным аргументом. 
  \\\verb![ 1, 2, 3 ].replace [ ] # -> [ ]!
 
  \declare{.insert( *(index, *object) )}{\# -> self}
  Аналогично выполнению \verb!array[integer] = *object! для каждой пары переданных методу объектов. Результат возвращается в виде объекта или массива объектов.
  \\\verb![ 1, 2, 3 ].insert 1, 2, 3 # -> [ 1, 2, 3, 2, 3 ]!
 
  \declare{.fill( object, start = 0, size = self.size )}{\# -> self}
  \verb!( start = 0, size = self.size ) { |index| } # -> self!
  \\\verb!( object, range ) # -> self!
  \\\verb!(range) { |index| } # -> self!

  Изменяет значение объекта, заменяя элементы \verb!array[ start, size ]! или \verb!array[range]! либо на переданный объект, либо на результат выполнения блока. 
  \\\verb![ 1, 2, 3 ].fill 1 # -> [ 1, 1, 1 ]!
\end{methodlist}

\subsubsection*{Остальное}

\begin{methodlist}
  \declare{.flatten( deep = nil )}{\# -> array}
  Извлекает элементы вложенных массивов до заданного уровня. По умолчанию извлекаются все элементы. 
  \\\verb![ [[1]], [[2]], [[3]] ].flatten # -> [ 1, 2, 3 ]!
 
  \declare{.flatten!(deep)}{\# -> self}
  Версия предыдущего метода, изменяющая значение объекта. 

  \declare{.rotate( step = 1 )}{\# -> array} 
  Вращает индексный массив на заданное число позиций. Если передано положительное число, то вращение происходит слева направо, если отрицательное, то справа налево.
  \begin{verbatim}
  [ 1, 2, 3 ].rotate  # -> [ 2, 3, 1 ]
  [ 1, 2, 3 ].rotate -1  # -> [ 3, 1, 2 ]\
  \end{verbatim}

  \declare{.rotate!( step = 1 )}{\# -> array}
  Версия предыдущего метода, изменяющая значение объекта. 
\end{methodlist}

\subsection*{Сортировка массива}

\begin{methodlist}
  \declare{.reverse}{\# -> array}
  Переставляет элементы индексного массива в обратном порядке. 
  \\\verb![ 1, 2, 3 ].reverse # -> [ 3, 2, 1 ]!

  \declare{.reverse!}{\# -> self}
  Версия предыдущего метода, изменяющая значение объекта. 

  \declare{.shuffle}{\# -> array}
  Переставляет элементы индексного массива в случайном порядке. 
  \\\verb![ 1, 2, 3 ].shuffle # -> [ 2, 3, 1 ]!

  \declare{.shuffle!}{\# -> self}
  Версия предыдущего метода, изменяющая значение объекта. 

  \declare{.sort!}{\# -> self}
  \verb!{ |object, object2| } # -> self!

  Изменяет значение объекта, сортируя элементы либо с помощью оператора \method{<=>}, либо с помощью результатов выполнения блока (-1, 0, 1 или nil).

  \declare{.sort_by! \{ |object, object2| \}}{\# -> self}
  Изменяет значение объекта, сортируя элементы массива в восходящем порядке, на основе результатов их итерации. 
\end{methodlist}

\subsection*{Итераторы}

\begin{methodlist}
  \declare{.each \{ |object| \}}{\# -> self} 
  Последовательно перебирает элементы индексного массива. 

  \declare{.each_index \{ |index| \}}{\# -> self}
  Последовательно перебирает индексы массива.

  \declare{.collect! \{ |object| \}}{\# -> self}
  \alias{map!}
  Изменяет значение объекта, заменяя элементы массива на результат их итерации.
  \begin{verbatim}
  [ 1, 2, 3 ].collect! { |elem| elem + 1 } # -> [ 2, 3, 4 ]
  [1,2,3].collect! &:to_s # -> ["1", "2", "3"]\
  \end{verbatim}
  

  \declare{.combination(size) \{ |array| \}}{\# -> self} 
  Последовательно перебираются все возможные массивы заданного размера, созданные на основе элементов объекта. Различный порядок элементов при этом игнорируется.
  \begin{itemize}
    \item Если методу передается ноль, то итерируется \verb![[]]!;
    \item Если переданное число больше, чем размер объекта, то итерируется пустой массив.
  \end{itemize}
  
  \declare{.repeated_combination(size) \{ |array| \}}{\# -> self}
  Версия предыдущего метода, в которой один и тот же элемент может использоваться несколько раз.

  \declare{.permutation( size = self.size ) \{ |array| \}}{\# -> self} 
  Версия метода, учитывающая различный порядок элементов.

  \declare{.repeated_permutation( size = self.size ) \{ |array| \}}{\# -> self} 
  Версия предыдущего метода, в которой один и тот же элемент может использоваться несколько раз. 
\end{methodlist}

\subsection*{Ассоциативные массивы}

\begin{methodlist}
  \declare{.assoc(key)}{\# -> array}
  Сравнивает переданный объект с первыми элементами вложенных подмассивов. В результате возвращается вложенный массив, содержащий первое найденное совпадение. Если совпадений не найдено, то возвращается nil. 
  \\\verb![ [ :a, 1 ], [ :b, 2 ], [ :a, 3] ].assoc :a # -> [:a, 1]!

  \declare{.rassoc(object)}{\# -> array} 
  Сравнивает переданный объект с вторыми элементами вложенных подмассивов. В результате возвращается вложенный массив, содержащий первое найденное совпадение. Если совпадений не найдено, то возвращается nil. 
  \\\verb![ [ :a, 1 ], [ :b, 2 ], [ :a, 3] ].rassoc :a # -> nil!
 
  \declare{.transpose}{\# -> array}
  Обрабатывает индексный массив, состоящий из вложенных подмассивов. В результате возвращается объект, состоящий из двух вложенных массивов. Первый содержит все первые элементы, а второй - оставшиеся элементы. 
  \\\verb![ [:a, 1], [:b, 1] ].transpose # -> [ [:a, :b ], [1, 1 ] ]!
\end{methodlist} 

\subsection*{Остальное}

\begin{methodlist}
  \declare{.product( *array = nil )}{\# -> array2}
  \verb!( *array = nil ) { |array2| } # -> array3!

  Создает массив из всех возможных подмассивов размером self.size, созданных на основе всех участвующих элементов. Учитывается разный порядок элементов. Каждый элемент может быть использован в подмассиве только один раз.
  \begin{itemize}
    \item При вызове без аргументов, подмассивы будут состоять из одного элемента;
    \item Если методу передается пустой массив, то в результате также возвращается пустой массив.
  \end{itemize}
  \begin{verbatim}
  [ 1, 2 ].product [3] # -> [ [1, 3], [2, 3] ]
  [ 1, 2, 3 ].product # -> [ [1], [2], [3] ] 
  [ 1, 2, 3 ].product [] # -> []\
  \end{verbatim}

  \declare{.hash}{\# -> integer} 
  Возвращает цифровой код объекта. 
  \\\verb![ 1, 2, 3 ].hash # -> -831861323!

  \declare{.empty?}{}
  Проверяет пуст ли массив. 
  \\\verb![ 1, 2, 3 ].empty? # -> false!

  \declare{.size}{\# -> integer}
  \alias{length}
  Возвращает количество элементов в индексном массиве. Результат всегда на единицу больше, чем индекс последнего элемента. 
  \\\verb![ 1, 2, 3 ].size # -> 3!
 \end{methodlist}

\section{Hash}

Ассоциативные массивы.

Добавленные модули: Enumerable 

\begin{methodlist}
  \declare{::new( object = nil )}{\# -> hash} 
  \verb!{ |hash, key| } # -> hash!

  Создание массива. Значение по умолчанию определяется с помощью дополнительного аргумента.

  \declare{Hash[ *(key, object) ]}{\# -> hash} 
  \verb![ *[key,object] ] # -> hash!
  \\\verb![object] # -> hash!

  Создание массива на основе переданных объектов.
  \begin{verbatim}
  Hash[ :Ruby, "languages", :Ivan, "man" ] 
  # -> \{ Ruby: "languages", Ivan: "man" \} 
  
  Hash[ [ [:Ruby, "languages"], [:Ivan, "man"] ] ] 
  # -> \{ Ruby: "languages", Ivan: "man" \} 
  
  Hash[ Ruby: "languages", Ivan: "man" ] 
  # -> \{ Ruby: "languages", Ivan: "man" \}\
  \end{verbatim}
\end{methodlist} 

\subsection*{Приведение типов}

\begin{methodlist}
  \declare{::try_convert(object)}{\# -> hash} 
  Преобразование объекта в массив, с помощью метода \method{.to_hash}. Если для объекта этот метод не определен, то возвращается nil. 
  \\\verb!Hash.try_convert[1] # -> nil!
 
  \declare{.to_s}{\# -> string} 
  \alias{inspect} 
  Преобразование массива в текст. Спецсимволы экранируются. 
  \\\verb!{ a: ?a, "b" => '\n' }.to_s # -> "{:a=>\"a\", \"b\"=>\"\\\\n\"}"!

  \declare{.to_a}{\# -> array }
  Преобразование ассоциативного массива в индексный вида \verb![ *[key, object] ]!. Спецсимволы экранируются.
  \\\verb!{ a: ?a, "b" => '\n' }.to_a # -> [ [ :a, "a" ], [ "b", "\\n" ] ]!

  \declare{.to_hash}{\# -> hash} 
\end{methodlist}

\subsection*{Элементы массива} 

\begin{methodlist}
  \declare{hash[key]}{\# -> object} 
  Возвращает объект, ассоциируемый с ключом. Если ключ не найден, то возвращается значение по умолчанию. 
  \\\verb!{ a: ?a, "b" => 1 }[:a] # -> "a"!
  
  \declare{.values_at(*key)}{\# -> array}
  Возвращает индексный массив, содержащий все объекты, ассоциируемые с переданными ключами. 
  \\\verb!{ a: ?a, "b" => 1 }.values_at :a, :b, ?b # ->  [ "a", nil, 1 ]!
  
  \declare{.select \{ | key, object | \}}{\# -> hash}
  Возвращает ассоциативный массив, содержащий все элементы, с логическим значением итерации true. 
  \\\verb!{ a: ?a, "b" => 1 }.select { |key| key == ?b } # -> { "b"=>1 }!
  
  \declare{.key(object)}{\# -> key}
  Возвращает ключ, ассоциированный с заданным объектом. Если ассоциируемый объект не найден, то возвращается nil. 
  \\\verb!{ a: ?a, "b" => 1 }.key ?a # -> :a!

  \declare{.keys}{\# -> array} 
  Возвращает индексный массив, содержащий все ключи. 
  \\\verb!{ a: ?a, "b" => 1 }.keys # -> [:a, "b"]!
 
  \declare{.values}{\# -> array} 
  Возвращает индексный массив, содержащий все ассоциируемые объекты. 
  \\\verb!{ a: ?a, "b" => 1 }.values # -> [ "a", 1 ]!
 
  \declare{hash[key] = (object)}{\# -> object} 
  \alias{store}
  Изменяет значение объекта заменяя или добавляя элемент в ассоциативный массив. 
  \begin{verbatim}
  \{ a: ?a, "b" => 1 \}[:a] = 2 # -> 2 
  hash # -> \{ :a => 2, "b" => 1 \}\
  \end{verbatim}
   
  \declare{.fetch( key, default = nil )}{\# -> object} 
  \verb!(key) { |key| } # -> object!

  Возвращает объект, ассоциируемый с ключом. Дополнительный аргумент используется если ключ не найден (иначе вызывается ошибка). 
  \\\verb!{ a: ?a, "b" => 1 }.fetch :b, ?a # -> "a"!
\end{methodlist}

\subsection*{Изменение массивов}

\subsubsection*{Добавление элементов}

\begin{methodlist} 
  \declare{.merge(hash)}{\# -> hash2}
  \verb!(hash) { | key, object, object2 | } # -> hash2!

  Объединение двух массивов. Для одинаковых ключей ассоциируемыми объектами станут либо объекты из переданного массива, либо объекты, возвращаемые в результате выполнения блока.
  \\\verb!{ a: ?a, "b" => 1 }.merge( { "b" => ?b } ) # -> { a: "a", "b" => "b" }!

  \declare{.merge!(hash)}{\# -> self} 
  \verb!(hash) { | key, object, object2 | } # -> self!

  \alias{update} 
  Версия предыдущего метода, изменяющая значение объекта. 
\end{methodlist}

\subsubsection*{Удаление элементов}

\begin{methodlist}
  \declare{.clear}{\# -> self} 
  Изменяет значение объекта, удаляя все элементы. 
  \\\verb!{ a: ?a, "b" => 1 }.clear # -> { }!
 
  \declare{.shift}{\# -> array} 
  Изменяет значение ассоциативного массива, удаляя первый элемент. В результате возвращается индексный массив вида \verb![ key, object ]!. 
  \\\verb!{ a: ?a, "b" => 1 }.shift # -> [ :a, "a" ]!
 
  \declare{.delete(key)}{\# -> object}
  \verb!(key) { |key| } # -> object!

  Изменяет значение объекта, удаляя указанный элемент. В результате возвращается ассоциируемый объект. Если ключ не найден, то возвращается значение по умолчанию или результат выполнения необязательного блока. 
  \begin{verbatim}
  \{ a: ?a, "b" => 1 \}.delete :a # -> "a"
  hash # -> \{ "b"=>1 \}\
  \end{verbatim}
 
  \declare{.delete_if \{ | key, object | \}}{\# -> self}
  Изменяет значение объекта, удаляя все элементы, с логическим значением итерации true. 
  \\\verb!{ a: ?a, "b" => 1 }.delete_if { |key| key == ?b } # -> { a: "a" }!
 
  \declare{.reject \{ | key, object | \}}{\# -> self}
  Аналогично выполнению \verb!self.delete_if { | key, object | }!. Значение объекта при этом не изменяется. 
  \\\verb!{ a: ?a, "b" => 1 }.reject { |key| key == ?b } # -> { a: "a" }!

  \declare{.reject! \{ | key, object | \}}{\# -> self}
  Аналогично выполнению \verb!self.delete_if { | key, object | }!. Если ни один объект не был удален, то возвращается nil. 
  \\\verb/{ a: ?a, "b" => 1 }.reject! { |key| key == ?c } # -> nil/
 
  \declare{.keep_if \{ | key, object | \}}{\# -> self}
  Изменяет значение объекта, удаляя все элементы, с логическим значением итерации false. 
  \\\verb!{ a: ?a, "b" => 1 }.keep_if { |key| key == ?b } # -> { "b"=>1 }!
 
  \declare{.select! \{ | key, object | \}}{\# -> self}
  Аналогично выполнению \verb!self.keep_if { | key, object | }!. Если ни один элемент не был удален, то возвращается nil. 
  \\\verb/{ a: ?a, "b" => 1 }.select! { |key| key == ?b } # -> { "b"=>1 }/
\end{methodlist}

\subsubsection*{Остальное} 

\begin{methodlist}
  \declare{.replace(hash)}{\# -> self}
  \alias{initialize_copy}
  Изменяет значение объекта, копируя переданный аргумент. 
  \\\verb!{ a: ?a, "b" => 1 }.replace( { } ) # -> { }!
 
  \declare{.invert}{\# -> hash}
  Возвращает ассоциативный массив, в котором ключи и объекты меняются местами.
  \\\verb!{ a: ?a, "b" => 1 }.invert # -> { "a" => :a, 1 => "b" }!
\end{methodlist}

\subsection*{Предикаты}

\begin{methodlist}
  \declare{.has_key?(key)}{} 
  \alias{include?, key?, member?} 
  Проверяет содержит ли массив элемент с переданным ключом. 
  \\\verb!{ a: ?a, "b" => 1 }.has_key? :a # -> true!
 
  \declare{.has_value?(object)}{} 
  \alias{value?} 
  Проверяет содержит ли массив элемент с переданным ассоциируемым объектом. 
  \\\verb!{ a: ?a, "b" => 1 }.has_value? :a # -> false!
 
  \declare{.compare_by_identity?}{} 
  Проверяет сравниваются ли все ключи по их объектам-идентификаторам. 
 
  \declare{.empty?}{} 
  Проверяет пуст ли ассоциативный массив. 
  \\\verb!{ a: ?a, "b" => 1 }.empty? # -> false!
\end{methodlist} 

\subsection*{Итераторы} 

\begin{methodlist}
  \declare{.each \{ | key, object | \}}{\# -> self} 
  \alias{each_pair} 
  Последовательно перебирает элементы. 
 
  \declare{.each_key \{ |key| \}}{\# -> self} 
  Последовательно перебирает ключи. 
 
  \declare{.each_value \{ |object| \}}{\# -> self} 
  Последовательно перебирает ассоциируемые объекты. 
\end{methodlist}

\subsection*{Индексные массивы}

\begin{methodlist}
  \declare{.assoc(key)}{\# -> array} 
  Возвращает индексный массив вида \verb![ key, object ]!. Если ключ не найден, то возвращается nil. Сравнение ключей выполняется с помощью оператора \method{==}. 
  \\\verb!{ a: ?a, "b" => 1 }.assoc :a # -> nil!
 
  \declare{.rassoc(object)}{\# -> array} 
  Возвращает индексный массив вида \verb![ key, object ]!. Если объект не найден, то возвращаетсяnil. Сравнение объектов выполняется с помощью оператора ==. 
  \\\verb!{ a: ?a, "b" => 1 }.rassoc ?a # -> [ :a, "a" ]!

  \declare{.flatten( deep = 0 )}{\# -> array} 
  Возвращает индексный массив, содержащий элементы ассоциативного. Все вложенные индексные массивы будут извлекаться до заданного уровня.
  \begin{verbatim}
  \{ 1 => "one", 2 => [ [2], ["two"] ], 3 => "three" \}.flatten 3 
  # -> [ 1, "one", 2, 2, "two", 3, "three" ]\
  \end{verbatim}
\end{methodlist}

\subsection*{Остальное}

\begin{methodlist}
  \declare{.compare_by_identity}{\# -> self} 
  Изменяет информацию об элементах ассоциативного массива, так что доступны будут только те элементы, ключами для которых служат объекты-идентификаторы. (То есть все ключи будут сравниваться по их объектам-идентификаторам). 
  \begin{verbatim}
  \{ a: ?a, "b" => 1 \}.compare_by_identity
  # -> \{ :a => "a", "b" => 1 \} 
  hash[:a] # -> "a" 
  hash["b"] # -> nil
  hash[:b] # -> nil
  hash.key 1 # -> "b"\
  \end{verbatim}

  \declare{.size}{\# -> integer} 
  \alias{length} 
  Возвращает количество элементов в ассоциативном массиве. 
  \\\verb!{ a: ?a, "b" => 1 }.size # -> 2!

  \declare{.default}{\# -> object} 
  Интерпретатор возвращает значение по умолчанию для ассоциативного массива. 
 
  \declare{.default_proc}{\# -> proc} 
  Интерпретатор возвращает замыкание, выполняемую как значение по умолчанию для ассоциативного массива. Если ее нет, то возвращается nil.

  \declare{.default = (object)}{\# -> object} 
  Объявление значения по умолчанию. 
 
  \declare{.default = proc}{\# -> proc} 
  Выполнение замыкания в качестве значения по умолчанию.

  \declare{.hash}{\# -> integer} 
  Возвращает цифровой код объекта. 
  \\\verb!{ a: ?a, "b" => 1 }.hash # -> -3034512!
 
  \declare{.rehash}{\# -> hash} 
  Интерпретатор заново вычисляет цифровые коды ключей для виртуальной таблицы.
\end{methodlist}

\section{Range} 

Диапазоны.

Добавленные модули: Enumerable 

Диапазоны требуется ограничивать круглыми скобками. В противном случае метод будет вызван только для конечной границы.

\begin{methodlist}
  \declare{::new( first, last, include_last = false )}{\# -> range} 
  Возвращает диапазон с переданными начальной и конечной границами. Логическая величина влияет на обработку конечной границы.
  \\\verb!Range.new 1, 5, 0 # -> 1...5!
\end{methodlist}

\subsection*{Приведение типов} 

\begin{methodlist}
  \declare{.inspect}{\# -> string} 
  Преобразование диапазона в текст, с помощью вызова метода \method{.inspect} для каждой границы. 
  \\\verb!(1..3).inspect # -> "1..3"!
 
  \declare{.to_s}{\# -> string} 
  Преобразует диапазон в текст. 
  \\\verb!(1..3).to_s # -> "1..3"!
\end{methodlist}

\subsection*{Элементы диапазона}

\begin{methodlist}
  \declare{.begin}{\# -> object} 
  Возвращает первый элемент диапазона. 
  \\\verb!(1..3).begin # -> 1!
 
  \declare{.end}{\# -> object} 
  Возвращает последний элемент диапазона. 
  \\\verb!(1..3).end # -> 3!
 
  \declare{.last( size = nil )}{\# -> array} 
  Возвращает последний элемент диапазона или массив конечных элементов. 
  \\\verb!(1..3).last 2 # -> [ 2, 3 ]!
\end{methodlist}
  
\subsection*{Операторы}

\begin{methodlist}
  \declare{range === object}{} 
  \alias{cover?, member?, include?}  
  Проверяет входит ли объект в диапазон.
  \\\verb!(1..3) === 2 # -> true!
\end{methodlist}

\subsection*{Итераторы}

\begin{methodlist}
  \declare{.each \{ |object| \}}{\# -> self}
  Последовательно перебирает элементы диапазона с помощью метода \method{.succ}. 
 
  \declare{.step( step = 1 ) \{ |object| \}}{\# -> self}
  Последовательно перебирает элементы диапазона с указанным шагом, либо прибавляя его после каждой итерации, либо используя метод \method{.succ}.
\end{methodlist} 

\subsection*{Остальное}

\begin{methodlist}
  \declare{.exclude_end?}{} 
  Проверяет входит ли конечная граница в диапазон. 
  \\\verb!(1..3).exclude_end? # -> false!

  \declare{.hash}{\# -> integer} 
  Возвращает цифровой код объекта. 
  \\\verb!(1..3).hash # -> -337569967!
\end{methodlist}

\section{Перечни (Класс Enumerator)}

Добавленные модули: Enumerable 

Перечни - это составные объекты, содержащие информацию о хранящихся элементах и о методе, вызов которого привел к их группировке. Индексация элементов начинается с нуля. 

Если вызвать метод, отправляющий элементы в блок и не передать ему блока, то в результате возвращается ссылка на перечень, содержащий все отправленные элементы. 

\begin{methodlist}
  \declare{::new( object, method, *arg )}{\# -> enum} 
  \verb!{ |enum| } # -> enum!

  Создание перечня с помощью переданного метода. 

  Результат также может быть передан в блок. В теле блока предоставляется возможность добавлять элементы в перечень с помощью выражения \verb!enum << object! (как синоним для yield). Тело блока будет выполняться в момент использования перечня.
  \begin{verbatim}
  Enumerator.new( [ 1, 2, ?R ], :delete_at, 2 ) 
  # -> #<Enumerator: [1, 2, "R"]:delete_at(2)> 
  Enumerator.new { |enum| enum << 3 } 
  # -> #<Enumerator: <Enumerator::Generator:0x87378e8>:each>\
  \end{verbatim}

  \declare{object.enum_for( method = :each, *arg = nil )}{\# -> enum} 
  \alias{to_enum}
  Аналогично выполнению \verb!Enumerator.new( object, method, *arg )!. 
  \\\verb![ 1, 2, ?R ].enum_for # -> #<Enumerator: [1, 2, "R"]:each>!
\end{methodlist}

\subsection*{Приведение типов}

\begin{methodlist}
  \declare{.inspect}{\# -> string} 
  Преобразует перечень в текст. 
  \begin{verbatim}
  Enumerate.new( [ 1, 2, ?R ], :delete_at, 2 ).inspect 
  # -> "#<Enumerator: [1, 2, \"R\"]:delete_at(2)>"\
  \end{verbatim}
\end{methodlist}

\subsection*{Элементы перечня}

\begin{methodlist}
  \declare{.next}{\# -> object} 
  Возвращает следующий элемент перечня, сохраняя его позицию. При достижении конца перечня вызывается событие \error{StopIteration}. 
 
  \declare{.next_values}{\# -> array} 
  Возвращает индексный массив, содержащий следующий элемент перечня, сохраняя его позицию. При достижении конца перечня вызывается событие \error{StopIteration}. Этот метод может быть использован для различия между инструкциями yield и yield nil. 
 
  \declare{.peek}{\# -> object} 
  Возвращает следующий элемент перечня. При достижении конца перечня вызывается событие \error{StopIteration}. 
 
  \declare{.peek_values}{\# -> array} 
  Возвращает индексный массив, содержащий следующий элемент перечня. При достижении конца перечня вызывается событие \error{StopIteration}. Этот метод может быть использован для различия между инструкциями yield и yield nil. 
 
  \declare{.rewind}{\# -> enum} 
  Обнуляет позицию последнего извлеченного элемента.
\end{methodlist}

\subsection*{Итераторы}

\begin{methodlist}
  \declare{.each( start = 0 ) \{ |object| \}}{\# -> self} 
  Последовательно перебирает элементы перечня, используя информацию о создавшем его методе. 
 
  \declare{.with_index( start = 0 ) \{ | object, index | \}}{\# -> self} 
  Последовательно перебирает элементы перечня вместе с их индексами. Перебор начинается с элемента, имеющего индекс, переданный методу.
 
  \declare{.with_object(object) \{ | object2, object | \}}{\# -> object} 
  Аналогично выполнению 
  \\\verb!.each_with_object(object) { | object2, object | }!.
\end{methodlist}

\subsection*{Остальное}

\begin{methodlist}
  \declare{.feed( object = nil )}{\# -> nil} 
  Устанавливает результат следующей итерации перечня. При вызове без аргументов, использование инструкции yield возвращает nil.
\end{methodlist}

\section{Enumerable} 

Модуль содержит методы для работы с составными объектами, реализованные на основе итератора \method{.each}. 

Также для некоторых методов может понадобиться определение оператора \method{<=>}. 

Ассоциативные массивы преобразуются в индексные с помощью метода \method{.to_a}. 

\subsection*{Приведение типов} 

\begin{methodlist}
  \declare{.to_a}{\# -> array}
  \alias{entry} 
  Преобразует составной объект в индексный массив.
\end{methodlist}

\subsection*{Элементы объекта}

\begin{methodlist}
  \declare{.first( size = nil )}{\# -> object}
  Возвращает либо первый элемент составного объекта, либо начальную часть массива. Если методу передается ноль, то возвращается пустой массив. 
  \\\verb![ 1, 2, 3 ].first 2 # -> [ 1, 2 ]!
 
  \declare{.take(size)}{\# -> array}
  Возвращает массив элементов из начала массива. Если методу передается ноль, то возвращается пустой массив. 
  \\\verb![ 1, 2, 3 ].take 2 # -> [ 1, 2 ]!
 
  \declare{.drop(size)}{\# -> array}
  Возвращает индексный массив, содержащий все элементы составного объекта, кроме первых. 
  \\\verb![ 1, 2, 3 ].drop 2 # -> [ 3 ]!
\end{methodlist}

\subsection*{Сортировка и группировка}

\begin{methodlist}
  \declare{.sort}{\# -> array} 
  \verb!{ | object, object2 | } # -> array!

  Сортировка элементов либо с помощью оператора \method{<=>}, либо с помощью блока возвращающего -1, 0 , 1 или nil. 
  \\\verb!{ a: 1, b: 2, c: 3 }.sort # -> [ [ :a, 1 ], [ :b, 2 ], [ :c, 3 ] ]!
 
  \declare{.sort_by \{ | object, object2 | \}}{\# -> array} 
  Сортировка элементов в восходящем порядке в соответствии с результатами их итераций.
  \begin{verbatim}
  \{ a: 1, b: 2, c: 3 \}.sort_by \{ |array| -array[1] \}
  # -> [ [:c, 3], [:b, 2], [:a, 1] ]\
  \end{verbatim}  
 
  \declare{.group_by \{ |object| \}}{\# -> hash} 
  Группировка элементов. В качестве ключей будут использоваться результаты итерации элементов, а в качестве ассоциируемых объектов - индексные массивы, содержащие элементы составного объекта. 
  \\\verb![ 1, 2 ].group_by { |elem| elem > 4 } # -> { false => [ 1, 2 ] }!

  \declare{.zip(*object)}{\# -> array} 
  \verb!(*object) { |array| } # -> nil!

  Группировка элементов с одинаковыми индексами. Группы элементов могут передаваться в необязательный блок. 

  Количество групп равно размеру объекта, для которого метод был вызван. Остальные объекты при необходимости дополняются элементами, ссылающимися на nil.
  \begin{verbatim}
  \{ a: 1, b: 2 \}.zip [ 1, 2 ], [1]  
  # -> [ [ [:a, 1], 1, 1 ], [ [:b, 2], 2, nil ] ]\
  \end{verbatim}

  \declare{.chunk \{ |object| \}}{\# -> enum} 
  \verb!(buffer) { | object, buffer | } # -> enum!

  Группировка элементов с одинаковыми результатами итераций. Создаваемый перечень содержит информацию о группе элементов в индексном массиве и объединившем их результате итерации. 

  Результат итерации блока для дальнейшего использования может быть сохранен с помощью дополнительного аргумента. 

  Блок может возвращать специальные объекты:
  \begin{description}
    \item[nil или :_] - игнорировать элемент;
    \item[:_alone] - элемент будет единственным в группе.
  \end{description}   
 
  \declare{.slice_before(object)}{\# -> enum} 
  \verb!{ |object| } # -> enum!
  \\\verb!(buffer  { | object, buffer | } # -> enum!

  Группировка элементов. 

  Новая группа начинается с элемента равного переданному аргументу (сравнение выполняется с помощью оператора \method{===}), или если логическое значение итерации элемента true. 

  Первый элемент игнорируется. 

  В перечне группа объектов сохраняется в виде индексного массива. 
\end{methodlist}

\subsection*{Поиск элементов}

\begin{methodlist}
  \declare{.count( object = nil )}{\# -> integer} 
  \verb!{ |object| } # -> integer!

  Возвращает количество элементов, либо равных переданному аргументу, либо с логическим значением итерации true. При вызове без аргументов возвращает количество элементов. 
  \\\verb![ 1, 2, 3 ].count { |elem| elem < 4 } # -> 3!

  \declare{.grep(object)}{\# -> array} 
  \verb!(object) { |object| } # -> array!

  Поиск всех элементов, равных переданному аргументу (сравнение выполняется с помощью оператора \method{===}).

  Если методу передается блок, то вместо элементов возвращается результат их итерации.
  \\\verb![ 1, 2, 3 ].grep(2) { |elem| elem > 4 } # -> [false]!

  \declare{.find_all \{ |object| \}}{\# -> array} 
  \alias{select} 
  Поиск всех элементов с логическим значением итерации true. 
  \\\verb![ 1, 2, 3 ].find_all { |elem| elem > 4 } # -> [ ]!

  \declare{.reject \{ |object| \}}{\# -> array} 
  Поиск всех элементов с логическим значением итерации false. 
  \\\verb![ 1, 2, 3 ].reject { |elem| elem > 4 } # -> [ 1, 2, 3 ]!

  \declare{.partition \{ |object| \}}{\# -> array} 
  Поиск элементов с различными логическими значениями итераций. 
  \\\verb![ 1, 2, 3 ].partition { |elem| elem > 2 } # -> [ [3], [1, 2] ]!

  \declare{.detect( default = nil ) \{ |object| \}}{\# -> obj2}
  \alias{find} 
  Поиск первого элемента с логическим значением итерации true. Если искомый элемент не найден, то возвращается либо nil, либо переданный методу объект.
  \\\verb![ 1, 2, 3 ].detect { |elem| elem > 4 } # -> nil!

  \declare{.find_index( object = nil )}{\# -> index} 
  \verb!{ |object| } # -> index!

  Поиск индекса первого элемента, либо равного переданному аргументу, либо с логическим значением итерации true. Если элемент не найден, то возвращается nil. 
  \\\verb![ 1, 2, 3 ].find_index { |elem| elem > 4 } # -> nil!
\end{methodlist}

\subsection*{Сравнение элементов}

Сравнение выполняется с помощью оператора \method{<=>}.

\begin{methodlist}
  \declare{.min}{\# -> object}
  Возвращает наименьший элемент.
  \\\verb![ 1, 2, 3 ].min # -> 1!
  
  \declare{.max}{\# -> object}
  Возвращает наибольший элемент. 
  \\\verb![ 1, 2, 3 ].max # -> 3!
  
  \declare{.minmax}{\# -> array} 
  Возвращает наименьший и наибольший элементы.
  \\\verb![ 1, 2, 3 ].minmax # -> [ 1, 3 ]!
  
  \declare{.min_by \{ |object| \}}{\# -> object} 
  Возвращает элемент с наименьшим результатом итерации.
  \\\verb![ 1, 2, 3 ].min_by { |elem| -elem } # -> 3!
  
  \declare{.max_by \{ |object| \}}{\# -> object}
  Возвращает элемент с наибольшим результатом итерации.
  \\\verb![ 1, 2, 3 ].max_by { |elem| -elem } # -> 1!
  
  \declare{.minmax_by \{ |object| \}}{\# -> array} 
  Возвращает элементы с наименьшим и наибольшим результатами итерации.  
  \\\verb![ 1, 2, 3 ].minmax_by { |elem| -elem } # -> [ 3, 1 ]!
\end{methodlist}

\subsection*{Предикаты}

\begin{methodlist}  
  \declare{.include?(object)}{} 
  \alias{member?} 
  Проверяется наличие элемента, равного переданному аргументу (сравнение выполняется с помощью оператора \method{==}). 
  \\\verb![ 1, 2, 3 ].include? 4  # -> false!
  
  \declare{.all? \{ |object| \}}{} 
  Проверяется наличие элементов только с логическим значением итерации true. При вызове без аргументов последовательно проверяет каждый элемент. 
  \\\verb![ 1, 2, 3 ].all? { |elem| elem < 4 } # -> true!
  
  \declare{.any? \{ |object| \}}{} 
  Проверяется наличие любого элемента с логическим значением итерации true. При вызове без аргументов последовательно проверяет каждый элемент. 
  \\\verb![ 1, 2, 3 ].any? { |elem| elem < 4 } # -> true!
 
  \declare{.one? \{ |object| \}}{}
  Проверяется наличие только одного элемента с логическим значением итерации true. При вызове без аргументов последовательно проверяет каждый элемент. 
  \\\verb![ 1, 2, 3 ].one? { |elem| elem < 4 } # -> false!
 
  \declare{.none? \{ |object| \}}{}
  Проверяется отсутствие элементов с логическим значением итерации true. При вызове без аргументов последовательно проверяет каждый элемент. 
  \\\verb![ 1, 2, 3 ].none? { |elem| elem < 4 } # -> false!
\end{methodlist}

\subsection*{Итераторы}

\begin{methodlist}
  \declare{.collect \{ |object| \}}{\# -> array} 
  \alias{map, collect_concat, flat_map} 
  Последовательно перебирает элементы, сохраняя результат итерации в индексном массиве.
  \begin{verbatim}
  [ 1, 2, 3 ].collect { |elem| elem < 4 } # -> [ true, true, true ]
  (1..3).collect(&:next) * ?| # -> "2|3|4"\
  \end{verbatim}  

  \declare{.reverse_each( *arg = nil ) \{ |object| \}}{\# -> self} 
  Последовательно перебирает элементы в обратном порядке.
  
  \declare{.each_with_index \{ | object, index | \}}{\# -> self}
  Последовательно перебирает элементы вместе с их индексами. 
  
  \declare{.each_with_object(object) \{ | object2, object | \}}{\# -> object} 
  Последовательно перебирает элементы вместе с переданным аргументом. 
  
  \declare{.each_slice(size) \{ |array| \}}{\# -> nil} 
  Последовательно перебирает элементы, группируя их в индексные массивы заданного размера. 
  
  \declare{.each_cons(size) \{ |array| \}}{\# -> nil} 
  Последовательно перебирает элементы составного объекта, группируя их в индексные массивы заданного размера. 

  После каждой итерации из начала группы будет удален элемент, а в конец будет добавлен следующий элемент составного объекта. 
  
  \declare{.each_entry \{ |object| \}}{\# -> nil} 
  Последовательно перебирает элементы. Несколько объектов, переданных инструкции yield в теле метода \method{.each}, сохраняются в индексном массиве. 

  \declare{.drop_while \{ |object| \}}{\# -> array}
  Последовательно перебирает все элементы составного объекта, кроме первого, до итерации с логическим значением false.

  Возвращаются элементы, итерация которых не выполнялась. 
  \\\verb![ 1, 2, 3].drop_while { |elem| elem < 4 } # -> [ ]!

  \declare{.take_while \{ |object| \}}{\# -> array} 
  Последовательно перебирает все элементы составного объекта, кроме первого, до итерации с логическим значением false.

  Возвращаются элементы, итерация которых выполнялась. 
  \\\verb![ 1, 2, 3].take_while { |elem| elem < 4 } # -> [ 1, 2, 3 ]!

  \declare{.cycle( step = nil ) \{ |object| \}}{\# -> nil} 
  Последовательно перебирает элементы в бесконечном цикле. Выполнение может быть остановлено с помощью инструкций или ограничения количества выполнений цикла переборов.

  Если методу передано отрицательное число, то вызов метода завершается до выполнения.

  \declare{.inject(method)}{\# -> object}
  \verb!( first, method ) # -> object!
  \\\verb!( first = nil ) { | buffer, first | } # -> buffer!

  \alias{reduce}
  Преобразует объект, объединяя его элементы либо с помощью указанного метода, либо передавая результат каждой итерации первому параметру блока.

  Выполнение начинается с первого элемента или с дополнительно переданного аргумента. 
  \\\verb![ 1, 2, 3 ].inject( 100, :+ ) # -> 106!
\end{methodlist} 