* Довольно слабое краткое описание языка. Возможно стоит добавить побольше особенностей.

* Описание принципов и реализации ООП требует улучшения. В частности описание полиморфизма.

* Предметный указатель методов. Вместо таблицы глобальных переменных - предметный указатель.

* Добавить примеры регулярных выражений.

* Добавить подробное описание процессов (Process).

* Добавить главу "Форматирование кода".

* Добавить главу "Документирование кода".

* Добавить создание тестов (Test::Unit, Rspec).

* Добавить управление пакетами.

* IO::console

* Примеры мультиплексирования и ассинхронного ввода/вывода.

* Установка интерпретатора (компиляция).

* Функциональная парадигма.

* Irb и Ri (установка интерпретатора).

* true - истинные значения; false - ложные значения; Если результат выполнения блока имеет истинное значение (ложное значение).

* В некоторых случаях можно заменить если на когда. Если методу передаются -> когда методу передаются.

* Приводит к вызову ошибки -> считается ошибкой.

* Методы .push, .pop, .shift и .unshift вынести в отдельный подраздел - работа со стеком.

* Module.methods false - список идентификаторов всех методов класса. Возможно синоним для .singleton_methods.

* Thread.current[:symbol]

* /\b(word)\b/ - идиома для поиска отдельных слов.

* :) Методы - это свойства, значением которых является функция.

* Объект, связанный с переменной, называется ее значением.

* .reduce - типичная операция в функциональном программирования, также известная как "свертка".

* Замыкания:
Замыкание (англ. closure) в программировании — процедура или функция, в теле которой присутствуют ссылки на переменные, объявленные вне тела этой функции и не в качестве её параметров (а в окружающем коде). Эти переменные продолжают существовать во время выполнения функции, даже если во внешнем коде их уже не существует.
closure = proc { counter = 0; proc {counter += 1} }.call
closure.call # -> 1
closure.call # -> 2
closure.call # -> 3

# ruby
def foo
  f = Proc.new { return "return from foo from inside proc" }
  f.call # после вызова функции замыкания f осуществляется выход из foo
         # результатом работы функции foo является результат работы f замыкания
  return "return from foo" 
end
 
def bar
  f = lambda { return "return from lambda" }
  f.call # после вызова функции замыкания f продолжается выполнение bar
  return "return from bar"
end
 
puts foo # печатает "return from foo from inside proc"
puts bar # печатает "return from bar"

* Мемоизация - хранение ранее вычисленного результата с помощью замыканий и вложенных подпрограмм.

* "Утиная типизация" ставит во главе угла не тип объекта, а его возможности.

* Если в теле метода используется инструкция yield, а блок не переадется то вызывается LocalJumpError.

* Обработка событий:
begin
rescue StandardError
  print "OK"
TestKlass.new.test_method # raise StandardError
end
=> nil

begin
TestKlass.new.test_method
rescue StandardError
  "OK"
end
=> "OK"

* Иерархия областей видимости:
Область видимости объекта - тело метода
Область видимости вызова метода

* until - это эквивалент while not, а loop - это эквивалент while true.

* иерархия классов и иерархия областей видимости

* объявление метода - объявление существования метода.

* с помощью define_method и public_send возможно использовать методы, идентифкаторы которых отличаются от стандартных (могут содержать пробелы и знаки препинания).