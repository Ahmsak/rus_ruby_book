\chapter{Числа}
$$
  \xymatrix{	
  Numeric \: (+ \: Comparable) \ar[d]\ar[dr]\ar[drr]\ar[drrr] &&& \\
  Complex & Rational & Float & Integer \ar[d]\ar[dr] & \\
  &&& Fixnum & Bignum }
$$

Для математических расчетов в Ruby определен модуль Math.

\section{Numeric}

Абстрактный класс, описывающий общие принципы работы с числами.

Добавленные модули: Comparable.

Если в результате выполнения какого-либо выражения интерпретатор возвращает число, то оно автоматически переводится в десятичную систему счисления.

\subsection*{Приведение типов}

\subsubsection{Неявное приведение}

Подклассы чисел за внешней схожестью имеют различную внутреннюю реализацию. Поэтому перед тем как вызвать метод, интерпретатор приводит переданные аргументы к одному классу. Делается это в соответствии с приведенным ниже списком:
\begin{enumerate}
  \item Если одно из чисел - комплексное, то и другие числа будут преобразованы в комплексные;

  \item Если одно из чисел - десятичная дробь, то и другие числа будут преобразованы в десятичные дроби;

  \item Если одно из чисел - рациональная дробь, то и другие числа будут преобразованы в рациональные дроби. 
\end{enumerate}

Результат будет экземпляром того же класса, к которому приводятся аргументы.

\subsubsection{Явное приведение}

\begin{methodlist}
  \declare{.coerce(number)}{\# -> array}
  Возвращает индексный массив вида \verb![ self, number ]!. 
  \begin{itemize}
    \item Если числа принадлежат к разным классам, то они преобразуются в десятичные дроби с помощью метода .Float;

    \item Текст преобразуется, если он содержит только цифры (поддерживаются двоичная и шестнадцатеричная системы счисления).
  \end{itemize}
  \begin{verbatim}
  1.coerce 2.1 # -> [ 2.1, 1.0 ]
  1.coerce "2.1" # -> [ 2.1, 1.0 ]
  1.coerce "0xAF" # -> [ 175.0, 1.0 ]
  1.coerce "q123" # -> error!
  \end{verbatim}

  \declare{.i}{\# -> complex}
  Преобразует число в комплексное. Метод удален из класса Complex.
  \\\verb!1.i # -> (0+1i)!

  \declare{.to_c}{\# -> complex}
  Преобразует число в комплексное. 
  \\\verb!1.to_c # -> (1+0i)!

  \declare{.to_int}{\# -> integer}
  Преобразует число в целое с помощью метода \method{.to_i}.
  \\\verb!2.1.to_int # -> 2!
\end{methodlist}

\subsection*{Операторы}

\begin{methodlist}
  \declare{number1 \% number2}{}
  Синонимы: \method{modulo}

  Вычисление остатка от деления.

  Аналогично выполнению \verb!number1 – number2 * (number1 / number2).floor!

  \declare{+number}{(идентификатор метода +@)}
  Унарный плюс.

  \declare{-number}{(идентификатор метода -@)}
  Унарный минус.

  \declare{number1 <=> number2}{}
  Сравнение.
\end{methodlist}

\subsection*{Округление}

\begin{methodlist}
  \declare{.ceil}{\# -> integer}
  Возвращается наименьшее целое число, которое будет больше или равно объекту, для которого метод был вызван (округление в большую сторону).
  \\\verb!2.1.ceil # -> 3!

  \declare{.floor}{\# -> integer}
  Возвращается наибольшее целое число, которое будет меньше или равно объекту, для которого метод был вызван (округление в меньшую сторону).
  \\\verb!2.1.floor # -> 2!

  \declare{.round( precise = 0 )}{\# -> number}
  Округляет число с заданной точностью. Точность определяет разряд, до которого будет выполнено округление.
  \begin{verbatim}
  2.11355.round 4 # -> 2.1136
  2.round 4 # -> 2.0
  \end{verbatim} 

  \declare{.truncate}{\# -> integer}
  Возвращает целую часть числа.
  \\\verb!2.1.truncate # -> 2!
\end{methodlist}

\subsection*{Математические функции}

\begin{methodlist}
  \declare{.abs2}{\# -> number}
  Возвращает квадрат числа.
  \\\verb!-2.1.abs2 # -> 4.41!

  \declare{.numerator}{\# -> integer}
  Возвращает числитель рациональной дроби, полученной с помощью метода \method{.to_r}.
  \\\verb!2.1.numerator # -> 4728779608739021!

  \declare{.denominator}{\# -> integer}
  Возвращает знаменатель рациональной дроби, полученной с помощью метода \method{.to_r}.
  \\\verb!2.1.denominator # -> 2251799813685248!

  \declare{.divmod(number)}{\# -> array}
  Возвращает ссылку на индексный массив вида \verb![ self / number, self  % number ]!. Деление и остаток от деления.
  \\\verb!1.divmod 3 # -> [ 0, 1 ]!

  \declare{.div(number)}{\# -> integer}
  Аналогично выполнению \verb!( self / number ).to_i!. Округленная разность.
  \\\verb!1.div 3 # -> 0!

  \declare{.fdiv(number)}{\# -> float}
  Аналогично выполнению \verb!( self / number ).to_f!.
  \\\verb!1.fdiv 3 # -> 0.3333333333333333!

  \declare{.quo(number)}{\# -> number2}
  Частное двух чисел. Для двух целых чисел результатом будет рациональная дробь.
  \\\verb!1.quo 3 # -> (1/3)!

  \declare{.remainder(number)}{\# -> number2}
  Аналогично выполнению \verb!self – number * ( self / number ).truncate!.
  \\\verb!1.remainder 3 # -> 1!

  \declare{.abs}{\# -> number}
  Возвращает модуль числа.
  \\\verb!-2.1.abs # -> 2.1!

  \declare{.arg}{\# -> number}
  Синонимы: \method{angle}, \method{phase}

  Угловое значение для полярной системы координат.

  Для действительных чисел возвращает ноль, если число не отрицательно. В другом случае возвращается ссылка на константу \constant{Math::PI}.
  \begin{verbatim}
  1.arg # -> 0
  -1.arg # -> 3.141592653589793
  \end{verbatim}

  \declare{.polar}{\# -> array}
  Возвращает ссылку на индексный массив вида \verb![ self.abs, self.arg ]!. Число в полярной системе координат.
  \\\verb!1.polar # -> [ 1, 0 ]!

  \declare{.real}{\# -> number}
  Возвращает вещественную часть числа.
  \\\verb!1.real # -> 1!

  \declare{.imag}{\# -> 0}
  Синонимы: \method{imaginary}

  Возвращает мнимую часть числа.

  \declare{.rect}{\# -> array}
  Возвращает ссылку на индексный массив вида \verb![ self, 0 ]!. Вещественная и мнимая части числа. Число в прямоугольной системе координат.
  \\\verb!1.rect # -> [ 1, 0 ]!

  \declare{.conj}{\# -> self}
  Синонимы: \method{conjugate}

  Возвращает сопряженное число (используется для комплексных чисел).
\end{methodlist}

\subsection*{Предикаты}

\begin{methodlist}
  \declare{.integer?}{}
  Проверяет относится ли число к целым.
  \begin{verbatim}
  1.integer? # -> true
  2.1.integer? # -> false
  \end{verbatim}

  \declare{.real?}{}
  Проверяет относится ли число к действительным (false возвращается только для комплексных чисел).
  \\\verb!1.real? # -> true!

  \declare{.nonzero?}{}
  Возвращает число, если оно не равно нулю. В другом случае возвращается nil.
  \begin{verbatim}
  1.nonzero? # -> 1
  0.0.nonzero? # -> nil
  \end{verbatim}

  \declare{.zero?}{}
  Проверяет равно ли число нулю.
  \begin{verbatim}
  1.zero? # -> false
  0.0.zero? # -> true
  \end{verbatim}
\end{methodlist}

\subsection*{Итераторы}

\begin{methodlist}
  \declare{.step( limit, step = 1) \{|number|\}}{\# -> self}
  Последовательно перебирает числа.

  Если одно из чисел не относится к целым, то все числа преобразуются в десятичные дроби. При этом число итераций соответствует \verb!n + n * Flt::EPSILON!, где \verb!n == limit – self / step!.
\end{methodlist}

\subsection*{Остальное}

\begin{methodlist}
  \declare{.singleton_method_added(*object)}{}
  Вызывает ошибку при попытке определить собственный метод для числа.
\end{methodlist}

\section{Integer}

Абстрактный класс, описывающий основы работы с целыми числами. Производные классы Fixnum и Bignum отличаются только внутренней реализацией.

\subsection*{Приведение типов}

\begin{methodlist}
  \declare{.to_i}{\# -> self}

  \declare{.to_r}{\# -> rational}
  Синонимы: \method{rationalize}

  Преобразует целое число в рациональную дробь.
  \\\verb!0.to_r # -> (0/1)!

  \declare{.to_f}{\# -> float [Fixnum и Bignum]}
  Преобразует целое число в десятичную дробь.
  \\\verb!1.to_f # -> 1.0!

  \declare{.to_s( numeral_system = 10 )}{\# -> string [Fixnum и Bignum]}
  Преобразует целое число в текст, используя указанную систему счисления (от 2 до 36).
  \begin{verbatim}
  16.to_s 16 # -> "10"
  0xF.to_s 16 # -> "f" 
  0x16.to_s 16 # -> "16" 
  \end{verbatim}
\end{methodlist}

\subsection*{Операторы: Fixnum и Bignum}

  \begin{methodlist}
  \declare{integer * integer2}{\# -> integer3}
  Произведение.

  \declare{integer / integer2}{\# -> integer3}
  Деление.

  \declare{integer**integer2}{\# -> integer3}
  Возведение в степень.

  \declare{integer + integer2}{\# -> integer3}
  Сумма.

  \declare{integer - integer2}{\# -> integer3}
  Разность.

  \declare{\textasciitilde\-, integer}{\# -> integer2}
  Побитовое отрицание.

  \declare{integer[index]}{\# -> 0 или 1}
  Возвращает указанный бит из двоичного представления числа.

  \declare{integer \twoless integer2}{\# -> integer3}
  Побитовый сдвиг влево.

  \declare{integer \twogreat integer2}{\# -> integer3}
  Побитовый сдвиг вправо.

  \declare{integer \& integer2}{\# -> integer3}
  Побитовое И.

  \declare{integer | integer2}{\# -> integer3}
  Побитовое ИЛИ.

  \declare{integer \textasciicircum\-, integer2}{\# -> integer3}
  Побитовое исключающее ИЛИ.
\end{methodlist}

\subsection*{Арифметические операции}

\begin{methodlist}
  \declare{.next}{\# -> integer}
  Синонимы: \method{succ}

  Аналогично выполнению \verb!self + 1!.
  \\\verb!1.next # -> 2!

  \declare{.pred}{\# -> integer}
  Аналогично выполнению \verb!self - 1!.
  \\\verb!1.pred # -> 0!

  \declare{.gcd(integer)}{\# -> integer2}
  Вычисляет наибольший общий делитель для двух целых чисел. Если одно из них равно нулю, то возвращается результат вызова метода \method{.abs} для другого.
  \\\verb!2.gcd 3 # -> 1!

  \declare{.lcm(integer)}{\# -> integer2}
  Вычисляет наименьшее общее кратное для двух целых чисел. Если одно из них равно нулю, то возвращается ноль.
  \\\verb!2.lcm 3 # -> 6!

  \declare{.gcdlcm(integer)}{\# -> array}
  	Интерпретатор возвращает ссылку на индексный массив вида
  \\\verb![ self.gcd(integer), self.lcm(integer) ]!
  \\\verb!2.gcdlcm 3 # -> [ 1, 6 ]!
\end{methodlist}

\subsection*{Предикаты}

\begin{methodlist}
  \declare{.even?}{}
  Проверяет относится ли число к четным.
  \begin{verbatim}
  0.even? # -> true
  1.even? # -> false
  2.even? # -> true
  \end{verbatim}

  \declare{.odd?}{}
  Проверяет относится ли число к нечетным.
  \begin{verbatim}
  0.odd? # -> false
  1.odd? # -> true
  2.odd? # -> false
  \end{verbatim}
\end{methodlist}

\subsection*{Итераторы}

\begin{methodlist}
  \declare{.upto(limit) \{|integer|\}}{\# -> self}
  Последовательно перебирает числа (включительно) с шагом +1. 

  \declare{.downto(limit) \{|integer|\}}{\# -> self}
  Последовательно перебирает числа (включительно) с шагом -1. 

  \declare{.times \{|integer|\}}{\# -> self}
  Последовательно перебирает числа из диапазона \verb!0...self!.
\end{methodlist}

\subsection*{Остальное}

\begin{methodlist}
  \declare{.chr( encode = "binary")}{\# -> string}
  Возвращает символ с переданной кодовой позицией. Передача неопределенной кодовой позиции приводит к вызову ошибки (\error{RangeError}).
  \\\verb!42.chr # -> "*"!

  \declare{.hash}{\# -> integer [Fixnum и Bignum]}
  Возвращает цифровой код объекта.
  \\\verb!1.hash # -> -861462684!

  \declare{.size}{\# -> integer [Fixnum и Bignum]}
  Возвращает количество байтов, занимаемых числом.
  \\\verb!1.size # -> 4!
\end{methodlist}

\section{Float}

Десятичные дроби реализованы в Ruby как числа с плавающей точкой.
\begin{keylist}{Константы:}
  
  \firstkey{Float::ROUNDS} - способ округления чисел по умолчанию;
  
  \key{Float::RADIX} - показатель степени для представления порядка числа;
  
  \key{Float::MANT_DIG} - количество цифр в мантиссе;
  
  \key{Float::DIG} - максимально возможная точность;
  
  \key{Float::MIN_EXP} - минимально возможный показатель степени 10;
  
  \key{Float::MAX_EXP} - максимально возможный показатель степени \verb!Float::RADIX**Float::MAX_EXP - 1!; 
  
  \key{Float::MIN_10_EXP} - минимально возможная экспонента;
  
  \key{Float::MAX_10_EXP} - максимально возможная экспонента;
  
  \key{Float::MIN} - минимально возможная десятичная дробь;
  
  \key{Float::MAX} - максимально возможная десятичная дробь;
  
  \key{Float::EPSILON} - минимальное число, при добавлении к которому единицы, в результате не возвращается 1.0;
  
  \key{Float::INFINITY} - используется для бесконечности;
  
  \key{Float::NAN} - инициализируется в результате выполнения выражения \verb!0.0 / 0.0!.
\end{keylist}

\subsection*{Приведение типов}

\begin{methodlist}
  \declare{.to_f}{\# -> float}

  \declare{.to_i}{\# -> integer}
  Возвращает целую часть десятичной дроби.
  \\\verb!2.1.to_i # -> 2!

  \declare{.to_r}{\# -> rational}
  Преобразует десятичную дробь в рациональную с максимально возможной точностью.
  \\\verb!2.1.to_r # -> ( 4728779608739021 / 2251799813685248 )!

  \declare{.rationalize( number = Flt::EPSILON )}{\# -> rational}
  Преобразует десятичную дробь в рациональную, так что 
  \\\verb!( self – number.abs ) <= rational and rational <= ( self + number.abs )!
  \\\verb!2.1.rationalize # -> (21/10)!

  \declare{.to_s}{\# -> string}
  Преобразует десятичную дробь в текст. Допускается возвращение \verb!"NaN"!, \verb!"+Infinity"! или \verb!"-Infinity"!.
  \\\verb!2.1.to_s # -> "2.1"!
\end{methodlist}

\subsection*{Операторы}

\begin{methodlist}
  \declare{float * number}{\# -> number2}
  Произведение.

  \declare{float / number}{\# -> number2}
  Деление.

  \declare{float**number}{\# -> number2}
  Возведение в степень.

  \declare{float + number}{\# -> number2}
  Сумма.

  \declare{float - number}{\# -> number2}
  Разность.
\end{methodlist}

\subsection*{Предикаты}

\begin{methodlist}
  \declare{.finite?}{}
  Проверяет относится ли десятичная дробь к конечным дробям.
  \\\verb!2.1.finite? # -> true!

  \declare{.infinite?}{\# -> -1, nil, 1}
  Возвращает направление бесконечности для десятичной дроби. Если дробь относится к конечным дробям, то, в результате, возвращается nil.
  \\\verb!2.1.infinite? # -> nil!

  \declare{.nan?}{}
  Проверяет ссылается ли десятичная дробь на константу \constant{Float::NAN}.
  \\\verb!2.1.nan? # -> false!
\end{methodlist}

\subsection*{Остальное}

\begin{methodlist}
  \declare{.hash}{\# -> integer}
  Возвращает цифровой код объекта.
  \\\verb!2.1.hash # -> 569222191!
\end{methodlist}

\section{Rational}

Рациональная дробь - это рациональное число, вида \verb!(a/b)!, где число a называют числителем, а число b - знаменателем. Косая черта обозначает деление двух чисел. Рациональные дроби используются чтобы избежать ошибок приближения при работе с десятичными дробями.

Для работы с рациональными дробями в Ruby предоставлен класс Rational. 

\begin{methodlist}
  \declare{Raional( nom, denom = 1 )}{\# -> rational} 
  Возвращает рациональную дробь, вида \verb!(nom/denom)!. 
  \begin{verbatim}
  Rational 2, 3 # -> (2/3) 
  Rational "2/3" # -> (2/3) 
  Rational 8, 3 # -> (8/3) 
  Rational 2.1, 3 # -> (4728779608739021/6755399441055744)
  \end{verbatim}
\end{methodlist}

\subsection*{Приведение типов}

\begin{methodlist}
  \declare{.inspect}{\# -> string} 
  Преобразует рациональную дробь в текст. 
  \\\verb!Rational( 2, 3 ).inspect # -> "(2/3)"!

  \declare{.to_s}{\# -> string} 
  Преобразует тело рациональной дроби в текст. 
  \\\verb!Rational( 2, 3 ).to_s # -> "2/3"!

  \declare{.to_f}{\# -> float} 
  Преобразует рациональную дробь в десятичную. 
  \\\verb!Rational( 2, 3 ).to_f # -> 0.6666666666666666!

  \declare{.to_i}{\# -> integer} 
  Аналогично выполнению self.truncate.
  \\\verb!Rational( 2, 3 ).to_i # -> 0!

  \declare{.to_r}{\# -> rational} 
\end{methodlist}

\subsection*{Операторы} 

\begin{methodlist}
  \declare{rational * number}{\# -> number} 
  Произведение. 
 
  \declare{rational / number}{\# -> number2} 
  \alias{quo} 
  Деление. 
 
  \declare{rational**number}{\# -> number2}
  Возведение в степень. 
 
  \declare{rational + number}{\# -> number2} 
  Сумма. 
 
  \declare{rational - number}{\# -> number2} 
  Разность. 
\end{methodlist}

\subsection*{Остальное} 

\begin{methodlist}
  \declare{.rationalize( number = Flt::EPSILON )}{\# -> rational}
  Преобразует рациональную дробь, так что 
  \\\verb!self – number.abs <= rational && rational <= self + number.abs!
\end{methodlist}

\section{Complex}

Комплексные числа - это подвид вещественных чисел в виде суммы \verb!(a+b*i)!, где a и b - вещественные числа, а i - мнимая единица.

Для работы с комплексными числами в Ruby предоставлен класс Complex. В этом классе удалены некоторые базовые методы Numeric (все методы, относящиеся к округлению чисел, оператор \%, методы \method{.div}, \method{.divmod}, \method{.remainder}, итератор \method{.step}).

\begin{keylist}{Константы}
  \firstkey{Complex::I}{ - мнимая единица.}
\end{keylist} 

\begin{methodlist}
  \declare{Complex( real, imag = 0 )}{\# -> complex} 
  Создание комплексного числа.
  \begin{verbatim}
  Complex 2, 3 # -> (2+3i) 
  Complex "2/3" # -> ((2/3)+0i) 
  Complex 8, 3 # -> (8+3i) 
  Complex 2.1, 3 # -> (2.1+3i) 
  Complex ?i # -> (0+1i)
  \end{verbatim}

  \declare{::polar( magnitude, angle = 0.0 )}{\# -> complex} 
  Возвращает комплексное число в полярной системе координат. 
  \\\verb!Complex.polar 2, 3 # -> (-1.9799849932008908+0.2822400161197344i)!
  \declare{::rect( real, imag = nil )}{\# -> complex} 
  \alias{rectangular} 
  Возвращает комплексное число в прямоугольной системе координат. 
  \\\verb!Complex.rect 2, 3 # -> (2+3i)!
\end{methodlist}

\subsection*{Приведение типов}

\begin{methodlist}
  \declare{.inspect}{\# -> string} 
  Преобразует комплексное число в текст. 
  \\\verb!Complex( 2, 3 ).inspect # -> "(2+3i)"!
 
  \declare{.to_s}{\# -> string} 
  Преобразует тело комплексного числа в текст. 
  \\\verb!Complex( 2, 3 ).to_s # -> "2+3i"!
 
  \declare{.to_f}{\# -> float} 
  Преобразует комплексное число в десятичную дробь, если такое преобразование возможно. 
  \\\verb!Complex( 2, 3 ).to_f # -> error!
 
  \declare{.to_i}{\# -> integer} 
  Преобразует комплексное число в целое, если такое преобразование возможно. 
  \\\verb!Complex( 2, 3 ).to_i # -> error!
 
  \declare{.to_r}{\# -> rational} 
  Преобразует комплексное число в рациональную дробь, если такое преобразование возможно. 
  \\\verb!Complex( 2, 3 ).to_r # -> error!
 
  \declare{.rationalize( number = Flt::EPSILON )}{\# -> rational} 
  Преобразует комплексное число в рациональную дробь, если такое преобразование возможно. Переданный аргумент игнорируется. 
  \\\verb!Complex(3).rationalize true # -> (3/1)!
\end{methodlist}

\subsection*{Операторы} 

\begin{methodlist}
  \declare{complex * number}{\# -> complex2} 
  Произведение. 
  \\\verb!Complex( 2, 3 ) * 2 # -> (4+6i)!
 
  \declare{complex / number}{\# -> complex2} 
  \alias{quo} 
  Деление. 
  \\\verb!Complex( 2, 3 ) / 2 # -> ((1/1)+(3/2)*i)!
 
  \declare{complex**number}{\# -> complex2} 
  Возведение в степень. 
  \verb!Complex(2, 3)**2 # -> (-5+12i)!
 
  \declare{complex + number}{\# -> complex2} 
  Сумма. 
  \\\verb!Complex( 2, 3 ) + 2 # -> (4+3i)!
 
  \declare{complex - number}{\# -> complex2} 
  Разность. 
  \\\verb!Complex( 2, 3 ) - 2 # -> (0+3i)!
 
  \declare{-complex}{\# -> complex2} 
  Унарный минус. 
  \\\verb!-Complex( 2, 3 ) # -> (-2-3i)!
\end{methodlist}


\subsection*{Математические функции}

\begin{methodlist}
  \declare{.abs2}{\# -> number} 
  Возвращает квадрат абсолютного значения. 
  \\\verb!Complex( 2, 3 ).abs2 # # -> 13!

  \declare{.numerator}{\# -> complex}
  Возвращает числитель возможной рациональной дроби. 
  \\\verb!Complex( 2, 3 ).numerator # -> (2+3i) !
 
  \declare{.denominator}{\# -> complex}
  Возвращает знаменатель возможной рациональной дроби (наименьшее общее кратное рациональной и мнимой частей). 
  \\\verb!Complex( 2, 3 ).denominator # -> 1!

  \declare{.fdiv(number)}{\# -> complex}
  Выполняет деление каждой части в виде десятичной дроби. 
  \\\verb!Complex( 2, 3 ).fdiv 2 # -> (1.0+1.5i)!

  \declare{.abs}{\# -> number} 
  \alias{magnitude} 
  Возвращает абсолютную часть в полярной системе координат. 
  \\\verb!Complex( 2, 3 ).abs # -> 3.605551275463989 !
 
  \declare{.arg}{\# -> float} 
  \alias{angle, phase} 
  Возвращает угловое значение в полярной системе координат. 
  \\\verb!Complex( 2, 3 ).arg # -> 0.982793723247329!

  \declare{.real}{\# -> number} 
  Возвращает вещественную часть числа. 
  \\\verb!Complex( 2, 3 ).real # -> 2 !
 
  \declare{.imag}{\# -> number} 
  \alias{imaginary} 
  Возвращает мнимую часть числа. 
  \\\verb!Complex( 2, 3 ).imag # -> 3 !
 
  \declare{.rect}{\# -> float} 
  \alias{rectangular} 
  Возвращает массив вида \verb![ self.real, self.imag ]!. Вещественная и мнимая части числа в прямоугольной системе координат.
  \\\verb!Complex( 2, 3 ).rect # -> [2, 3] !
 
  \declare{.conj}{\# -> complex}
  \alias{conjugate} 
  Возвращает сопряженное комплексное число. 
  \\\verb!Complex( 2, 3 ).conj # -> (2-3i) !
\end{methodlist}

\section{Math}

Модуль содержит определение различных математических функций. Все методы могут быть вызваны либо как методы класса (для модуля Math), либо как частные методы экземпляров (для любого класса, добавляющего модуль Math).

Переданные аргументы, преобразуются в десятичные дроби. Поэтому в результате вызова метода также возвращается десятичная дробь.

\begin{keylist}{Константы:}
  
  \firstkey{Math::PI} - число π (пи);
  
  \key{Math::E} - число e.
\end{keylist}

\begin{methodlist}
  \declare{.acos(number)}{\# -> float}
  Возвращает арккосинус числа.

  \declare{.acosh(number)}{\# -> float}
  Возвращает гиперболический косинус числа.

  \declare{.asin(number)}{\# -> float}
  Возвращает арксинус числа. 

  \declare{.asinh(number)}{\# -> float}
  Возвращает гиперболический синус числа.

  \declare{.atan(number)}{\# -> float}
  Возвращает арктангенс числа.

  \declare{.atan2( number, number2 )}{\# -> float}
  Возвращает арктангенс двух чисел.

  \declare{.atanh(number)}{\# -> float}
  Возвращает гиперболический тангенс числа.

  \declare{.cbrt(number)}{\# -> float}
  Возвращает кубический корень числа.

  \declare{.cos(number)}{\# -> float}
  Возвращает косинус числа (в радианах).

  \declare{.cosh(number)}{\# -> float}
  Возвращает гиперболический косинус числа (в радианах).

  \declare{.erf(number)}{\# -> float}
  Возвращает функцию ошибки из числа.

  \declare{.erfc(number)}{\# -> float}
  Возвращает дополнительную функцию ошибки из числа.

  \declare{.exp(number)}{\# -> float}
  Аналогично выполнению \verb!Math::E**number!.

  \declare{.frexp(number)}{\# -> array}
  Возвращает ссылку на индексный массив вида \verb![ float, integer]!, где \verb!float * 2**integer == number!.

  \declare{.gamma(number)}{\# -> float}
  Возвращает гамма функцию из числа.

  \declare{.hypot( number, number2 )}{\# -> float}
  Аналогично выполнению \verb!Math.sqrt(number**2 + number2**2)!.

  \declare{.ldexp( float, integer )}{\# -> float}
  Аналогично выполнению \verb!float * 2**integer!.

  \declare{.lgamma(number)}{\# -> array}
  Возвращает ссылку на индексный массив вида 
  \\\verb![ Math.log( Math.gamma(number).abs), Math.gamma(number)<0 ? -1: 1 ]!.

  \declare{.log( number, base = Math::E )}{\# -> float}
  Возвращает логарифм числа по заданному основанию.

  \declare{.log10(number)}{\# -> float}
  Возвращает десятичный логарифм числа.

  \declare{.log2(number)}{\# -> float}
  Возвращает логарифм числа по основанию 2.

  \declare{.sin(number)}{\# -> float}
  Возвращает синус числа (в радианах).

  \declare{.sinh(number)}{\# -> float}
  Возвращает гиперболический синус числа (в радианах).

  \declare{.sqrt(number)}{\# -> float}
  Возвращает квадратный корень числа.

  \declare{.tan(number)}{\# -> float}
  Возвращает тангенс числа (в радианах).

  \declare{.tanh(number)}{\# -> float}
  	Интерпретатор возвращает гиперболический тангенс числа (в радианах).
\end{methodlist}