\chapter{Переменные и константы}

Переменные и константы - это вид идентификаторов, использующихся для хранения данных (объектов). Объекты, которым присвоен идентификатор могут быть использованы повторно. Выражение, связывающее объекты и идентификаторы, называется выражением присваивания.

Переменные и константы также позволяют логически разделить используемые данные. Они облегчают понимание кода, позволяя перейти от терминов языка программирования к терминам решаемой задачи (проблемной области). Адекватность переменной (константы) во многом определяется ее именем. Название переменной можно рассматривать как высокоуровневый псевдокод, характеризующий ее содержимое.

Переменные (и константы) содержат адрес объекта, на который ссылаются. Адрес - это небольшое целое число, характеризующее область памяти, в которой хранится объект. В Ruby адрес объекта доступен только интерпретатору. Синтаксис использования идентификатора позволяет работать непосредственно с объектом, не отвлекая внимание на его адрес. Объект, на который ссылается переменная, также называют ее значением.

Константы от переменных отличаются только областью применения. Константы подразумевают единственное определение и не используются для изменения объектов. Обычно константы применяют для хранения постоянных неизменяющихся данных. В отличии от констант переменные подразумевают многократное использование. Переменная может использоваться как для изменения текущего объекта, так и связываться с новым объектом.

\begin{note}
  На самом деле, в Ruby, переопределение констант не приведет к завершению процесса выполнения программы. Вместо этого интерпретатор просто выведет обычное предупреждение. Скорей всего это сделано для облегчения возможности произвольного переопределения существуующих классов.
\end{note}

Для использования переменных и констант необходимо объявить интерпретатору об их существовании. Переменные и константы считаются существующими после выполнения первого выражения присваивания с их участием. Это выражение называют инициализацией. Процесс инициализации состоит из объявления (создания) переменной и определения (присваивания) переменной.

Переменные и константы также могут быть объявлены и без выражения присваивания. Встретив подходящую лексему интерпретатор создаст требуемую переменную или константу. В этом случае определение выполянется автоматически и идентификатор связывается с nil. Автоматическая инициализация предотвращает ошибки, возникающие при использовании переменных, не связанных с объектами. Это также позволяет сосредоточить внимание на объектах, а не на переменных.

\begin{note}
  Переменная (или константа) считается объявленной если код содержит ее лексему, даже если фрагмент кода не выполнялся (в этом случае она ссылается на nil). Это происходит из-за предварительной обработки кода для виртуальной машины.
\end{note}

\paragraph*{Область видимости:} фрагмент кода, в котором переменная (или константа) объявлена и может быть использована. 

На основе областей видимости также осуществляется классификация переменных. К базовым областям видимости относятся глобальная и локальные области. Глобальная область видимости распространяется на весь код. Глобальные переменные и константы существуют в любом месте кода (после их инициализации).	Локальная область видимости распространяется только на явно ограниченный фрагмент кода. Локальные переменные и константы существуют только в той части кода, в которой происходила их инициализация.

\begin{itemize}
  \item Лексемы локальных переменных начинаются с символа подчеркивания или строчной буквы (принято использовать только строчные буквы, разделяя слова знаком подчеркивания - змеиная_нотация). Использование не сущестующей локальной переменной обрабатывается интерпретатором как вызов метода;

  \item Лексемы глобальных переменных начинаются с знака доллара. Использование не существующей глобальной переменной, приводит к ее объявлению;

  \item Лексемы констант начинаются с прописной буквы (принято использовать только прописные буквы, разделяя слова знаком подчеркивания - НОТАЦИЯ_ГРЕМУЧЕЙ_ЗМЕИ). Область видимости констант основана на иерархии вложенности и иерархии классов. Использование не существующей константы приводит к вызову ошибки.
\end{itemize}

ООП вводит две дополнительные области видимости: область видимости класса и область видимости экземпляра класса. Это так же добавляет два вида переменных.
\begin{itemize}
  \item Лексема переменной экземпляра начинается с знака @ (принято использовать змеиную нотацию). Использование не существующей переменной экземпляра, приводит к ее объявлению;
  
  \item Лексема переменной класса начинается с @@ (принято использовать змеиную нотацию). Использование не существующей переменной класса, приводит к вызову ошибки.
\end{itemize}

\paragraph*{Сбор мусора:} удаление неиспользующихся объектов.

В Ruby ресурсы, используемые программой, определяются интерпретатором. Это позволяет избегать наиболее распространенных проблем работы с памятью. В то же время интерпретатор распознает только заранее определенные ситуации, что иногда приводит к довольно неприятным результатам. Дополнительная работа также увеличивает время интерпретации и выполнения программ. Баланс между этими двумя полюсами - важная задача для разработчиков интерпретатора.

Для автоматического управления памятью реализован механизм, называемый сбором мусора. Под мусором подразумеваются объекты, сохраненные в памяти, но при этом не использующиеся. Как только интерпретатор понимает, что объект не связан ни с одним идентификатором, он освобождает память, которую этот объект занимал. Это позволяет удалять одноразовые объекты сразу после их использования, а также сохранять синтаксичекие структуры на всем протяжении процесса выполнения.