\chapter{Чтение и запись данных}

$$
  \xymatrix{  
  IO \: (+ \: Enumerable) \ar[d] & Dir \: (+ \: Enumerable) \\
  File & }
$$

\section{Потоки}

Поток - это абстрактный объект, необходимый для ввода и вывода данных. Вывод также называют чтением (извлечением) данных, а ввод - записью (передачей) данных.

Два потока (один для чтения и один для записи) объединенные вместе образуют канал. Обычно каналы анонимны и удаляются после использования, но также существуют и именованные каналы, которые необходимо удалять вручную.

Модели ввода/вывода:
\begin{description}
  \item[Блокирующий] - процесс выполнения блокируется до завершения операции;
  \item[Неблокирующий] - процесс выполнения не блокируется. Попытка доступа к данным может привести к вызову ошибки. 
\end{description}


Для работы с потоками в Ruby предоставлен класс IO (добавлены модули Enumerable и File::Constants).

\subsection{Управление потоками}

Виды потоков подробно описаны в \hyperlink{appio}{\underline{приложение}}.

\subsubsection*{Открытие потока}

\begin{methodlist}
  \declare{::new( file, mode, options = nil )}{\# -> io} 
  \alias{for_fd}
  Создание нового потока для переданного файла (объект или дескриптор) или производного объекта от класса IO.

  Создаваемый поток не может получить права доступа, ограниченные при открытии файла.
  
  \declare{::open( file, mode, options = nil )}{\# -> io} 
  \verb!( file, mode, options = nil ) { |io| } # -> object!

  Метод аналогичный предыдущему, но, отличии от него, позволяющий работать с потоком в теле блока (поток автоматически закрывается после завершения выполнения блока). 

  \declare{::sysopen( path, mode = nil, *perm = nil )}{\# -> integer} 
  Открывает файл и возвращает файловый дескриптор.

  \declare{::copy_stream( old_io, new_io, start = nil, syze = nil )}{\# -> integer} 
  Копирование содержимого потока. Возвращается количество скопированных байт.Дополнительные аргументы определяют начало и размер копируемых данных. Если переданный размер превышает размер потока, то копирование выполняется до последнего байта. 

  \declare{::pipe( *encoding = nil, options = nil )}{\# -> array}  
  \verb!( *encoding = nil, options = nil ) { |read, write| } # -> object!

  Создание канала из двух потоков: для чтения и для записи. Если методу передан блок, то потоки отправляются в блок и закрываются после его выполнения.

  В качестве аргументов передается кодировка (внешняя или текст). Дополнительный аргумент влияет на \hyperlink{appencode}{\underline{преобразование кодировок}}.  
\end{methodlist}

\subsubsection*{Модификация потока}

\begin{methodlist}
  \declare{.reopen(io)}{\# -> self}
  \verb!( path, mode ) # -> self!
  
  Пересоздание потока. Для определения характеристик потока может быть использован уже существующий поток.   

  \declare{.binmode}{\# -> self}
  Объявление двоичного режима.

  \declare{.autoclose=(bool)}{\# -> bool}
  Режим автоматического закрытия потока. 

  \declare{.close_on_exec=(bool)}{\# -> nil}
  Запрет использования потока в производных процессах.

  \declare{.advise( symbol, start = 0, size = 0 )}{\# -> nil}
  Переключение схемы работы с файлом, позволяющее выполнять некоторые действия по оптимизации. Дополнительные аргументы объявляют фрагмент файла, с которым ведется работа.
  \begin{description}
    \item[:normal] - без схем (по умолчанию);
    \item[:sequintial] - последовательный доступ к данным;
    \item[:random] - произвольный доступ к данным;
    \item[:willneed] - работа с файлом в ближайшем будущем;
    \item[:dontneed] - работа с файлом в ближайшем будущем не требуется;
    \item[:noreuse] - работа с файлом требуется только один раз.
  \end{description}

  \declare{.fcntl( integer, object )}{\# -> integer2}
  Низкоуровневое управление потоком. ToDo (см. fcntl(2)). 
 
  \declare{.ioctl( integer, object )}{\# -> integer2}
  Низкоуровневое управление потоком. ToDo (см. ioctl(2)).
\end{methodlist}

\subsubsection*{Закрытие потока}

\begin{methodlist}
  \declare{.close}{\# -> nil} 
  Закрывает поток и передает все изменения из буфера программы в ОС. Потоки также автоматически закрываются сборщиком мусора. 
 
  \declare{.close_read}{\# -> nil} 
  Закрывает в канале поток для чтения. Если поток не относится к каналам, то вызывается ошибка. 
 
  \declare{.close_write}{\# -> nil} 
  Закрывает в канале поток для записи. Если поток не относится к каналам, то вызывается ошибка. 
\end{methodlist} 

\subsubsection*{Кодировка}

\begin{methodlist}
  \declare{.external_encoding}{\# -> encoding} 
  Возвращает внешнюю кодировку. Если поток доступен для записи, но кодировка при этом не задана, то возвращается nil. 
 
  \declare{.internal_encoding}{\# -> encoding} 
  Возвращает внутреннюю кодировку если она указана. В другом случае возвращает nil. 

  \declare{.set_encoding( *encoding, options = nil )}{\# -> io} 
  Объявление внешней и внутренней кодировок (объекты или текст). Дополнительный аргумент используется при \hyperlink{appencode}{\underline{преобразовании данных}}.
\end{methodlist}

\subsubsection*{Предикаты}

\begin{methodlist}
  \declare{.autoclose?}{} 
  Проверка автоматического закрытия потока.
 
  \declare{.binmode?}{} 
  Проверяет объявление двоичного режима. 
 
  \declare{.eof?}{} 
  \alias{eof} 
  Проверяет достигнут ли конец файла (поток должен быть доступен для чтения). Если поток относится к каналам или сокетам, то процесс выполнения программы блокируется до тех пор пока не закончатся действия с данными или поток не будет закрыт. 
 
  \declare{.tty?}{} 
  \alias{isatty} 
  Проверяет связан ли поток с терминалом. 
 
  \declare{.closed?}{} 
  Проверяет закрыт ли поток.
 
  \declare{.close_on_exec?}{} 
  Проверяет закрыт ли поток для использования производными процессами. 
\end{methodlist}

\subsubsection*{Остальное}

\begin{methodlist}
  \declare{.stat}{\# -> stat} 
  Возвращает экземпляр класса File::Stat, содержащий информацию об открытом файле. 
\end{methodlist}

\subsection{Приведение типов}

\begin{methodlist}
  \declare{::try_convert(object)}{\# -> io} 
  Преобразует объект в поток с помощью метода \method{.to_io}. Если такой метод не определен, то возвращается nil. 

  \declare{.to_i}{\# -> integer} 
  \alias{fileno} 
  Возвращает дескриптор файла.

  \declare{.to_io}{\# -> io}
\end{methodlist}
 

\subsection{Чтение данных}

Для чтения данных поток должен быть доступен для чтения.

Дополнительный аргумент, передаваемый методам влияет на автоматически создаваемый поток.
\begin{keylist}{Принимаемые элементы:}
  
  \firstkey{encoding:} внешняя кодировка. Игнорируется если указана размер фрагмента;
  
  \key{mode:} вид создаваемого потока. Объект должен содержать модификатор r;
  
  \key{open_args:} массив аргументов, используемых при открытии файла.
\end{keylist}

\subsubsection*{Фрагмент}

\begin{methodlist}
  \declare{::read( path, start = nil, bytesize = nil, options = nil )}{\# -> string}
  Чтение данных из файла (по умолчанию весь файл). После чтения данных поток закрывается. Если размер фрагмента больше чем размер данных в потоке, то извлекаются все оставшиеся данные.    

  \declare{::binread( path, start = nil, size = nil )}{\# -> str}
  Чтение данных из файла (по умолчанию весь файл). После чтения данных поток закрывается. Поток открывается в режиме "rb:ASCII". Если размер фрагмента больше чем размер данных в потоке, то извлекаются все оставшиеся данные.
 
  \declare{.read( bytesize = nil, buffer = nil )}{\# -> buffer}
  Чтение данных из потока (по умолчанию полностью). Если размер фрагмента ограничен, то чтение выполняется в двоичном режиме. Дополнительный аргумент служит для хранения полученных данных.
  \begin{itemize}
    \item Если передается ноль, то возвращается пустой текст;
    \item Если в начале чтения достигнут конца файла, то возвращается ссылка nil (если размер фрагмента ограничен). В другом случае возвращается пустой текст. 
  \end{itemize}
 
  \declare{.sysread( bytesize, buffer = nil )}{\# -> buffer}
  Чтение данных из потока (по умолчанию полностью) используя низкоуровневые возможности системы.
 
  \declare{.read_nonblock( bytesize, buffer = nil )}{\# -> buffer}
  Чтение данных, не блокирующее процесс выполнения. В этом случае при ошибке чтения, она будет вызвана немедленно. Используется для реализации многопоточности на основе потоков выполнения или сопрограмм.
 
  \declare{.readpartial( bytesize, buffer = nil )}{\# -> buffer}
  Чтение данных, блокирующее процесс выполнения:
  \begin{itemize}
    \item если буфер пуст;
    \item если поток пуст;
    \item если поток не достиг конца файла;
  \end{itemize}
  
  После блокировки ожидается получение данных или достижения конца файла. При получении данных они возвращаются, при достижении конца файла вызывается ошибка \error{EOFError}.

  Процесс выполнения не блокируется, если поток содержит данные - в этом случае данные возвращаются.

  Используется для чтения данных из каналов, сокетов и терминалов.

  Действие метода сходно с \method{.sysread}, но, в отличии от него при возможности читает данные из буфера, вместо вызова ошибки \error{IOError}. Также не вызываются Errno::EWOULDBLOCK и Errno::EINTR, а повторяется попытка чтения (нечувствителен к неблокирующему модификатору).
\end{methodlist}

\subsubsection*{Строка}

\begin{methodlist}
  \declare{::readlines( path, sep = \$/, options = nil )}{\# -> array} 
  \verb!( path, size, options = nil ) # -> array!
  \\\verb!( path, sep, size, options = nil ) # -> array!
  
  Чтение строк и сохранение их в индексном массиве (размер массива может быть ограничен). Переданный разделитель обрабатывается в качестве символа перевода строки.
 
  \declare{.readlines( sep = \$/, size = nil )}{\# -> array} 
  Чтение строк и сохранение их в индексном массиве (размер массива может быть ограничен). Переданный разделитель обрабатывается в качестве символа перевода строки (если передается пустой текст, то обрабатывается "/n/n").
   
  \declare{.gets( sep = \$/, bytesize = nil )}{\# -> string}
  Чтение следующей строки из потока (размер строки может быть ограничен). Переданный разделитель обрабатывается в качестве символа перевода строки (если передается пустой текст, то обрабатывается "/n/n"). Если достигнут конец файла, то возвращается nil.

  Полученная в результате строка связывается с глобальной переменной \$_. 
 
  \declare{.readline( sep = \$/, bytesize = nil )}{\# -> string}
  Версия метода вызывающая ошибку при достижении конца файла. 
 
  \declare{.lineno}{\# -> integer}
  Возвращает позицию (порядковый номер) извлекаемой строки. Вызов метода аналогичен вызову глобальной переменной \$. 
 
  \declare{.lineno=(pos)}{\# -> integer}
  Объявление позиции (порядкового номера) извлекаемой строки. Позиция обновляется при последующем чтении данных из потока.  
 
  \declare{.seek( offset, object = IO::SEEK_SET )}{\# -> 0} 
  Объявление позиции (порядкового номера) извлекаемой строки относительно текущего положения и переданного смещения.

  Константы:
  \begin{description}
    \item[IO::SEEK_CUR] -> новая_позиция = текущая_позиция + offset
    \item[IO::SEEK_END] -> новая_позиция = конец_файла + offset
    \item[IO::SEEK_SET] -> новая_позиция = offset
  \end{description}   
 
  \declare{.sysseek( offset, object = IO::SEEK_SET )}{\# -> 0} 
  Версия предыдущего метода, использующая низкоуровневые возможности системы.

  \declare{.rewind}{\# -> 0} 
  Сброс позиции (порядковый номер) извлекаемой строки. Метод не может быть вызван для каналов, терминалов или сокетов. 
\end{methodlist}

\subsubsection*{Символ}

\begin{methodlist}
  \declare{.getc}{\# -> string}
  Чтение следующего символа из потока. Если достигнут конец файла, возвращается nil.

  \declare{.readchar}{\# -> string}
  Версия метода вызывающая ошибку при достижении конца файла. 
\end{methodlist}

\subsubsection*{Байт}

\begin{methodlist}
  \declare{.getbyte}{\# -> integer} 
  Чтение следующего байта из потока. Если достигнут конец файла, возвращается nil. 
 
  \declare{.readbyte}{\# -> integer} 
  Версия метода вызывающая ошибку при достижении конца файла. 
 
  \declare{.pos}{\# -> integer} 
  \alias{tell} 
  Возвращает позицию (порядковый номер) извлекаемого байта. 
 
  \declare{.pos=(pos)}{\# -> integer} 
  Объявление позиции (порядкового номера) извлекаемого байта. Позиция обновляется при последующем чтении данных из потока.
\end{methodlist}

\subsubsection*{Итераторы}

При итерации данных в потоке, поток должен быть доступен для чтения.

\begin{methodlist}
  \declare{::foreach( path, sep = \$/, options = nil ) \{ |string| \}}{\# -> nil} 
  \verb!( path, size, options = nil ) { |string| } # -> nil!
  \\\verb!( path, sep, size, options = nil ) { |string| } # -> nil!
  
  Последовательный перебор строк в потоке (выполняется чтение с помощью \method{::readlines}). Количество строк может быть ограничено. Переданный разделитель обрабатывается в качестве символа перевода строки.
 
  \declare{.each( sep = \$/ ) \{ |string| \}}{\# -> self} 
  \verb!(size) { |string| } # -> self!
  \\\verb!( sep, size) { |string| } # -> self!

  \alias{each_line, lines} 
  Последовательный перебор строк в потоке (выполняется чтение с помощью \method{.readlines}). Количество строк может быть ограничено. Переданный разделитель обрабатывается в качестве символа перевода строки.
 
  \declare{.bytes \{ |byte| \}}{\# -> self}
  \alias{each_byte} 
  Последовательно перебирает байты в потоке.
 

  \declare{.chars \{ |char| \}}{\# -> self}
  \alias{each_char} 
  Последовательно перебирает символы в потоке. 
 
  \declare{.codepoints \{ |point| \}}{\# -> self}
  \alias{codepoints} 
  Последовательно перебирает кодовые позиции в потоке.
 \end{methodlist} 

\subsection{Запись данных} 

Для записи данных поток должен быть доступен для записи.

Дополнительный аргумент, передаваемый методам влияет на автоматически создаваемый поток.
\begin{keylist}{Принимаемые элементы:}
  
  \firstkey{encoding:} внешняя кодировка. Игнорируется если указана размер фрагмента;
  
  \key{mode:} вид создаваемого потока. Объект должен содержать модификатор r;
  
  \key{perm:} права доступа к файлу;
  
  \key{open_args:} массив аргументов, используемых при открытии файла.
\end{keylist}

\begin{methodlist}
  \declare{::write( path, string, start = nil, options = nil )}{\# -> string.length}
  Запись текста, начиная с переданной позиции (по умолчанию - в конец файла). После записи данных файл закрывается.

  \declare{::binwrite( path, string, start = nil )}{\# -> string.length}
  Запись текста, начиная с переданной позиции (по умолчанию - в конец файла). После записи данных файл закрывается. Поток создается в режиме \verb!"rb:ASCII-8BIT"!.

  \declare{.write(object)}{\# -> object.to_s.bytesize}
  Запись \verb!object.to_s! в поток. 

  \declare{.syswrite(object)}{\# -> object.to_s.bytesize}
  Версия предыдущего метода, использующая низкоуровневые возможности системы.
 
  \declare{io \twoless object}{\# -> io}
  Запись \verb!object.to_s! в поток. 
 
  \declare{.write_nonblock(string)}{\# -> string.length}
  Запись текста в поток, не блокирующая процесс выполнения. В этом случае при ошибке записи, она будет вызвана немедленно. Буфер программы освобождается перед выполнением записью.    

  \declare{.print( *object = \$_ )}{\# -> nil}
  Запись \verb!object.to_s! в поток для всех переданных аргументов.
  \begin{itemize}
    \item Если глобальная переменная \$,, отвечающая за разделение элементов, не ссылается на nil, то она будет использоваться для разделения аргументов. 
    \item Если глобальная переменная \$\textbackslash, отвечающая за разделение данных, не ссылается на nil, то она будет использована после записи всех объектов. 
  \end{itemize}
 
  \declare{.printf( format, *object = nil )}{\# -> nil}
  Запись отформатированных объектов в поток - \verb!string % [*object]!. 
   
  \declare{.putc(object)}{\# -> object}
  Запись \verb!object.to_s! в поток. Переданное число считается кодовой позицией.
 
  \declare{.puts( *object = \$\\ )}{\# -> nil}
  Запись \verb!object.to_s! в поток. Аргументы разделяются с помощью перевода строки. Из индексного массива извлекаются все элементы.
\end{methodlist}

\subsubsection*{Работа с буфером}

Запись данных в файл выполняется автоматически, но не моментально. Сначала данные сохраняются в буфере программы, создаваемом интерпретатором.

\begin{methodlist}
  \declare{.ungetbyte(object)}{\# -> nil}
  Запись в буфер текста или байта (не повлияет на вызов низкоуровневых методов для чтения, например .sysread).

  \declare{.ungetc(char)}{\# -> nil} 
  Запись в буфер символа (не повлияет на вызов низкоуровневых методов для чтения, например .sysread). 

  \declare{.fdatasync}{\# -> 0} 
  Сохранение буфера в файл. 

  \declare{.fsync}{\# -> 0} 
  Сохранение буфера в файл. 

  \declare{.flush}{\# -> 0} 
  Освобождение буфера.

  \declare{.sync=(bool)}{\# -> bool}
  Режим синхронизации - любые записываемые данные сразу передаются операционной системе, а не записываются в буфер программы. 

  \declare{.sync}{}
  Возвращает текущий режим синхронизации.
\end{methodlist}

\subsection{Стандартные потоки}

Три стандартных потока, создаваемых при запуске программы, позволяют передавать произвольные данные между системой и программой. По умолчанию стандартные потоки соединены с терминалом, из которого запущена программа.

Если программа работает с файлами, то стандартные потоки иногда перенаправляют в файл.

\begin{keylist}{Потоки:}
  
  \firstkey{STDIN (\$stdin)} - стандартный поток для ввода. Используется для получения команд пользователя или входных данных.

  \key{STDOUT (\$stdout, \$>)} - стандартный поток для вывода. Используется для передачи полученных данных системе; 
  
  \key{STDERR (\$stderr)} - стандартный поток для вывода ошибок. Используется для вывода диагностичеких и отладочных сообщений;
\end{keylist}

\subsubsection*{Запись данных}

\begin{methodlist}
  \declare{object.display( io = \$> )}{\# -> nil}
  Запись объекта в поток. По умолчанию используется стандартный поток для вывода.

  \declare{p( *object = nil )}{\# -> object}
  Запись \verb!object.inspect! в стандартный поток для вывода, объединяя аргументы в один текст, разделенный с помощью \verb!$/!. В результате возвращается переданный объект или массив объектов.
 
  \declare{print( *object = nil )}{\# -> nil} 
  Аналогично выполнению \verb!$stdout.print *object!. 

  \declare{printf( format, *object = nil )}{\# -> nil} 
  Аналогично выполнению \verb!$stdout.printf format, *object!.
 
  \declare{putc(object)}{\# -> object} 
  Аналогично выполнению \verb!$stdout.putc object!.
 
  \declare{puts(*object)}{\# -> nil} 
  Аналогично выполнению \verb!$stdout.puts *object!.
 
  \declare{warn(message)}{\# -> nil}
  Запись объекта в стандартны поток для вывода ошибок. Выполнение программы продолжается.
\end{methodlist}

\subsection{Мультиплексирование}

Мультиплексирование потоков блокирует процесс выполнения, но снижает время ожидания, обрабатывая сразу несколько потоков.

\begin{methodlist}
  \declare{IO::select}{( reads, writes = nil, errors = nil, sec = nil)}
  Системный вызов \verb!select(2)!. Мониторинг переданных массивов потоков, ожидающий готовность потоков для дальнейшего чтения, для записи и потоков, получивших сообщение.

  Возвращает массив, состоящий из подмассивов готовых потоков. Обычно возвращается поток, который освободился первым. Если время ожидания истекло, а ни один поток не готов, то возвращается nil.
  \begin{verbatim}
  rp, wp = IO.pipe
  mesg = "ping "
  100.times \{
    rs, ws, = IO.select([rp], [wp])
    if r = rs[0]
      ret = r.read(5)
      print ret
      case ret
      when /ping/
        mesg = "pong\textbackslash n"
      when /pong/
        mesg = "ping "
      end
    end
    if w = ws[0]
      w.write(mesg)
    end
  \}
  # ->
  ping pong
  ping pong
  ping pong
  (snipped)
  ping
  \end{verbatim}
\end{methodlist}
 
\section{Файловая система}

Подробное описание структуры файловой системы приведено в \hyperlink{appfile}{\underline{приложении}}.

\subsection{Файлы}

Файл - это фундаментальная абстракция в Linux. Linux придерживается философии "все есть файл", а значит большая часть взаимодействия реализуется через чтение и запись файлов. Операции с файлом осуществляются с помощью уникального файлового дескриптора. Большая часть системного программирования в Linux состоит в работе с файловыми дескрипторами.

Так как класс File, наследует классу IO, то с его экземплярами можно работать также, как если бы они были обычными потоками.

При открытии файла создается поток, позволяющий получить доступ к данным, сохраненным в файле.

Также в системе регистрируется файловый дескриптор - цифровой идентификатор открытого файла.

\begin{keylist}{Константы}
  
  \firstkey{File::SEPARATOR} - символ, использующийся для разделения каталогов. В Windows обратная косая черта (\textbackslash), а в Linux - косая черта (/); 
  
  \key{File::ALT_SEPARATOR} - альтернативный разделитель для каталогов;
  
  \key{File::PATH_SEPARATOR} - символ, использующийся для разделения нескольких путей (":");
  
  \key{File::NULL} - путь к нулевому устройству.
\end{keylist}

\begin{methodlist}
  \declare{::new( name, mode, *perm = nil )}{\# -> file} 
  Открытие файла и создание объекта для него. 
  
  \declare{::open( name, mode, *perm = nil )}{\# -> 0} 
  \verb!( name, mode, *perm = nil )  { |file| } # -> object!
  
  Метод, аналогичный предыдущему, но, в отличии от него, принимающий блок, после выполнения которого файл закрывается.
\end{methodlist}

\subsubsection*{Работа с файловой системой} 

\begin{methodlist}
  \declare{::delete(*path)}{\# -> integer} 
  \alias{unlink} 
  Удаляет переданные файлы и возвращает их количество. 

  \declare{::truncate( path, bytesize )}{\# -> 0} 
  Обрезает файл до указанного размера (в байтах). 

  \declare{::rename( path, new_name )}{\# -> 0} 
  Переименовывает файл. Если файл не был переименован, то вызывается ошибка. 

  \declare{::symlink( path, name )}{\# -> 0} 
  Создает ярлык для файла. 

  \declare{::link( path, new_name )}{\# -> 0} 
  Создает жесткую ссылку для файла. Если файл с таким именем уже существует, то вызывается ошибка. 

  \declare{::utime( atime, mtime, *path )}{\# -> integer}
  Изменяет время последнего доступа к файлу и время изменения файла. В результате возвращается количество файлов.

  \declare{::readlink(path)}{\# -> filename} 
  Возвращает имя файла, связанного с переданным методу ярлыком.

  \declare{.flock(constants)}{\# -> 0} 
  Объявляет тип блокировки файла. Блокировка файлов необходима для ограничения одновременного доступа различных программ к одному файлу.
  \begin{description}
    \item[File::LOCK_EX] - эксклюзивная блокировки (для записи). Доступ к файлу будет запрещен до закрытия файла текущей программой. Только одна программа может устанавливать такую блокировку; 

    \item[File::LOCK_NB] - процесс выполнения программы не будет заблокирован;

    \item[File::LOCK_SH] - совместная блокировка файла (для чтения). Блокировка применяется при чтении информации из файла несколькими программами одновременно. Произвольное число программ могут устанавливать такую блокировку;

    \item[File::LOCK_UN] - отмена блокировки.
  \end{description}
 
  \declare{.truncate(bytesize)}{\# -> 0} 
  Обрезает файл до указанного размера (в байтах).
\end{methodlist}

\subsubsection*{Путь к файлу}

\begin{methodlist}
  \declare{::path(object)}{\# -> path}
  Преобразование объекта с помощью метода \method{.to_path}. Если такой метод не определен, то вызывается ошибка. 

  \declare{::absolute_path( filename, basedir = File::pwd )}{\# -> path}
  Возвращает абсолютный путь. Тильда считается частью имени каталога.
  \begin{verbatim}
  File.expand_path "test.rb", "~"
  # -> "/home/krugloff/~/test.rb"
  File.expand_path "/test.rb", ".rb" # -> "/test.rb"
  \end{verbatim}  

  \declare{::expand_path( filename, basedir = File::pwd )}{\# -> path}
  Возвращает абсолютный путь. Тильда соответствует домашнему каталогу.
  \begin{verbatim}
  File.expand_path "test.rb", "~" # -> "/home/krugloff/test.rb" 
  File.expand_path "/test.rb", ".rb" # -> "/test.rb"
  File.expand_path('../config/environment', "my_app/config.ru") 
  # -> "/home/mak/my_app/config/environment"
  \end{verbatim} 

  \declare{::realdirpath( filename, basedir = File::pwd )}{\# -> path}
  Возвращает абсолютный путь. Тильда считается частью имени каталога. Реальное существование каталога обязательно. В другом случае будет вызвана ошибка. При этом существование файла не проверяется.
  \begin{verbatim}
  File.realdirpath "test.rb", "~" # -> error!
  File.realdirpath "/test.rb", ".rb" # -> "/test.rb"
  \end{verbatim} 

  \declare{::realpath( filename, basedir = File::pwd )}{\# -> path}
  Возвращает абсолютный путь. Тильда считается частью имени каталога. Реальное существование файла обязательно.
  \begin{verbatim}
  File.realpath "test.rb", "~" # -> error! 
  File.realpath "/test.rb", ".rb" # -> error!
  \end{verbatim}

  \declare{::basename( path, extname = nil )}{\# -> filename}
  Извлекает имя файла из переданного пути (для разделения каталогов должна использоваться косая черта). Необязательный суффикс будет удален из результата. 
  \\\verb!File.basename "/test.rb", ".rb" # -> "test"!

  \declare{::dirname(path)}{\# -> basedir}
  Извлекает путь к базовому каталогу из переданного пути (для разделения каталогов должна использоваться косая черта). 
  \\\verb!File.dirname "/test.rb" # -> "/"!

  \declare{::split(path)}{\# -> array} 
  Возвращает индексный массив вида 
  \\\verb![ File.dirname(path), File.basename(path) ]!. 
  \\\verb!File.split "/test.rb" # -> [ "/", "test.rb" ]!

  \declare{::extname(path)}{\# -> extname}
  Возвращает расширение файла. Для каталогов возвращается пустой текст.
  \\\verb!File.extname "/test.rb" # -> ".rb"!

  \declare{::join(*name)}{\# -> path} 
  Создание пути из переданных имен. Объекты разделяются с помощью \constant{File::SEPARATOR}. 
  \\\verb!File.join "/", "test", ".rb" # -> "/test/.rb"!

  \declare{::fnmatch?( pattern, path, constants = nil )}{}
  \alias{fnmatch} 
  Проверяет соответствие пути переданному образцу.

  \declare{::identical?( path, path2 )}{}
  Сравнение двух путей. 
\end{methodlist}

\subsubsection*{Права доступа}

\begin{methodlist}
  \declare{::chmod( *perm, *path )}{\# -> integer}
  Изменение прав доступа. Возвращается количество файлов. 

  \declare{::lchmod( perm, *path )}{\# -> integer}
  Версия метода, аналогичная предыдущему. Для ярлыков изменяет права доступа к ярлыку, а не к файлу, на который ярлык ссылается. 

  \declare{::chown( user, group, *path )}{\# -> integer}
  Изменение владельца и группы. Возвращается количество файлов. Только администратор может изменить владельца файла. Текущий владелец может изменить группу на любую в которую входит. Владелец и группа устанавливаются с помощью их цифровых идентификаторов. Идентификаторы 0 и -1 игнорируются. 

  \declare{::lchown( user, group, *path )}{\# -> integer}
  Версия метода, аналогичная предыдущему. Для ярлыков изменяет данные ярлыка, а не файла, на который ярлык ссылается. 
 
  \declare{::umask( mask = nil )}{\# -> old_perm}
  Возвращает права доступа, присваивающиеся создаваемым файлам и каталогам. Переданное число вычитается из прав доступа, используемых по умолчанию, и используется для объявление новых. 
  
  \declare{::readable?(path)}{}
  Проверяет возможность чтения на основе действующего идентификатора. 

  \declare{::readable_real?(path)}{}
  Проверяет возможность чтения на основе реального идентификатора.

  \declare{::world_readable?(path)}{}
  Возвращает права доступа к файлу, если он доступен для чтения всем пользователям. В другом случае возвращается nil. 

  \declare{::writable?(path)}{}
  Проверяет возможность записи на основе действующего идентификатора. 

  \declare{::writable_real?(path)}{}
  Проверяет возможность записи на основе реального идентификатора. 

  \declare{::world_writable?(path)}{}
  Возвращает права доступа к файлу, если он доступен для записи всем пользователям. В другом случае возвращается nil. 

  \declare{::executable?(path)}{}
  Проверяет возможность выполнения файла на основе действующего идентификатора.

  \declare{::executable_real?(path)}{}
  Проверяет возможность выполнения файла на основе реального идентификатора.

  \declare{::setuid?(path)}{}
  Проверяет возможность выполнения файла с правами владельца. 

  \declare{::setgid?(path) }{}
  Проверяет возможность выполнения файла с правами группы. 

  \declare{::sticky?(path)}{}
  Проверяет наличие дополнительного свойства (sticky bit) для каталогов. 

  \declare{::owned?(path)}{}
  Проверяет равенство идентификатора владельца файла и действующего идентификатора. 

  \declare{::grpowned?(path) }{}
  Проверяет равенство цифрового идентификатора группы для файла и цифрового идентификатора группы для программы.
\end{methodlist}

\subsubsection*{Статистика}

\begin{methodlist}
  \declare{::stat(path)}{\# -> file_stat}
  Возвращает экземпляр класса File::Stat, содержащий информацию о файле. 

  \declare{::lstat(path)}{\# -> file_stat} 
  Версия метода, аналогичная предыдущему. Для ярлыков сохраняется информация об ярлыке, а не о файле, на который ярлык ссылается.

  \declare{.lstat}{\# -> file_stat} 
  Версия метода, аналогичная предыдущему. Для ярлыков сохраняется информация об ярлыке, а не о файле, на который ярлык ссылается.

  \declare{::atime(path)}{\# -> time} 
  Возвращает время последнего доступа к файлу.

  \declare{.atime}{\# -> time} 
  Возвращает время последнего доступа к файлу. 

  \declare{::ctime(path)}{\# -> time} 
  Возвращает время последнего изменения информации о файле (но не самого файла).

  \declare{.ctime}{\# -> time} 
  Возвращает время последнего изменения информации о файле (но не самого файла).

  \declare{::mtime(path)}{\# -> time} 
  Возвращает время последнего изменения файла.

  \declare{.mtime}{\# -> time} 
  Возвращает время последнего изменения файла.

  \declare{::size(path)}{\# -> integer} 
  Возвращает размер файла.

  \declare{.size}{\# -> integer} 
  Возвращает размер файла.

  \declare{::ftype(path)}{\# -> string}
  Возвращает тип файла. 
  \begin{description}
    \item["file"] - обычный файл; 
    \item["directory"] - каталог; 
    \item["blockSpecial"] - блочное устройство; 
    \item["characterSpecial"] - символьное устройство; 
    \item["fifo"] - именованный канал; 
    \item["link"] - ссылка; 
    \item["socket"] - сокет; 
    \item["unknown"] - неизвестный тип.
  \end{description}

  \declare{.path}{\# -> path}
  \alias{to_path} 
  Возвращает путь к файлу (переданный при его открытии). 
\end{methodlist}

\subsubsection*{Предикаты}

\begin{methodlist}
  \declare{::exist?(path)}{} 
  \alias{exists?} 
  Проверяет существование файла. 

  \declare{::size?(path)}{\# -> integer}
  Проверяет существование файла. Для существующих файлов возвращается их размер.

  \declare{::zero?(path)}{} 
  Проверяет существование файла нулевого размера. 

  \declare{::file?(path)}{} 
  Проверяет относится ли файл к обычным. 

  \declare{::symlink?(path)}{} 
  Проверяет относится ли файл к ярлыкам. 

  \declare{::directory?(path)}{} 
  Проверяет относится ли файл к каталогам или к ярлыкам на каталог. 

  \declare{::blockdev?(path)}{} 
  Проверяет относится ли файл к блочным устройствам. 

  \declare{::chardev?(path)}{} 
  Проверяет относится ли файл к символьным устройствам. 

  \declare{::pipe?(path)}{} 
  Проверяет относится ли файл к каналам. 

  \declare{::socket?(path)}{} 
  Проверяет относится ли файл к сокетам.
\end{methodlist} 

\subsection{Каталоги}

Каталог - это файл, содержащий информацию о расположении какой-либо группы файлов. Для работы с каталогами в Ruby используется класс Dir (добавлен модуль Enumerable).

\itemtitle{Виды каталогов:}
\begin{description}
  \item[Базовый каталог]- каталог, в котором находится файл;
  \item[Рабочий каталог] - каталог, относительно которого выполняется программа. Поиск файлов выполняется относительно рабочего каталога;
  \item[Домашний каталог] - персональный каталог пользователя, зарегистрированного в системе.
\end{description}

\begin{methodlist}
  \declare{::new(path)}{\# -> dir} 
  Создание нового объекта - абстракции над каталогом. 

  \declare{::open(path)}{\# -> dir}
  \verb!(path) { |dir| } # -> dir!

  Аналогично выполнению \verb!Dir.new path!. Новый объект может быть передан блоку. После выполнения блока каталог закрывается.

  \declare{.close}{\# -> nil} 
  Закрывает каталог. Любая попытка использования приведет к вызову ошибки. 
\end{methodlist}

\subsubsection*{Работа с файловой системой}

\begin{methodlist}
  \declare{::mkdir( name, *perm = nil )}{\# -> 0} 
  Создание каталога (в текущем рабочем каталоге). Если каталог не был создан, то вызывается ошибка.

  \declare{::delete(path)}{\# -> 0} 
  \alias{rmdir, unlink} 
  Удаление каталога. При попытке удалить каталог, содержащий файлы, вызывается ошибка.

  \declare{::chdir( path = Dir.home )}{\# -> 0} 
  \verb!( path = Dir.home ) { |path| } # -> object!

  Изменение рабочего каталога либо для всей программы, либо только в теле блока.

  \declare{::chroot(path)}{\# -> 0} 
  Изменение корневого каталога в Unix-подобных системах. Программа, запущенная с изменённым корневым каталогом, будет иметь доступ только к файлам, содержащимся в данном каталоге. Только пользователь с правами администратора может изменить корневой каталог программы.
\end{methodlist}

\subsubsection*{Содержимое каталога}

\begin{methodlist}
  \declare{::entries(path)}{\# -> array} 
  Возвращает список имен всех файлов, содержащихся в каталоге.

  \declare{::glob( pattern, constants = nil )}{\# -> array} 
  \verb!( pattern, constants = nil ) { |name| } # -> nil!

  Возвращает список имен файлов, подходящих под переданный шаблон (синтаксис шаблонов описан в приложении). Чувствительность к регистру зависит от ОС. Если методу передан блок, то найденные совпадения будут переданы в блок. Дополнительно могут быть переданы константы, влияющие на поиск.

  \declare{Dir[pattern]}{\# -> array}
  Аналогично выполнению \verb!Dir.glob pattern, 0!. 

  \declare{.read}{\# -> name}
  Возвращает имя следующего файла. При достижении конца каталога возвращается nil. 
 
  \declare{.pos}{\# -> integer} 
  \alias{tell} 
  Возвращает текущую позицию в каталоге. 

  \declare{.seek(pos)}{\# -> self} 
  Переход к переданной позиции. 
 
  \declare{.pos=(pos)}{\# -> integer} 
  Переход к переданной позиции.

  \declare{.rewind}{\# -> self}
  Сброс текущей позиции в каталоге.
\end{methodlist}

\subsubsection*{Итераторы}

\begin{methodlist}
  \declare{.each \{ |name| \}}{\# -> self} 
  Последовательно перебирает имена всех файлов в каталоге. 

  \declare{::foreach(path) \{ |name| \}}{\# -> nil} 
  Последовательно перебирает имена всех файлов в каталоге. 
\end{methodlist}

\subsubsection*{Остальное}

\begin{methodlist}
  \declare{::directory?(path)}{} 
  \alias{exist?, exists?} 
  Проверяет относится ли файл к каталогам или к ярлыкам, ссылающимся на каталог.

  \declare{::getwd}{\# -> path}
  \alias{pwd} 
  Возвращает путь к рабочему каталогу программы. 
 
  \declare{::home( user = nil )}{\# -> path}
  Возвращает путь к домашнему каталогу текущего пользователя или пользователя с переданным идентификатором. 

  \declare{.inspect}{\# -> string} 
  Возвращает информацию об объекте. 
 
  \declare{.path}{\# -> path}
  Возвращает путь к каталогу (переданный при создании объекта).
\end{methodlist}
    
\section{Информация о файле}

\begin{methodlist}
  \declare{test( type, path, path2 = nil )}{}
  Возвращает информацию о переданных файлах.

  \begin{keylist}{Тип информации:}
    
    \firstkey{?A}  - возвращает время последнего доступа к файлу;
    
    \key{?C} - возвращает время последнего изменения информации о файле; 
    
    \key{?M} - возвращает время последнего изменения файла;

    \key{?e} - проверяет существование файла;
    
    \key{?s} - возвращает размер файла. Для фалов нулевого размера возвращается nil;
    
    \key{?z} - проверяет существование файла нулевого размера;
    
    \key{?f} - проверяет относится ли файл к обычным;
    
    \key{?L} - проверяет относится ли файл к ярлыкам;
    
    \key{?d} - проверяет относится ли файл к каталогам;
    
    \key{?b} - проверяет относится ли файл к блочным устройствам;
    
    \key{?c} - проверяет относится ли файл к символьным устройствам;
    
    \key{?S} - проверяет относится ли файл к сокетам;
    
    \key{?p} - проверяет относится ли файл к очередям;
    
    \key{?r} - проверяет возможность чтения на основе действующего идентификатора; 
    
    \key{?R} - проверяет возможность чтения на основе реального идентификатора; 
    
    \key{?w} - проверяет возможность записи на основе действующего идентификатора;
    
    \key{?W} - проверяет возможность записи на основе реального идентификатора; 
    
    \key{?x} - проверяет возможность выполнения на основе действующего идентификатора; 
    
    \key{?X} - проверяет возможность выполнения на основе реального идентификатора; 
    
    \key{?u} - проверяет возможность выполнения файла с правами владельца; 
    
    \key{?g} - проверяет возможность выполнения файла с правами группы; 
    
    \key{?K} - проверяет существование дополнительного свойства (sticky bit) для каталогов; 
    
    \key{?o} - проверяет равенство идентификатора владельца файла и действующего идентификатора; 
    
    \key{?O} - проверяет равенство идентификатора владельца файла и реального идентификатора; 
    
    \key{?G} - проверяет равенство идентификатора группы для файла и идентификатора группы для программы; 
    
    \key{?-} - проверяет ссылаются ли два пути на один и тот же файл;
    
    \key{?=} - проверяет равенство времени последнего изменения двух файлов;
    
    \key{?<} - сравнивает время последнего изменения двух файлов;
    
    \key{?>} - сравнивает время последнего изменения двух файлов.
  \end{keylist}
\end{methodlist}  

Для получения информации о файле также предоставлены классы File::Stat и модуль FileTest. 

\subsection{File::Stat}

Экземпляры класса File::Stat возвращаются методами \method{.stat} и \method{l.stat}. Это позволяет получать полную информацию о файле, обратившись к системе только один раз.

\begin{methodlist}
  \declare{::new(path)}{\$ -> stat} 
  Сбор информации о файле. Если файла не существует, то вызывается ошибка.
\end{methodlist}

\subsubsection*{Приведение типов}

\begin{methodlist}
  \declare{.inspect}{\# -> string} 
  Интерпретатор возвращает текст, содержащий информацию об объекте.
\end{methodlist}

\subsubsection*{Операторы}

\begin{methodlist}
  \declare{stat <=> stat2}{} 
  Сравнивает время получения информации.
\end{methodlist}

\subsubsection*{Права доступа}

\begin{methodlist}
  \declare{.uid}{\# -> integer} 
  Возвращает цифровой идентификатор владельца. 
 
  \declare{.gid}{\# -> integer} 
  Возвращает цифровой идентификатор группы. 

  \declare{.mode}{\# -> perm}
  Возвращает права доступа. 

  \declare{.readable?}{}
  Проверяет возможность чтения на основе действующего идентификатора. 

  \declare{.readable_real?}{}
  Проверяет возможность чтения на основе реального идентификатора.

  \declare{.world_readable?}{}
  Возвращает права доступа к файлу, если он доступен для чтения всем пользователям. В другом случае возвращается nil. 

  \declare{.writable?}{}
  Проверяет возможность записи на основе действующего идентификатора. 

  \declare{.writable_real?}{}
  Проверяет возможность записи на основе реального идентификатора. 

  \declare{.world_writable?}{}
  Возвращает права доступа к файлу, если он доступен для записи всем пользователям. В другом случае возвращается nil. 

  \declare{.executable?}{}
  Проверяет возможность выполнения файла на основе действующего идентификатора.

  \declare{.executable_real?}{}
  Проверяет возможность выполнения файла на основе реального идентификатора.

  \declare{.setuid?}{}
  Проверяет возможность выполнения файла с правами владельца. 

  \declare{.setgid? }{}
  Проверяет возможность выполнения файла с правами группы. 

  \declare{.sticky?}{}
  Проверяет наличие дополнительного свойства (sticky bit) для каталогов. 

  \declare{.owned?}{}
  Проверяет равенство идентификатора владельца файла и действующего идентификатора. 

  \declare{.grpowned? }{}
  Проверяет равенство цифрового идентификатора группы для файла и цифрового идентификатора группы для программы.
\end{methodlist}

\subsubsection*{Статистика}

\begin{methodlist}
  \declare{.atime}{\# -> time} 
  Возвращает время последнего доступа к файлу. 

  \declare{.ctime}{\# -> time} 
  Возвращает время последнего изменения информации о файле (но не самого файла).

  \declare{.mtime}{\# -> time} 
  Возвращает время последнего изменения файла.

  \declare{.size}{\# -> integer} 
  Возвращает размер файла.

  \declare{.ftype}{\# -> string}
  Возвращает тип файла. 
  \begin{description}
    \item["file"] - обычный файл; 
    \item["directory"] - каталог; 
    \item["blockSpecial"] - блочное устройство; 
    \item["characterSpecial"] - символьное устройство; 
    \item["fifo"] - именованный канал; 
    \item["link"] - ссылка; 
    \item["socket"] - сокет; 
    \item["unknown"] - неизвестный тип.
  \end{description}

  \declare{.blksize}{\# -> integer} 
  Возвращает системный размер блока, выделенного для файла. Для систем, не поддерживающих эту информацию возвращается nil. 
 
  \declare{.blocks}{\# -> integer} 
  Возвращает системный номер блока, выделенного для файла. Для систем, не поддерживающих эту информацию возвращается nil. 
 
  \declare{.dev}{\# -> integer} 
  Возвращает цифровой код устройства, на котором размещена информация о файле. 
 
  \declare{.dev_major}{\# -> integer} 
  Возвращает основную часть цифрового кода устройства. 
 
  \declare{.dev_minor}{\# -> integer} 
  Возвращает дополнительную часть цифрового кода устройства. 
 
  \declare{.rdev}{\# -> integer} 
  Возвращает цифровой код устройства, на котором размещена информация о файле. 
 
  \declare{.rdev_major}{\# -> integer} 
  Возвращает основную часть цифрового кода устройства. 
 
  \declare{.rdev_minor}{\# -> integer} 
  Возвращает дополнительную часть цифрового кода устройства. 
 
  \declare{.ino}{\# -> integer} 
  Возвращает inode код файла. С помощью этого кода получается информация о файле от системы.

  \declare{.nlink}{\# -> integer} 
  Возвращает цифровой код жесткой ссылки.
\end{methodlist}

\subsubsection*{Предикаты}

\begin{methodlist}
  \declare{.zero?}{} 
  Проверяет существование файла нулевого размера. 

  \declare{.file?}{} 
  Проверяет относится ли файл к обычным. 

  \declare{.symlink?}{} 
  Проверяет относится ли файл к ярлыкам. 

  \declare{.directory?}{} 
  Проверяет относится ли файл к каталогам или к ярлыкам на каталог. 

  \declare{.blockdev?}{} 
  Проверяет относится ли файл к блочным устройствам. 

  \declare{.chardev?}{} 
  Проверяет относится ли файл к символьным устройствам. 

  \declare{.pipe?}{} 
  Проверяет относится ли файл к каналам. 

  \declare{.socket?}{} 
  Проверяет относится ли файл к сокетам.
\end{methodlist}

\subsection{FileTest}

\subsubsection*{Права доступа}

\begin{methodlist}
  \declare{::readable?(path)}{}
  Проверяет возможность чтения на основе действующего идентификатора. 

  \declare{::readable_real?(path)}{}
  Проверяет возможность чтения на основе реального идентификатора.

  \declare{::world_readable?(path)}{}
  Возвращает права доступа к файлу, если он доступен для чтения всем пользователям. В другом случае возвращается nil. 

  \declare{::writable?(path)}{}
  Проверяет возможность записи на основе действующего идентификатора. 

  \declare{::writable_real?(path)}{}
  Проверяет возможность записи на основе реального идентификатора. 

  \declare{::world_writable?(path)}{}
  Возвращает права доступа к файлу, если он доступен для записи всем пользователям. В другом случае возвращается nil. 

  \declare{::executable?(path)}{}
  Проверяет возможность выполнения файла на основе действующего идентификатора.

  \declare{::executable_real?(path)}{}
  Проверяет возможность выполнения файла на основе реального идентификатора.

  \declare{::setuid?(path)}{}
  Проверяет возможность выполнения файла с правами владельца. 

  \declare{::setgid?(path) }{}
  Проверяет возможность выполнения файла с правами группы. 

  \declare{::sticky?(path)}{}
  Проверяет наличие дополнительного свойства (sticky bit) для каталогов. 

  \declare{::owned?(path)}{}
  Проверяет равенство идентификатора владельца файла и действующего идентификатора. 

  \declare{::grpowned?(path) }{}
  Проверяет равенство цифрового идентификатора группы для файла и цифрового идентификатора группы для программы.
\end{methodlist}

\subsubsection*{Предикаты}

\begin{methodlist}
  \declare{::exist?(path)}{} 
  \alias{exists?} 
  Проверяет существование файла. 

  \declare{::size?(path)}{\# -> integer}
  Проверяет существование файла. Для существующих файлов возвращается их размер.

  \declare{::zero?(path)}{} 
  Проверяет существование файла нулевого размера. 

  \declare{::file?(path)}{} 
  Проверяет относится ли файл к обычным. 

  \declare{::symlink?(path)}{} 
  Проверяет относится ли файл к ярлыкам. 

  \declare{::directory?(path)}{} 
  Проверяет относится ли файл к каталогам или к ярлыкам на каталог. 

  \declare{::blockdev?(path)}{} 
  Проверяет относится ли файл к блочным устройствам. 

  \declare{::chardev?(path)}{} 
  Проверяет относится ли файл к символьным устройствам. 

  \declare{::pipe?(path)}{} 
  Проверяет относится ли файл к каналам. 

  \declare{::socket?(path)}{} 
  Проверяет относится ли файл к сокетам.
\end{methodlist}

\subsubsection*{Остальное}

\begin{methodlist}
  \declare{::size(path)}{\# -> integer} 
  Возвращает размер файла.

  \declare{::identical?( path, path2 )}{}
  Сравнение двух путей.
\end{methodlist}