# Парадигмы программирования

Парадигма программирования - это система идей и понятий, определяющих стиль написания компьютерных программ. Отдельные парадигмы программирования не являются взаимоисключающими и, следовательно, могут сочетаться.


## ООП

*Объектно-ориентированная парадигма (ООП)* - это парадигма программирования, описывающая концепцию "объектов", связывающую данные и способы их обработки вместе. С ее помощью программа проектируется как набор объектов, обменивающихся сообщениями (методами) для взаимодействия.

Большинство основных положений ООП было развито в языке программирования Smalltalk, сильно повлиявшем на Ruby. В настоящее время количество прикладных языков программирования, реализующих ООП, преобладает над остальными парадигмами.

ООП развивает идеи процедурного программирования, где данные и способы их обработки формально не связаны.

Основные понятия, используемые в ООП - это абстракция, класс, объект, свойство, и метод. Также, большинство объектно-ориентированных языков позволяет реализовать инкапсуляцию, наследование и полиморфизм, в той или иной мере (мы рассмотрим что это такое позже).


~~~~~ note
Хоть ООП и является достаточно удобной парадигмой, не стоит забывать, что она далеко не единственная. В некоторых случаях применение объектного подхода не оправдано и снижает производительность и удобство создания программ. В любом случае, необдуманное и чрезмерное применение идей ООП усложняет и замедляет выполнение кода, превращая его в бесполезный, малопонятный набор выражений.
~~~~~


### Абстракция:

*Абстрагирование* - это способ выделить существенные свойства и игнорировать несущественные. Соответственно, *абстракция* - это набор выделенных существенных свойств.

Существенные свойства - это свойства, которыми нечто обязано обладать, чтобы бы его можно было идентифицировать. Несущественные свойства - свойства, обладание которыми необязательно.

Главное достоинство использования абстракций в программировании в том, что они позволяют игнорировать несущественные детали (не имеющие значения для работы программы). Абстракция - это один из главных способов борьбы со сложностью реального мира.


~~~~~ note
Что же такое абстракция в программировании? Например, стул, на котором вы сидите - это не абстракция. Это реальная вещь, которую можно потрогать, разобрать или использовать по назначению. А вот то, что вы думаете о стуле, это абстракция. Вы наделяете его абстрактными свойствами (существенными) - количество ножек (4), материал (дерево) и т.д. Некоторые свойства в данный момент времени для вас несущественны - наличие спинки, цвет, год покупки. При этом в разные моменты времени существенные и несущественные свойства могут меняться. Все абстракции довольно непостоянны и могут сильно отличаться от человека к человеку.

Иногда абстракции используют для вещей, которых в реальном мире даже не существует. Но речь не о призраках или магии, а, например, о денежных переводах. Существует ли такая вещь как денежный перевод? Есть деньги и счета, между которыми они переводятся. А перевод - это абстрактное описание этой операции. У него есть существенные свойства (сумма, валюта, получатель, отправитель) и не существенные (ммм... количество монет, например). Вся эта информация обычно хранится на каком-либо диске и обрабатывается компьютерами для того, чтобы люди могли получать свои деньги.
~~~~~

### Объект:

В центре ООП находится понятие объекта. Объект - это абстракция чего-либо, хранимая в памяти компьютера. В процессе выполнения программы объекты могут как создаваться, так и изменяться. Объекты в ООП также наделяют состоянием и поведением.

Состояние объекта - это хранимые объектом данные. Данные, в данном случае, это значения существенных свойств объекта. Каждое свойство имеет собственное название, позволяющее их различать (weight, hight).

Поведение объекта - это способы (методы) обработки хранимых данных. Методы также могут влиять на состояние объекта. Каждый способ имеет собственное название, позволяющее их различать (eat, jump).

Создание объектов позволяет уменьшить сложность программы, облегчая работу с выделенными группами данных.

Далее мы подробнее будем говорить об объектах, и их реализации в Ruby. Сейчас же, для облегчения понимания, вы можете рассматривать объекты как записи в памяти компьютера, вида:

~~~~~
object: 12312 - это идентификатор объекта,
использующийся для его поиска в памяти компьютера.

weight: 40kg
height: 60cm

eat: increase weight on 5kg and height on 5cm
~~~~~


### Класс:

*Классы* в ООП используются для группировки объектов, обладающих схожим набором свойств. Значения свойств при этом не учитываются. Фактически класс является образцом для создания новых объектов (формулой или руководством по эксплуатации) и содержит описание их структуры (имена свойств и доступные методы). Обычно классы создаются в процессе выполнения программы, но после создания не изменяются.

Объект, созданный по образцу класса называют экземпляром этого класса. В отличии от объектов, классы обычно не содержат конкретных данных (если не считать данные о структуре объектов). Передача данных классу позволяет создавать объекты с заранее известной структурой. Таким образом основное предназначение классов - определять поведение своих экземпляров, чтобы работа с каждым экземпляром выполнялась только определенным набором методов.

Классы позволяют объединять схожие сущности, уменьшая этим размеры и сложность программы.

Далее мы подробнее будем говорить о классах, и их реализации в Ruby. Сейчас же, для облегчения понимания, вы можете рассматривать классы как записи в памяти компьютера, вида:

~~~~~
class: fox - это название класса,
использующееся для его поиска в памяти компьютера.

define attribute weight
define attribute hight

define method eat: increase weight on 5kg and height on 5cm
~~~~~

При наличии классов, объект может быть выражен как запись вида:

~~~~~
object: 12312

class:  fox
weight: 40kg
height: 60cm
~~~~~


### Инкапсуляция:

Инкапсуляция - это механизм языка, позволяющий группировать данные и методы для их обработки в составе одной сущности (объекта). При этом доступ к данным объекта может быть получен только с помощью его методов. Большинство ООП языков облегчает инкапсуляцию объектов, но не требует ее. Однако это довольно полезный принцип и его нарушение, в большинстве случаев, неоправданно. В некоторых языках также существуют дополнительные инструменты, позволяющие еще больше ограничивать доступ к данным объекта.

+ Инкапсуляция снижает сложность разработки, позволяя создавать и изменять программу, переходя от одного независимого фрагмента, к другому;
+ Инкапсуляция облегчает возможность паралелльной разработки программы, ускоряя ее. Каждый разработчик может отвечать только за определенную группу данных и методов;
+ Инкапсуляция облегчает параллельное выполнение программы, ускоряя его. Когда части программы фрагментированны их проще выполнять одновременно.

Если вернутся к нашему примеру, то инкапсуляция объекта запрещает его изменение без ссылки на объект. То есть, вы не сможете изменить вес, не зная идентификатора (12312, к примеру). Если вы знаете идентификатор, то сможете изменить объект, но только с помощью метода eat (он был определен в классе, если вы помните).

~~~~~
object: 12312

class:  fox
weight: 40kg
height: 60cm
~~~~~


### Наследование:

Наследование - это механизм языка, позволяющий снова использовать уже реализованное поведение, в составе другой сущности. Объекты (обычно это классы) могут заимствовать и расширять уже имеющуюся функциональность (методы). Класс, который заимствуется (наследуется) называется базовым или суперклассом, а класс, который заимствует (наследует) - производным или подклассом. Все базовые и производные классы в общем создают иерархию классов программы.

+ Наследование снижает сложность, позволяя использовать уже известные фрагменты программы. Однако при сложной иерархии повышается объем кода, с которым работает программист в отдельный момент времени;
+ Наследование снижает время на разработку за счет повторного использования кода;
+ Наследование дополняет абстракцию, выделяя сущности с незначительным уровнем различий. Наследование позволяет создавать абстракции с различным уровнем реализации (дополнительными группами существенных свойств).


Вернемся к нашему примеру.

~~~~~
class: fox

define attribute weight
define attribute hight

define method eat: increase weight on 5kg and height on 5cm
~~~~~

Что случится если, мы захотим добавить в нашу программу кроликов? Неужели нам придется два раза хранить одну и ту же информацию? Тогда если мы захотим поменять код - нам придется менять его два раза.

~~~~~
class: fox

define attribute weight
define attribute hight

define method eat: increase weight on 5kg and height on 5cm
~~~~~

~~~~~
class: rabbit

define attribute weight
define attribute hight

define method eat: increase weight on 5kg and height on 5cm
~~~~~

К счастью, наследование решает эту задачу.

~~~~~
class: animal

define attribute weight
define attribute hight

define method eat: increase weight on 5kg and height on 5cm
~~~~~

~~~~~
class: fox
superclass: animal
~~~~~

~~~~~
class: rabbit
superclass: animal
~~~~~

Как вы видите, объем кода увеличился (по сравнению с одним классом), но сложность при этом уменьшилась.

### Полиморфизм:

Полиморфизм - это механизм языка, позволяющий производным классам изменять унаследованное поведение с сохранением общей структуры.

+ Полиморфизм снижает сложность, позволяя незначительно модифицировать уже существующую реализацию;
+ Полиморфизм повышает скорость разработки, позволяя быстро подстраиваться под требования заказчика;
+ Полиморфизм поддерживает возможность отдельной реализации базовых методов для производных классов.

Вернемся к нашему примеру. Как известно, кролики изменяются в размерах меньше, чем лисы. Нам придется поменять для них метод eat, но мы при этом не хотим изменять поведение базового класса. Если в языке возможна реализация полиморфизма, то изменить наш код будет довольно легко.

~~~~~
class: rabbit
superclass: animal

define method eat: increase weight on 1kg and height on 1cm
~~~~~

Хоп. Теперь кролики будут использовать для еды их собственный метод :)
