\chapter{Подпрограммы}

Подпрограммы - это именованный фрагмент программы, содержащий описание определенного набора действий. К подпрограммам относятся замыкания (процедуры и функции), методы и сопрограммы.

\section{Замыкания}

С помощью класса Proc предоставляется возможность создавать замыкания. 

Замыкания - это подпрограммы, в теле которых существуют локальные переменные, объявленные в окружающей программе.

Замыкания создаются заново каждый раз в момент выполнения.

Замыкания, так же как и объекты служат для инкапсуляции функциональности и данных.

Замыкания могут быть переданы методам как обычные блоки. Для этого перед аргументом записывают амперсанд.

Замыкания разделяются на процедуры (ведущие себя как блоки, но в действительности также относящиеся к функциям) и лямбда-функции (ведущие себя как методы).

\subsection{Процедуры}

\begin{methodlist}
  \declare{::new \{ |*params| \}}{\# -> proc}
  Создание нового объекта. В теле метода может принимать переданный ему блок.
  \begin{verbatim}
  def proc_from
    Proc.new
  end
  proc = proc_from \{ "hello" \}
  proc.call # -> "hello"
  \end{verbatim}

  \declare{proc \{ |*params| \}}{\# -> proc}
  Частный метод экземпляров из модуля Kernel, аналогичный предыдущему.
\end{methodlist}

Инструкция return в теле процедуры приводит к завершению выполнения метода, в теле которого объект был создан. Если выполнение метода уже завершено, то вызывается ошибка \error{LocalJumpError}.

Процедуры принимают аргументы также как и обычные блоки.

\subsection{Лямбда-функции}

\begin{methodlist}
  \declare{lambda \{ |*params| \}}{\# -> lambda}
  Создание объекта.

  \declare{->(*params) \{ \}}{\# -> lambda}
  Создание объекта. Круглые скобки не обязательны. Позволяется определять параметры, имеющие значения по умолчанию.
\end{methodlist}

Инструкция return в теле лямбда-функций приводит к завершению выполнения функции.

Лямбда-функции принимают аргументы также как и обычные методы.

\subsection{Использование замыканий}

\subsubsection*{Приведение типов}

\begin{methodlist}
  \declare{.to_proc}{\# -> self} 
 
  \declare{.to_s}{\# -> string} 
  Возвращает информацию об объекте. 
  \\\verb!Proc.new { }.to_s # -> "#<Proc:0x8850f18@(irb):31>"!
\end{methodlist}

\subsubsection*{Операторы}

\begin{methodlist}
  \declare{proc == proc2}{}
  \alias{eql?} 
  Два замыкания равны, если относятся к копиям одного и того же объекта. 
  \\\verb!proc {} == proc {} # -> true!

  \declare{proc === arg}{\# -> object} 
  Выполнение функции.
  \\\verb!proc {} === 1 # -> nil!
\end{methodlist}

\subsubsection*{Выполнение замыкания}

\begin{methodlist}
  \declare{.call(*arg)}{\# -> object} 
  \alias{yield, .(*arg), [*arg]} 
  Выполнение замыкания. 
  \\\verb!-> x {x**2}.(5) # -> 25!
 
  \declare{.curry( count = nil )*arg}{\# -> proc}
  Подготовка замыкания для выполнения.

  Если передано достаточное количество аргументов, то замыкание выполняется.

  В другом случае замыкание сохраняет информацию об аргументах.

  Дополнительный аргумент ограничивает количество передаваемых аргументов (остальным параметрам присваивается nil).
  \begin{verbatim}
  b = proc \{ | x, y, z | x + y + z \} 
  b.curry[1][2][3] # -> 6 
  b.curry[1, 2][3, 4] # -> 6 
  b.curry[1][2][3][4][5] # -> 0 
  b.curry(5) [ 1, 2 ][ 3, 4][5] # -> 6 
  b.curry(1) [1] # -> type_error

  b = lambda \{ | x, y, z | x + y + z \} 
  b.curry[1][2][3] # -> 6 
  b.curry[1, 2][3, 4] # -> argument_error 
  b.curry(5) # -> argument_error 
  b.curry(1) # -> argument_error
  \end{verbatim}
\end{methodlist}

\subsubsection*{Остальное}

\begin{methodlist}
  \declare{.arity}{\# -> integer}
  Возвращает количество принимаемых аргументов. Для произвольного количества возвращается отрицательное число. Его инверсия с помощью оператора \verb!~! в результате возвращает количество обязательных аргументов.
  \begin{verbatim}
  proc \{\}.arity # -> 0 
  proc \{ || \}.arity # -> 0 
  proc \{ |a| \}.arity # -> 1 
  proc \{ | a,b | \}.arity # -> 2 
  proc \{ | a, b, c | \}.arity # -> 3 
  proc \{ |*a| \}.arity # -> -1 
  proc \{ | a, *b | \}.arity # -> -2 
  proc \{ | a, *b, c | \}.arity # -> -3
  \end{verbatim} 
 
  \declare{.parameters}{\# -> array} 
  Возвращает информацию о параметрах.
  \begin{verbatim}
  proc = lambda \{ | x, y = 42, *other | \} 
  proc.parameters
  # -> [ [:req, :x],  [:opt, :y], [:rest, :other] ]
  \end{verbatim}

  \declare{.binding}{\# -> binding} 
  Возвращает экземпляр класса Binding, содержащий информацию о состоянии выполнения программы для замыкания.

  \declare{.lambda?}{} 
  Проверяет относится ли объект к лямбда-функциям. 
  \\\verb!proc {}.lambda? # -> false!
 
  \declare{.source_location}{\# -> array} 
  Возвращает местоположение создания замыкания в виде \verb![ filename, line ]!. Для замыканий, создаваемых не на Ruby, возвращается nil.
  \\\verb!proc {}.source_location # -> [ "(irb)", 19 ]!

  \declare{.hash}{\# -> integer} 
  Возвращает цифровой код объекта. 
  \\\verb!proc {}.hash # -> -259341767!
\end{methodlist}

\section{Методы}

Подпрограммы могут быть созданы на основе уже существующих методов с помощью классов Method и UnboundMethod.

\subsection{Method}

Экземпляры класса сохраняют информацию о методе вместе с объектом, для которого он вызывается.

\begin{methodlist}
  \declare{object.method(name)}{\# -> method}
  Создание объекта для метода с переданным идентификатором. Если метод для объекта не определен, то вызывается ошибка.
  \\\verb!12.method(?+) # -> #<Method: Fixnum#+>!

  \declare{object.public_method(name)}{\# -> method}
  Создание объекта для общего метода с переданным идентификатором. Если метод для объекта не определен, то вызывается ошибка. 
  \\\verb!12.public_method(?+) # -> #<Method: Fixnum#+>!
\end{methodlist}

\subsubsection*{Операторы}

\begin{methodlist}
  \declare{method == method2}{}
  \alias{eql?}
  Проверка на равенство. Объекты равны, если связаны с одним и тем же объектом и содержат информацию об одном и том же методе.
  \\\verb!12.method(?+) == 13.method(?+) # -> false!
\end{methodlist}

\subsubsection*{Приведение типов}

\begin{methodlist}
  \declare{.to_proc}{\# -> lambda}
  Создание лямбда-функции.
  \\\verb!12.method(?+).to_proc # -> #<Proc:0x88cdd60 (lambda)>!

  \declare{.to_s}{\# -> string}
  Возвращает информацию об объекте.
  \\\verb!12.method(?+).to_s # -> "#<Method: Fixnum#+>"!

  \declare{.unbind}{\# -> umethod}
  Удаление информации об объекте, для которого вызывается метод.
  \\\verb!12.method(?+).unbind -> #<UnboundMethod: Fixnum#+>!
\end{methodlist}

\subsubsection*{Вызов метода}

\begin{methodlist}
  \declare{.call(*arg)}{\# -> object}
  Вызов метода с переданными аргументами.
  \\\verb!12.method(?+).call 3 # -> 15!
\end{methodlist}

\subsubsection*{Остальное}

\begin{methodlist}
  \declare{.arity}{\# -> integer}
  Возвращает количество принимаемых аргументов. Для произвольного количества возвращается отрицательное число. Его инверсия с помощью оператора \verb!~! в результате возвращает количество обязательных аргументов. Для методов, определенных без помощи Ruby возвращается -1.
  \\\verb!12.method(?+).arity # -> 1!

  \declare{.name}{\# -> symbol}
  Возвращает идентификатор метода.
  \\\verb!12.method(?+).name # -> :+!

  \declare{.owner}{\# -> module}
  Возвращает модуль, в котором объявлен метод.
  \\\verb!12.method(?+).owner # -> Fixnum!

  \declare{.parameters}{\# -> array}
  Возвращает массив параметров метода.
  \\\verb!12.method(?+).parameters # -> [ [:req] ]!

  \declare{.receiver}{\# -> object}
  Возвращает объект, для которого метод вызывается.
  \\\verb!12.method(?+).receiver # -> 12!

  \declare{.source_location}{\# -> array}
  Возвращает местоположение объявления метода в виде массива \verb![ filename, line ]!. Для методов, определенных без помощи Ruby, возвращается nil.  
  \\\verb!12.method(?+).source_location # -> nil!

  \declare{.hash}{\# -> integer}
  Возвращает цифровой код объекта.
  \\\verb!12.method(?+).hash # -> -347045594!
\end{methodlist}

\subsection{UnboundMethod}

Экземпляры класса сохраняют информацию только о методе.

\begin{methodlist}
  \declare{module.instance_method(name)}{\# -> umethod} 
  Создание объекта для метода с переданным идентификатором. Если метод для объекта не определен, то вызывается ошибка. 
  \\\verb!Math.instance_method :sqrt # -> #<UnboundMethod: Math#sqrt>!
 
  \declare{module.public_instance_method(name)}{\# -> umethod} 
  Создание объекта для метода с переданным идентификатором. Если метод для объекта не определен, то вызывается ошибка.
  \\\verb!Math.public_instance_method :sqrt # -> error!
\end{methodlist}

\subsubsection*{Операторы}

\begin{methodlist}
  \declare{umethod == umethod2}{}
  \alias{eql?}
  Проверка на равенство. Объекты равны, если содержат информацию об одном и том же методе.
  \\\verb!Math.instance_method(:sin) == Math.instance_method(:sin) # -> true!
\end{methodlist}

\subsubsection*{Приведение типов}

\begin{methodlist}
  \declare{.to_s}{\# -> string}
  \alias{inspect}
  Возвращает информацию об объекте.
  \\\verb!Math.instance_method(:sqrt).to_s # -> "#<UnboundMethod: Math#sqrt>"!

  \declare{.bind(object)}{\# -> method}
  Добавление информации об объекте, для которого метод вызывается. Если такая информация уже существовала, то объекты должны принадлежать к одному классу.
  \begin{verbatim}
  12.method(?+).unbind.bind 1 # -> #<Method: Fixnum#+>
  12.method(?+).unbind.bind 1.0 # -> error
  \end{verbatim}  
\end{methodlist}

\subsubsection*{Остальное}

\begin{methodlist}
  \declare{.arity}{\# -> integer}
  Возвращает количество принимаемых аргументов. Для произвольного количества возвращается отрицательное число. Его инверсия с помощью оператора \verb!~! в результате возвращает количество обязательных аргументов. Для методов, определенных без помощи Ruby возвращается -1.
  \\\verb!Math.instance_method(:sqrt).arity # -> 1!

  \declare{.name}{\# -> symbol}
  Возвращает идентификатор метода.
  \\\verb!Math.instance_method(:sqrt).name # -> :sqrt!

  \declare{.owner}{\# -> module}
  Возвращает модуль, в котором объявлен метод.
  \\\verb!Math.instance_method(:sqrt).owner # -> Math!

  \declare{.parameters}{\# -> array}
  Возвращает массив параметров метода.
  \\\verb!Math.instance_method(:sqrt).parameters # -> [ [:req] ]!

  \declare{.source_location}{\# -> array}
  Возвращает местоположение объявления метода в виде массива \verb![ filename, line ]!. Для методов, определенных без помощи Ruby, возвращается nil.  
  \\\verb!Math.instance_method(:sqrt).source_location # -> nil!

  \declare{.hash}{\# -> integer}
  Возвращает цифровой код объекта.
  \\\verb!Math.instance_method(:sqrt).hash # -> 563385534!
\end{methodlist}

\section{Сопрограммы}

Сопрограмма - это фрагмент кода, поддерживающий несколько входных точек и остановку или продолжение выполнения с сохранением состояния выполнения. 

Для работы с сопрограммами используется класс Fiber.

Для управления сопрограммами создаются контрольные точки с помощью метода \method{::yield} и осуществляется последовательный переход между ними с помощью метода \method{.resume}.

\begin{methodlist}
  \declare{::new \{ |*params| \}}{\# -> fiber}
  Создание объекта. Блок при этом не выполняется. 

  \declare{::yield(*temp_result)}{\# -> object}
  Создание контрольной точки. Переданные аргументы возвращаются в результате вызова \method{.resume}.

  В результате возвращаются объекты, переданные при вызове метода \method{.resume} или полученные в результате выполнения последнего выражения в теле сопрограммы.
 
  \declare{.resume(*args)}{\# -> temp_result}
  Выполнение блока до следующей контрольной точки.

  Если метод был вызван впервые, то переданные аргументы отправляются в сопрограмму. В другом случае они возвращаются в результате вызова метода \method{::yield} в теле блока. 

  Если сопрограмма уже выполнена, то вызывается ошибка \error{FiberError}.
\end{methodlist}

Сопрограммы также могут использоваться для реализации многопоточности на уровне программы (в действительности код выполняется в единственном потоке выполнения). Такие потоки также называют "green thread". Использование сопрограмм позволяет уменьшить накладные расходы на переключение и обмен данными, так ка не требует взаимодействия с ядром ОС.

Проблема при использовании сопрограмм в том, что выполнение системного вызова будет блокировать процесс выполнения программы. Сопрограммы должны использовать специальные методы ввода/вывода, не блокирующие процесс выполнения. Также стоит заметить что управление переключением сопрограмм выполняется вручную и требует дополнительных затрат при разработке.