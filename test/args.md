# Обработка аргументов

Аргументы, переданные при запуске программы, сохраняются в массиве ARGV.

## Файлы

Программы, работающие с файлами, могут принимать как по одному файлу, так и сразу несколько. Для работы с одним файлом используется массив ARGV, а для работы с несколькими файлами - поток ARGF.

### ARGV

Для чтения файла используются частные методы экземпляров из модуля Kernel.

`.gets( sep = $/, bytesize = nil ) # -> string`

  Чтение следующей строки из файла, найденного в ARGV (размер строки может быть ограничен). Переданный разделитель обрабатывается в качестве символа перевода строки (если передается пустой текст, то обрабатывается "\n\n"). Если достигнут конец файла, то возвращается nil (если в массиве ARGV больше нет файлов).

  Полученная в результате строка связывается с глобальной переменной $_.

`.readline( sep = $/, bytesize = nil ) # -> string`

  Метод, аналогичный предыдущему. В конце файла вызывается ошибка.

### ARGF

**Добавленные модули: Enumerable**

ARGF ($<) - это поток, открываемый для файлов, содержащихся в ARGV. При этом подразумевается, что ARGV содержит только пути к файлам.

Файлы обрабатываются в том порядке, в котором они содержатся в ARGV. После обработки путь к файлу удаляется автоматически.

Файлы обрабатываются последовательно в качестве одного виртуального файла. Концом файла считается конец всех объединяемых файлов, а не конец отдельных элементов.

Если ARGV ссылается на пустой массив, то ARGF ссылается на стандартный поток для ввода данных в программу (стандартный поток для чтения).

#### Управление потоком

`::binmode # -> self`

  Переключение в двоичный режим. Возврат в текстовый режим после этого невозможен. Преобразование кодировок и символа перевода строки отменяется, а содержимое потока обрабатывается в ASCII кодировке.

`::close # -> self`

  Завершение обработки текущего файла и переход к следующему. Если все файлы уже обработаны, то вызывается ошибка \error{IOError}.

`::skip # -> self`

  Пропуск обработки текущего файла и переход к следующему. При отсутствии файлов ничего не выполняется.

`::argv # -> ARGV`

`::binmode?`

  Проверяет используется ли двоичный режим.

`::closed?`

  Проверяет завершена ли обработка текущего файла.

`::eof?`

  \alias{eof}

  Проверяет достигнут ли конец текущего файла.

`::filename # -> path`

  \alias{path}

  Возвращает относительный путь к обрабатываемому файлу. При взаимодействии с стандартным потоком для ввода возвращается `"-"`. Аналогично использованию $FILENAME.

#### Кодировка

`::external_encoding # -> encoding`

  Возвращает внешнюю кодировку.

`::internal_encoding # -> encoding`

  Возвращает внутреннюю кодировку если она указана. В другом случае возвращает nil.

`::set_encoding( *encoding, options = nil ) # -> self`

  Объявление внешней и внутренней кодировок (объекты или текст). Дополнительный аргумент используется при [преобразовании данных](appencode).

#### Приведение типов

`::to_io # -> io`

  \alias{file}

  Возвращает файл или поток для обрабатываемого файла (или стандартного потока для ввода).

`::to_i # -> integer`

  \alias{fileno}

  Возвращает дескриптор обрабатываемого файла. Отсутствие файлов считается ошибкой \error{ArgumentError}.

`::to_s # -> "ARGF"`

`::to_a( sep = $/, size = nil ) # -> array`

  \alias{readlines}

  Чтение строк и сохранение их в индексном массиве (размер массива может быть ограничен). Переданный разделитель обрабатывается в качестве символа перевода строки (если передается пустой текст, то обрабатывается "\n\n").

`::to_write_io # -> io`

  Интерпретатор возвращает поток, доступный для записи (только если используется режим редактирования файлов - ключ `-i`).

#### Чтение данных

###### Фрагмент:

`::read( bytesize = nil, buffer = nil ) # -> buffer`

  Чтение данных из потока (по умолчанию полностью). Если размер фрагмента ограничен, то чтение выполняется в двоичном режиме. Дополнительный аргумент служит для хранения полученных данных.

+ Если передается ноль, то возвращается пустой текст;
+ Если в начале чтения достигнут конца файла, то возвращается nil (если размер фрагмента ограничен). В другом случае возвращается пустой текст.

`::read_nonblock( bytesize, buffer = nil ) # -> buffer`

  Чтение данных, не блокирующее поток выполнения. В этом случае при ошибке чтения, она будет вызвана немедленно. Используется для реализации многопоточности на основе потоков выполнения или сопрограмм.

`::readpartial( bytesize, buffer = nil ) # -> buffer`

  Чтение данных, блокирующее поток выполнения:

+ если буфер пуст;
+ если поток пуст;
+ если поток не достиг конца файла.

После блокировки ожидается получение данных или достижения конца файла. Полученные данные возвращаются, а достижение конца файла считается ошибкой \error{EOFError}.

Процесс выполнения не блокируется, если поток содержит данные - в этом случае данные возвращаются.

Используется для чтения данных из каналов, сокетов и терминалов.

###### Строки:

`::gets( sep = $/, bytesize = nil ) # -> string`

  Чтение следующей строки из потока (размер строки может быть ограничен). Переданный разделитель обрабатывается в качестве символа перевода строки (если передается пустой текст, то обрабатывается "\n\n"). Когда достигается конец файла, возвращается nil.

  Полученная в результате строка связывается с глобальной переменной $_.

`::readline( sep = $/, bytesize = nil ) # -> string`

  Метод, аналогичный предыдущему. В конце файла вызывается ошибка.

`::lineno # -> integer`

  Возвращает позицию (порядковый номер) извлекаемой строки. Вызов метода аналогичен вызову глобальной переменной `$.`

`::lineno=(pos) # -> integer`

  Объявление позиции (порядкового номера) извлекаемой строки. Позиция обновляется при последующем чтении данных из потока.

`::seek( offset, object = IO::SEEK_SET ) # -> 0`

  Объявление позиции (порядкового номера) извлекаемой строки относительно текущего положения и переданного смещения.

  Константы:

+ _IO::SEEK_CUR_ -> новая_позиция = текущая_позиция + offset  
  _IO::SEEK_END_ -> новая_позиция = конец_файла + offset  
  _IO::SEEK_SET_ -> новая_позиция = offset

`::rewind # -> 0`

  Сброс позиции (порядковый номер) извлекаемой строки.

###### Символы:

`::getc # -> string`

  Чтение следующего символа из потока. Когда достигается конец файла, возвращается nil.

`::readchar # -> string`

  Версия метода вызывающая ошибку при достижении конца файла.

###### Байты:

`::getbyte # -> integer`

  Чтение следующего байта из потока. Когда достигается конец файла, возвращается nil.

`::readbyte # -> integer`

  Метод, аналогичный предыдущему. Достижение конца файла считается ошибкой.

`::pos # -> integer`

  \alias{tell}

  Возвращает позицию (порядковый номер) извлекаемого байта.

`::pos=(pos) # -> integer`

  Объявление позиции (порядкового номера) извлекаемого байта. Позиция обновляется при последующем чтении данных из потока.

###### Итераторы:

`::each( sep = $/ ) { |string| } # -> self`

  `(size) { |string| } # -> self`

  `( sep, size) { |string| } # -> self`

  \alias{each_line, lines}

  Последовательный перебор строк для каждого файла в потоке. Количество строк может быть ограничено. Переданный разделитель обрабатывается в качестве символа перевода строки.

`::bytes { |byte| } # -> self`

  \alias{each_byte}

  Последовательный перебор байт для каждого файла в потоке.

`::chars { |char| } # -> self`

  \alias{each_char}

  Последовательный перебор символов для каждого файла в потоке.

#### Запись данных

Запись данных с помощью ARGF возможна только при запуске программы с ключом `-i`.

`::inplace_mode # -> string`

  Возвращает расширение, используемое для создания резервных копий изменяемых файлов.

`::inplace_mode=(ext) # -> self`

  Изменяет расширение, используемое для создания резервных копий изменяемых файлов.

`::write(object) # -> object.to_s.bytesize`

  Запись `object.to_s` в обрабатываемый файл.

`::print( *object = $_ ) # -> nil`

  Запись `object.to_s` в обрабатываемый файл для всех переданных аргументов.

+ Если глобальная переменная `$,`, отвечающая за разделение элементов, не ссылается на nil, то она будет использоваться для разделения аргументов.
+ Если глобальная переменная `$\`, отвечающая за разделение данных, не ссылается на nil, то она будет использована после записи всех объектов.

`::printf( format, *object = nil ) # -> nil`

  Запись отформатированных объектов в обрабатываемый файл:  
  `string % [*object]`.

`::putc(object) # -> object`

  Запись `object.to_s` в обрабатываемый файл. Переданное число считается кодовой позицией.

`::puts( *object = $\ ) # -> nil`

  Запись `object.to_s` в обрабатываемый файл. Аргументы разделяются с помощью перевода строки. Из индексного массива извлекаются все элементы.