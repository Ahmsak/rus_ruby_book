\chapter{Начальные сведения}

\section{Краткое описание языка}

\epigraph
{Во имя эффективности - причем достигается она далеко не всегда - совершается больше компьютерных грехов, чем по любой другой причине, включая банальную глупость.}
{W. A. Wulf}

Язык программирования - это искусственно созданный язык, облегчающий управление компьютером. Текст, написанный с помощью языка программирования называется кодом.

Язык программирования Ruby начал разрабатываться 24 февраля 1993 года и вышел в свет в 1995. Создатель языка - Юкихиро Мацумото (Matz).
\begin{note}
  Я хотел получить скриптовый язык, который был бы мощнее чем Perl, и объектно-ориентированнее чем Python. Вот почему я решил разработать свой язык.
\end{note}

В противовес машинно-ориентированным языкам, работающим быстрее, целью Мацумото был язык, наиболее близкий к человеку. Основной целью Ruby он считает предоставление возможности программистам наслаждаться их работой.
\begin{note}
  Зачастую люди, в особенности компьютерные инженеры, фокусируют внимание на машинах. Они думают: "Сделаю это и машина будет работать быстрее. Сделаю то и машина будет работать эффективнее. Сделаю третье и машина будет пятое и десятое. Они помешаны на машинах. В действительности, необходимо больше думать о людях. О том чтобы людям было удобно создавать программы и пользоваться приложениями. Мы мастера. Они рабы.
\end{note}

Ruby позволяет создавать программы тем способом, который удобнее всего. Это подразумевает наличие нескольких путей выполнить одно и тоже действие, ведь и люди, хоть и схожие в целом имеют множество мелких различий. В том числе возможно применение нескольких парадигм программирования: процедурного, объектно-ориентированного и функционального.

Ruby освобождает пользователей от рутинной работы, которую компьютер может выполнять быстрее и качественнее. Особое внимание, в частности, уделялось будничным рутинным занятиям  (обработка текстов, администрирование), и для них язык подходит особенно хорошо. Гибкий и мощный синтаксис позволяет создавать программы, использующие термины предметной области (DSL).

\begin{note}
  Когда распространение языка только начиналось, очень часто его упрекали за низкую скорость. В последних версиях скорость выполнения была значительно увеличена. Обычно говорят, что Ruby достаточно быстр - скорость выполнения компенсируется скоростью разработки. Медленный код при этом принято переписывать на Си. Си API - одна из самых полезных и удобных особенностей языка.
\end{note}

Особенности Ruby:
\begin{itemize}
  \item высокоуровневый;
  \item интерпретируемый;
  \item объектно-ориентированный;
  \item динамическая неявная типизация.
\end{itemize}

Каждый пункт подробно описан в первой части этой книги.

Интерпретатор - это программа, переводящая код в машинные команды, понятные компьютеру.

\begin{keylist}{Интерпретаторы:}  
  \firstkey{MRI} - официальный интерпретатор, написанный на языке программирования Си с использованием виртуальной машины YARV (преимущество виртуальных машин в том, что код сначала интерпретируется полностью, и только затем выполняется).

  В этой книге описываются особенности работы именно этого интерпретатора;
  
  \key{Rubinius} - сторонняя реализация виртуальной машины. Написана как с помощью языка программирования C++, так и самого Ruby;
  
  \key{JRuby} - реализация языка для взаимодействия с виртуальной машиной Java;
  
  \key{IronRuby} - реализация языка для взаимодействия с платформой .Net.
\end{keylist}

Официальный \href{http://www.ruby-lang.org}{\underline{сайт}} языка. На нем можно узнать последние новости разработки интерпретатора, скачать исходный код и перейти к документации.

На этом \href{http://rubyinstaller.org}{\underline{сайте}} пользователи ОС Windows могут скачать установочный файл для своей операционной системы. 

В состав интерпретатора входят:
\begin{itemize}
  \item стандартная библиотека (наиболее часто используемые модули); 
  \item менеджер пакетов RubyGems; 
  \item интерактивный терминал irb (выполняет код на Ruby в режиме реального времени); 
  \item генератор документации RDoc; 
  \item программа ri для просмотра документации; 
  \item менеджер задач Rake; 
  \item шаблонизатор ERb.
\end{itemize} 

\section{Краткое описание кода}

Программа на Ruby - это код, сохраненный в текстовом файле с определенным расширением. Расширение - это группа символов, следующая за именем файла (после точки). Оно помогает компьютеру определить язык, на котором написана программа.

Для языка Ruby используются два расширения: \mono{.rb} (стандартное расширение) и \mono{.rbw} (используется в Windows для программ с графическим интерфейсом).

Любой интерпретатор понимает лишь код, написанный по заранее определенным правилам. Последовательность символов, имеющая смысл для интерпретатора называется лексемой. Лексические правила регулируют определение существующих лексем в коде. Встретив в тексте набор символов, не относящийся к известным лексемам, интерпретатор завершит обработку кода и вернет сообщение об ошибке.

\itemtitle{Типы лексем:}
\begin{itemize}
  \item элементарные типы данных - простейшие данные (числа, буквы, логические величины);

  \item идентификаторы - лексемы, использующиеся в двух случаях: для сохранения результатов выполнения выражения и для пометки различных синтаксических структур. И то и другое необходимо для повторного применения кода или данных. Лексема идентификатора - это группа символов состоящая из букв, цифр и знаков подчеркивания (\mono{_}). При этом идентификатор не может начинаться с цифры.

  Идентификаторы чувствительны к регистру. Интерпретатор по разному распознает строчные и прописные ASCII символы (принято использовать для идентификаторов именно ASCII символы, хотя в некоторых случаях это необязательное требование). Два идентификатора считаются идентичными только в том случае, если они состоят из одинакового набора байт;

  \item операторы - это знаки препинания, использующиеся в качестве разделителей и математичсекие символы, позволяющие выполнять различные вычисления;

  \item инструкции - слова, зарезервированные языком программирования. Их переопределение невозможно, а использование приведет к заранее определенному результату. Инструкции используется для создания различных синтаксических структур или для управления процессом выполнения программы.

  Список инструкций: __LINE__~; __ENCODING__~; __FILE__~; __END__~; BEGIN; END; =begin; =end; alias; and; begin; break; case; class; def; defined?; do; else; elsif; end; ensure; false; for; if; in; module; next; nil; not; or; redo; rescue; retry; return; self; super; then; true; undef; unless; until; when; while; yield;

  \item комментарии - текст на естественном языке, поясняющий процесс выполнения программы.
\end{itemize}

Из лексем создаются выражения, а из выражений - сложные выражения и предложения. Любая синтаксическая конструкция относится к выражениям. Вся программа может рассматриваться как последовательный набор выражений.

Выражение - это синтаксическая единица, возвращающая результат после выполнения. Простые выражения могут быть объединены в сложные, с помощью операторов, или даже в целые предложения, с помощью инструкций. Синтаксические правила регулируют использование выражений в коде. Нарушение синтаксических правил также приводит к завершению обработки кода интерпретатором. Синтаксис языка также содержит описание доступных видов выражений и предложений.

\begin{note}
  Кроме жестких правил существуют также соглашения, принятые в сообществе. Они необязательны, но крайне желательны к выполнению. Следования правилам позволяет понимать ваш код компьютеру, а следование соглашениям облегчает его понимание для людей.
\end{note}

\subsection{Синтаксис выражений}

Для упрощения разработки в Ruby присутствует множество синтаксического сахара. Синтаксический сахар - общее название дополнений (дополнительные выражения) к синтаксису языка, которые делают его использование более удобным, но не добавляют новых возможностей.

Минимальный набор синтаксических правил и соглашений описывает общие особенности употребления выражений в коде.

\itemtitle{Соглашения:}
\begin{itemize}
  \item Код принято разбивать на строки. Каждая строка обычно не превышает 80 символов (это облегчает чтение кода);

  \item На строках обычно располагаются отдельные выражения (простые или сложные). Выражение обычно составляют таким образом, чтобы результат его выполнения мог быть использован несколько раз.

  \item Вложенность выражений принято оформлять двумя пробелами.
\end{itemize}

\itemtitle{Синтаксические правила:}
\begin{itemize}
  \item Для разделения отдельных выражений используется символ перевода строки (невдимый символ, добавляемый текстовым редактором автоматически, при нажатии клавиши \mono{ENTER});

  \item Для разделения выражений на одной строке используется точка с запятой (\mono{;});

  \item Если выражение не помещается на строке, то каждую строку, содержащую фрагмент выражения, заканчивают символом обратной косой черты (backslash - \mono{\textbackslash}), отделяя его пробелом. (Таким образом он находится прямо перед символом перевода строки и экранирует его). Всякий раз, когда необходимо визуально разбить выражение на несколько строк, а вы не уверены в правильности его обработки - используйте обратную косую черту;

  \item Строки, начинающиеся с точки (\mono{.}), также считаются продолжением предыдущего выражения;

  \item Пробельные символы (пробел, отступ, перевод строки), не разделяющие выражения, игнорируются интерпретатором и могут использоваться для оформления кода. Однако стоит сохранять осторожность - в некоторых случаях они влияют на процесс выполнения программы.
\end{itemize}

\subsection{Комментарии}

Комментарии - это фрагменты текста на естественном языке, поясняющие задачу, которую решает код. 

Хорошие комментарии не повторяют и не объясняют код, а только цель, которую пытался достигнуть автор. Комментарии должны использовать более высокий уровень абстракции (ближайший к человеческому мышлению) чем код.

Обычно комментарий считается хорошим, если при перепроектировании кода необязательно изменять комментарий.

Хоть наличие комментариев и облегчает понимание кода, главный вклад все же вносится хорошим стилем программирования и следованием соглашениям. Никакой комментарий не спасет плохо написанной программы.

Следует помнить, что кроме пользы комментарии также приносят и вред - нарушают визуальное офрмление кода.

Комментарии не обрабатываются интерпретатором и не влияют на процесс выполнения программы.

В Ruby существует два способа создания комментариев:
\begin{itemize}
  \item Любой текст, начинающийся символом решетки и заканчивающийся переводом строки, считается комментарием.
  \begin{verbatim}
  # Это комментарий.
  # Это тоже комментарий.\
  \end{verbatim}

  \item Любой текст между инструкциями \verb!=begin! и \verb!=end! на отдельных строках считается комментарием. Текст комментария начинается после первого пробельного символа.
  \begin{verbatim}
  =begin Это тоже комментарий.
    В нем можно записывать все что угодно.
    Обычно его называют встроенной документацией,
    а на первой строке записывают название программы
    для ее обработки.
  =end\
  \end{verbatim}
\end{itemize}

\subsection{Кодировка символов}

Текст, который сохраняется в файле, для компьютера существует не в виде символов, а только как двоичные данные - числа из нулей и единиц. Каждый ноль или единица занимают один бит памяти. Восемь нулей или единиц занимают один байт. Обычно удобно записывать байты используя шестнадцатеричную систему счисления. Так ff в шестнадцатеричной системе соотвествует 255 в десятичной и 11111111 в двоичной.

Каждому символу соотвествует определенное число, сохраняемое в памяти компьютера. Это число также называется кодовой позицией (code point) символа. Таблица, в которой соотносятся кодовые позиции и символы называется кодовой таблицей.

Кодировка - это способ представления символов в памяти компьютера (в виде набора байт). Например пробел хранится как 10000 (32 в десятичной системе счисления, 20 в шестнадцатеричной). Без информации об используемой кодировке компьютер не сможет правильно отобразить сохраненный набор байт. Обычно понятия кодировки и кодовой таблицы взаимозаменяемы.

В начале появления компьютеров повсевместно использовалась кодировка ASCII, включающая кодовые позиции для 127 символов: цифр, знаков, букв латинского алфавита и спецсимволов. Для предоставления 127 различных кодовых позиций хватает 7 бит памяти, поэтому кодовая позиция в ASCII полностью аналогична байту, хранящемуся в памяти.

\itemtitle{Свойства ASCII:}
\begin{itemize}
  \item Кодовая позиция цифр (от 0 до 9) соотвествует их двоичному значению, перед которым стоит 00112;

  \item Кодовые позиции букв (от A до Z) верхнего и нижнего регистров различаются только одним битом, что упрощает преобразование регистра и проверку на диапазон. Кодовые позиции соотвествуют порядковым номерам букв в алфавите, записанным в двоичной системе счисления, перед которыми стоит 1002 (для букв верхнего регистра) или 1102 (для букв нижнего регистра).
\end{itemize}

В качестве минимальной единицы памяти обычно используется один байт. В одном байте может быть сохранено 255 различных кодовых позиций. Оставшиеся 128 чисел (от 128 до 255) использовались для представления национальных символов: букв национальных алфавитов и специфичных знаков.

Например слово hello хранится в памяти в виде набора байт 48 65 6c 6с 6a. Каждый байт одновременно является кодовой позицией символа.

Обилие национальностей и ограниченный набор различных вариаций битов привели к образованию огромного количества кодировок. Каждая кодировка по разному использовала оставшиеся кодовые позиции, представляя с их помощью разные символы. Это создавало сразу две проблемы: преобразования кодировок и ограниченности набора символов.

Для решения проблемы кодировок был создан стандарт Юникод (Unicode). Юникод был попыткой создать единый набор символов, который будет содержать в себе все символы всех языков на планете. В стандарте определены кодовые позиции символов, но не способ их хранения. Правила, согласно которым кодовые позиции преобразуются в байты (машинное представление), определяются Юникод-кодировками.

Кодовая позиция символа в Юникод записывается в формате U+xxxx, где x - это цифры в шестнадцатеричной системе счисления (может использоваться больше четырех цифр). Количество возможных кодовых позиций превышает миллион, что позволяет стандартизировать большинство существующих алфавитов. На данный момент стандарт содержит кодовые позиции около 100 тыс. символов.

Например, слово hello состоит из пяти кодовых позиций: U+0048 U+0065 U+006C U+006C U+006F.

Разные Юникод-кодировки довольно сильно отличаются. Слово hello может быть закодировано как в виде набора байт 00 48 00 65 00 6С 00 6С 00 6А, так и виде 48 00 65 00 6С 00 6С 00 6А 00. Существуют также кодировки, хранящие каждую кодовую позицию в четырех байтах.

В последнее время чаще всего используется Юникод-кодировка UTF-8. Она совместима с ASCII - для кодирования каждого символа, содержащегося в ASCII используется один байт (слово hello в UTF-8 кодируется так же как и в ASCII). Остальные символы кодируются двумя и более байтами. Это позволяет не хранить в памяти байты, содержащие только нули, и правильно обрабатывать ASCII символы.

Приступая к выполнению программы, интепретатор получает лишь набор байт. В зависимости от внутренней кодировки эти байты могут интерпретироваться по разному. По умолчанию интерпретатор считает, что внутри программы используется кодировка ASCII. Все лексические правила также определены относительно символов, содержащихся в ASCII. 

Если в коде или комментариях (ведь это тоже одна из лексем) используются символы, не входящие в ASCII (например кириллица), необходимо вручную задавать кодировку программы. 

Если текстовый редактор сохраняет код в кодировке, отличной от ASCII, то она также должна быть явно указана в качестве кодировки программы.

Кодировка устанавливается с помощью специального комментария, расположенного в самом начале программы: \verb!#coding: название_кодировки!

Существует несколько отдельных лексических правил для такого комментария:
\begin{itemize}
  \item Вместо coding также может быть использовано encoding;
  \item Вместо двоеточия также может использоваться знак равенства;
  \item Пробелы до и после двоеточия игнорируются;
  \item Весь комментарий не чувствителен к регистру;
  \item Перед coding также может использоваться набор символов -*-.
\end{itemize}

\section[Краткое описание ООП]{Объектно-ориентированная парадигма}

Объектно-ориентированная парадигма (ООП) - это парадигма программирования, в которой основными концепциями являются понятия объектов и классов. Большинство основных положений ООП было развито в языке программирования Smalltalk, сильно повлиявшем на Ruby. В настоящее время количество прикладных языков программирования, реализующих ООП, преобладает.

ООП - это не только набор конкретных методик, а также еще и философия проектирования приложений. Как и любая сложная парадигма, ООП состоит из нескольких уровней понимания. Следует заметить, что применение объектно-ориентированного языка Ruby не означает, что код автоматически становится объектно-ориентированным - требуется явная реализация и использование объектно-ориентированных концепций.

Основные понятия ООП - это абстракция, класс, объект, инкапсуляция, наследование и полиморфизм.

\paragraph*{Абстракция:}

Абстрагирование - это способ выделить существенные свойства и игнорировать несущественные. Соответсвенно, абстракция - это набор выделенных существенных свойств.

Существенные свойства - это свойства, которыми сущность должна обладать, чтобы быть именно этой сущностью. Несущественные свойства - свойства, обладание которыми необязательно.

С точки зрения сложности, главное достоинство абстракции в том, что она позволяет игнорировать несущественные детали (не имеющие значения для программы). Абстракция - это один из главных способов борьбы со сложностью реального мира.

\paragraph*{Класс:}

Класс - это абстрактная модель (абстрактный тип данных), еще не существующей сущности. Фактически класс является образцом для создания новых объектов (формулой или руководством по эксплуатации). Обычно классы относятся к статичным сущностям, существующим в коде и неизменным в процессе выполнения.

В отличии от объектов, классы обычно не содержат данных. Передача данных классу позволяет создавать объекты, описанного в классе типа (в ООП понятия тип данных и класс - синонимы).

Объект, созданный по образцу класса называют экземпляром этого класса. Основное предназначение классов - определять поведение своих экземпляров. Обычно классы создают таким образом, чтобы они описывали объекты предметной области (объекты реального мира).

\paragraph*{Объект:}

В основе ООП находится понятие объекта. Объект - это абстракция над содержимым памяти компьютера, появляющимся в результате создания экземпляра класса. Обычно объекты относятся к динамичным сущностям, создаваемым и изменяемым в процессе выполнения программы.

Объекты обладают состоянием и поведением. Состояние объекта зависит от значения его параметров (хранимых объектом данных). Поведение объекта зависит от набора доступных ему методов.

В Ruby любые данные (в том числе классы и элементарные типы данных) относятся к объектам. Сама программа представляет собой набор взаимодействующих объектов. Взаимодействие объектов обеспечивается вызовом ими методов друг друга. Это позволяет создавать модульные, разделяемые программы, облегчая их модификацию и позволяя работать с отдельными фрагментами по очереди.

\paragraph*{Инкапсуляция:}

Инкапсуляция - это свойство сущности объединять в себе данные и методы для работы с этими данными. Данные при этом скрыты от остальной программы, а методы доступны для взаимодействия объектов. Объект не считается отдельной сущностью, если его состояние может быть изменено без явного использования ссылки на объект.
\begin{itemize}
  \item Инкапсуляция поволяет распараллелить процессы создания программы, ускоряя разработку ПО;

  \item Инкапсуляция снижает сложность разработки, позволяя сосредоточиться на небольших фрагментах программы;

  \item Инкапсуляция помогает сокрытию деталей реализации, необходимых программе, но выходящих за рамки абстракции. Инкапсуляция помогает управлять сложностью, скрывая доступ к ней.
\end{itemize}

Инкапсуляция порождает понятие модуля. Модуль - это сущность, использующаяся для инкапсуляции. Любой класс может рассматриваться как модуль. Однако модули, в отличии от классов, не предназначены для создания объектов.

\paragraph*{Наследование:}

Наследование - это свойство сущности использовать структуру другой сущности, заимствуя и расширяя уже имеющуюся функциональность (например классы расширяют возможности модулей). Класс, который заимствуется (наследуется) называется базовым или суперклассом, а класс, который заимствует (наследует) - производным или подклассом. Экземпляры производных классов расширяют поведение экземпляров базовых классов. Все базовые и производные классы в общем создают иерархию классов программы.
\begin{itemize}
  \item Наследование снижает время на разработку за счет повторного использования кода;

  \item Наследование снижает сложность, позволяя использовать уже известные фрагменты программы. Однако при сложной иерархии повышается объем кода, с которым работает программист в отдельный момент времени;

  \item Наследование дополняет абстракцию, выделяя сущности с незначительным уровнем различий. Наследование позволяет создавать абстракции с различным уровнем реализации (дополнительными группами существенных свойств).
\end{itemize}

\paragraph*{Полиморфизм:}
Полиморфизм - это свойство сущностей с одинаковой структурой (одним и тем же базовым типом), иметь различную реализацию.
\begin{itemize}
  \item Полиморфизм повышает скорость разработки, позволяя быстро подстраиваться под требования заказчика;

  \item Полиморфизм снижает сложность, позволяя скрывать внутреннюю структуру объектов;

  \item Полиморфизм поддерживает возможность отдельной реализации базовых методов для производных классов.
\end{itemize}

\begin{note}
  Хоть ООП и является достаточно удобной парадигмой, не стоит забывать, что она далеко не единственная. В некоторых случаях применение объектного подхода не оправданно и снижает производительность и удобство создания программ. В любом случае необдуманное и чрезмерное применение концепций ООП усложняет и замедляет выполнение кода, превращая его в бесполезный, малопонятный набор выражений.
\end{note}

\paragraph*{Типизация данных:} строгая динамическая типизация.

При строгой типизации совместимость и границы использования типа объекта контролируются интерпретатором и каждый объект имеет тип (использование объектов не подходящего типа приводит к вызову ошибки).

При динамической (полиморфной) типизации тип объекта вычисляется во время выполнения и может произвольно изменяться в процессе. Динамическая типизация облегчает реализацию полиморфизма.

При неявной (утиной) типизации (подвид динамической типизации) совместимость и границы использования объекта ограничены его текущим набором методов и свойств, в противоположность наследованию от определенного класса. 

Для того чтобы в Ruby узнать возможность использования того или иного объекта проверяется не его класс, а его реакция на вызов определенных методов в текущий момент. Если реакция объекта удовлетворяет условию, то его использование разрешается. При прочтении этой книги вы встретите множество условий, требующих определенной реакции объекта, на вызов того или иного метода.

\begin{note}
  "Если что-то выглядит как утка, плавает как утка и крякает как утка, то, вероятно, это утка".
\end{note}

\section{Запуск программы}

Запуск программ выполняется из терминала. Общий вид команды:

{\medskip\noindent\verb!ruby [keys] [path] [args]!}

\begin{description}
  \item[keys] - заранее определенные \hyperlink{appbin}{\underline{спецсимволы или идентификаторы}}, влияющие на выполнение программы.; 
  
  \item[path] - путь к запускаемой программе. Поиск программы выполняется относительно текущего каталога. 

  Если имя программы не указано, или передается одиночный дефис, то интерпретатор будет выполнять код, полученный из стандартного потока для чтения информации (обычно связанный с терминалом).
  
  \item[args] - произвольный набор символов, которые будут переданы программе как элементы индексного массива ARGV.
\end{description}

Файлы, доступные для выполнения (скрипты или исполняемые файлы), могут содержать информацию об интерпретаторе в первом комментарии (shebang) программы:

\mono{\#!/usr/bin/env ruby [keys] [args]}

В этом случае для запуска программы требуется только ввести в терминале путь к ней.

Кроме переданных ключей на выполнение программы также могут влиять \hyperlink{appbin}{\underline{переменные окружения и предопределенные глобальные переменные}}.

Переменные окружения - это переменные, установленные операционной системой. В Linux список установленных переменных может быть получен с помощью команды \mono{env}.