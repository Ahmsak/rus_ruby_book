# Тестирование и отладка

## Тестирование

> Если вы хотите улучшить программу, вы должны не тестировать больше, а программировать лучше.

### Основы

Любая, даже самая маленькая программа, не может гарантировать правильной работы. Тестирование программ и исправление обнаруженных ошибок - один из самых трудоемких этапов разработки. Он не заканчивается и после публикации приложения.

Тестирование - это средство обнаружения ошибок. Для поиска и устранения их причин выполняется отладка. Устранение дефектов - это дорогой и длительный процесс. Легче сразу создать высококачественную программу, чем создать низкокачественную и исправлять ее.

Тесты создаются для обнаружения ошибок, которые никогда не должны происходить, в отличии от обработки исключений, возникновение которых возможно и предусмотрено реализацией.

Обзор кода часто эффективнее, чем тестирование, но выполнение тестов позволяет проверить влияние изменений, внесенных в ходе разработки.

Существует множество подходов к тестированию приложения, но в основном грамотное тестирование - процесс прежде всего творческий.

В общем случае тестирование приложения разделяется на четыре уровня:

+ _Модульное тестирование_ - тестирование минимально возможного фрагмента кода (unit test);  
  _Интеграционное тестирование_ - тестирование взаимодействия между различными элементами приложения;  
  _Функциональное тестирование_ - тестирование задач, выполняемых с помощью приложения;  
  _Тестирование производительности_ - тестирование скорости выполнения программы и затрачиваемых на это ресурсов компьютера.

Обычно для облегчения тестирования код разделяют на работающий с проверенными и непроверенными данными.

При выполнении теста ему передаются как заведомо правильные, так и заведомо неправильные данные.

Для тестирования программы может быть использована команда `testrb` (исполняемый файл на Ruby, использующий стандартную библиотеку Test::Unit).

Программа принимает путь к файлу с тестами (или выполняет все тесты в каталоге) и выводит результатаы тестирования.

Для проверки выполнения небольших кусков кода может быть использован интерактивный терминал irb.

### TDD

Одна из популярных техник тестирования - разработка, управляемая тестами (TDD, Test-Drive Development). Использование этой техники разделено на следующие этапы:

+ Написание кода, тестирующего часть приложения;
+ Выполнение теста. Получение отрицательного результата (этот этап необходим для проверки корректности теста);
+ Написание кода приложения;
+ Выполнение теста. Получение положительного результата.

Создание тестов перед кодом фокусирует внимание на требованиях к программе (т.е. необходимо понимание для чего она создается).

Тестирование -> написание кода -> удовлетворение требований -> улучшение кода (рефакторинг).

## Отладка

### Состояние программы

Так как вся программа по сути является объектом, то интроспекция также позволяет узнать о состоянии выполнения программы.

`.global_variables # -> array [PRIVATE: Kernel]`

Идентификаторы глобальных переменных.

`.local_variables # -> array [PRIVATE: Kernel]`

Идентификаторы локальных переменных.

`::constants # -> array [Module]`

Идентификаторы всех констант в теле программы (в теле Object).

`::nesting # -> array [Module]`

Очередь вызовов метода.

`.__method__ # -> symbol [Kernel]`  
Синонимы: `__callee__`

Идентификатор текущего метода. Вне тела метода возвращается nil.

##### Переменные и константы

`RUBY_PATCHLEVEL` - версия интерпретатора;

`RUBY_PLATFORM` - название используемой системы;

`RUBY_RELEASE_DATE` - дата выпуска интерпретатора;

`RUBY_VERSION` - версия языка;

`$PROGRAM_NAME ($0)`  - имя выполняемой программы (по умолчанию - имя файла с расширением);

`__dir__` - путь к текущему каталогу (ruby 2.0).

Аналогично `File.dirname __FILE__`;

`__FILE__` - имя выполняемого файла;

`__LINE__` - номер выполняемой строки кода;

`__Encoding__` - кодировка программы.

*****

### Стек выполнения

`.caller( offset = 1 ) # -> array [Kernel]`

Состояние стека выполнения в виде массива, содержащего:  
`"файл:строка_кода"` или `"файл: строка_кода in метод"`.

Число игнорируемых строк кода может быть ограничено. Если оно больше, чем количество выполненных строк кода, то возвращается nil.

#### Ruby 2.0

Во второй версии добавлен новый способ получить доступ к состоянию стека выполнения программы.

`.caller_locations( start = 1, length = nil ) # -> array or nil [Ruby 2.0]`

`(range) # -> array or nil`

Фрагмент состояния стека выполнения программы в виде массива, содержащего экземпляры `Thread::Backtrace::Location`.

Если начальная позиции фрагмента превышает текущий размер стека, то возвращается nil.

~~~~~ ruby
  # Ruby 1.9:
  def whoze_there_using_caller
    caller[0][/`([^']*)'/, 1]
  end

  # Ruby 2.0:
  def whoze_there_using_locations
    caller_locations(1, 1)[0].label
  end
~~~~~

###### Thread::Backtrace::Location

`.absolute_path # -> string`

Полный путь к файлу.  
`caller_locations.last.absolute_path # -> "/usr/bin/irb"`

`.base_label # -> string`

Основная метка. Обычно соответсвует простой метке без дополнительного оформления.

`caller_locations.last.base_label # -> "main"`

`.inspect # -> string`  
Информация об объекте.

`caller_locations.last.inspect # -> "\"/usr/bin/irb:12:in '<main>'\""`

`.label # -> string`

Метка. Обычно содержит название метода, класса, модуля и т.д. с дополнительным оформлением.  
`caller_locations.last.label # -> "<main>"`

`.lineno # -> integer`

Номер строки кода.  
`caller_locations.last.lineno # -> 12`

`.path # -> string`

Имя файла.

~~~~~ ruby
  loc = caller_locations(0..1).first
  loc.path # -> 'caller_locations.rb'
~~~~

`.to_s # -> string`

Иноформация об объекте в стиле метода `Kernel.caller`.  
`caller_locations.last.to_s # -> "/usr/bin/irb:12:in '<main>'"`

### Трассировка

Трассировка программы может выполняться с помощью частных методов экземпляров из модуля Kernel.

`.set_trace_func( proc = nil )`

Используется для выполнения переданной подпрограммы при возникновении ряда событий. Трассировка в теле подпрограммы при этом не выполняется.

Подпрограмме передаются: идентификатор события, имя файла, номер строки кода, цифровой идентификатор объекта, экземпляр класса Binding и идентификатор класса объекта.

Передача nil отменяет трассировку.

Возможные события:
+ _"c-call"_ - вызов Си функции;  
  _"c-return"_ - завершение выполнения Си функции;  
  _"call"_ - вызов Ruby метода;  
  _"return"_ - завершение выполнения Ruby метода;  
  _"class"_ - начало определения класса или модуля;  
  _"end"_ - завершение определения класса или модуля;  
  _"line"_ - выполнение новой строки кода;  
  _"raise"_ - вызов ошибки.

`.trace_var( name, code ) # -> nil`

`(name) { |object| } -> nil`

Используется для выполнения кода при изменении глобальных переменных. В блок передается новое значение.

`.untrace_var( name, code = nil ) # -> array`

Используется для отмены трассировки глобальной переменной. Возвращается массив, содержащий выполняемый при трассировке код.