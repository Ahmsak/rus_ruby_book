\chapter{Реализация ООП}

Одна из главных особенностей Ruby - сильно выраженная поддержка объектно-ориентированного парадигмы при создании программ. Любые данные, в том числе и элементарные, относятся к объектам. Большинство операторов относится к методам. Множество синтаксического сахара облегчает использование основных концепций и сущностей ООП.
\itemtitle{Основные особенности:}
\begin{itemize}
  \item Любые данные хранятся в виде объектов;

  \item Вычисления выполняются путем взаимодействия (обмена данными) между объектами, при котором один из объектов требует выполнение некоторого действия от другого. Объекты взаимодействуют с помощью методов. Метод - это запрос на выполнение действия, дополненный набором аргументов, которые могут понадобиться при его выполнении;

  \item Каждый объект имеет независимую память, которая состоит из других объектов;

  \item Каждый объект является представителем класса, который определяет общие свойства объектов; 

  \item В классе также определяется поведение объекта - набор доступных методов. Все экземпляры класса могут выполнять одни и те же действия;

  \item Классы организованы в единую древовидную структуру с общим корнем, называемую иерархией наследования. Память и поведение экземпляров базового класса автоматически доступны в производном классе.
\end{itemize}

\section{Основные сущности}

\subsection{Модули}

Модули - это абстрактные сущности, использующиеся для инкапсуляции. Они могут применяться как для инкапсуляции программы или ее фрагментов (пространства имен), так и для инкапсуляции логически связанных фрагментов кода (обычно для объединения логически связанных методов или констант).
\begin{note}
  В качестве пространств имен модули обычно используются для инкапсуляции области видимости программы. При этом все классы или модули программы объявляются только в теле одного отдельного модуля. Это позволяет разным программам не засорять глобальную область видимости. Использование глобальной области видимости программой считается плохим тоном среди программистов, т.к. требует согласования использованных имен классов и модулей и может привести к непредсказуемым последсвиям.

  Явно выраженный пример инкапсуляции логически связанных фрагментов кода представляет модуль Math, объединяющий математические функции.
\end{note}

С точки зрения синтаксиса модуль - это фрагмент кода, связанный с константой. В отличии от классов модули не могут иметь экземпляров или подклассов, поэтому любой класс может считаться модулем, но не любой модуль - считаться классом. Кроме этого любой модуль может использоваться также как класс. Все модули относятся к экземплярам класса Module.

Создание модуля называется объявлением, а заполнение области видимости модуля - определением.
\begin{verbatim}
  module идентификатор_модуля
    тело_модуля
  end
\end{verbatim}
\begin{itemize}
  \item Инструкция module ожидает получения константы, сообщая интерпретатору область памяти в которую необходимо выполнить запись информации. Если соотвествующей области не существует, то автоматически объявляется новый модуль. В другом случае будет изменен уже существующий модуль;

  \item Идентификатор модуля должен начинаться с прописной буквы. Каждое отдельное слово также начинается с прописной буквы. Такой подход называют ВерблюжьейНотацией;

  \item В теле модуля создается отдельная область видимости. В ней могут создаваться любые другие сущности. Внутри тела модуля псевдопеременная self ссылается на модуль. Интерпретатор возвращает результат выполнения последнего выражения в теле модуля (обычно это nil).
\end{itemize}

Любой модуль, объявленный в теле другого модуля, добавляется в иерархию вложенности. С точки зрения иерархии вложенный модуль будет представлен в виде константы, инициализированной в теле основного модуля. Модули, определенные на верхнем уровне - константы в классе Object.

\subsection{Классы}

Класс - это абстрактная сущность, использующаяся для описания структуры и поведения ее экземпляров. Создание класса называется объявлением, а описание его экземпляров - определением. Любой класс (даже встроенный) может быть переопределен в любом месте кода. Все классы относятся к экземплярам класса Class.

\begin{verbatim}
  class идентификатор_класса
    тело_класса
  end
\end{verbatim}

\begin{itemize}
  \item Инструкция class ожидает получения константы, сообщая интерпретатору область памяти в которую необходимо выполнить запись информации. Если соотвествующей области не существует, то автоматически объявляется новый класс. В другом случае будет изменен уже существующий класс.

  \item Идентификатор класса должен начинаться с прописной буквы. Каждое отдельное слово также начинается с прописной буквы. Такой подход называют ВерблюжьейНотацией.

  \item В теле класса создается отдельная область видимости. В ней может определяться поведение экземпляров класса или любые другие сущности. Внутри тела класса псевдопеременная self ссылается на класс. Интерпретатор возвращает результат выполнения последнего выражения в теле класса (обычно это nil).
\end{itemize}

\subsection{Константы}

Константы определяются в теле класса и служат для хранения известных и не изменяющихся данных, общих для всего класса. 

Использовать константу можно с помощью бинарного оператора \mono{::}, имеющего наивысший приоритет и последовательность выполнения L. В качестве левого операнда используется идентификатор класса, а в качестве правого операнда - константа. Использование константы называют ее вызовом.
\verb!класс::константа!

Использование этого выражения с оператором присваивания \mono{=}, позволяет инициализировать константу в любом месте кода.

Для того, чтобы вызвать константу, интерпретатор должен определить какая именно константа должна быть использована. При полной записи выражения поиск осуществляется в указанном классе. При отсутствии левого операнда по умолчанию используется псевдопеременная self.

При наличии только константы, поиск будет выполняться в следующем порядке:
\begin{enumerate}
  \item в теле класса, в котором была вызвана константа;
  \item в теле модуля, в котором определяется класс;
  \item в теле модуля, добавленного к классу;
  \item вверх по иерархии классов с выполнением пунктов 1-3;
  \item вызов метода \method{::const_missing} для класса, в теле которого была вызвана константа.
\end{enumerate}

\subsection{Переменные} 

Переменные определяются в теле класса и служат для хранения изменяющихся данных: состояния класса и его экземпляров. Переменные могут существовать в двух различных областях видимости: области видимости класса и области видимости экземпляра класса.

\paragraph*{Переменные класса:} переменные, объявляемые в области видимости класса.

Переменные класса могут быть объявлены в любом фрагменте тела класса (в том числе и в теле метода). Лексема переменной начинается с символов @@. 

Переменная класса может быть использована в любом фрагменте тела класса (в том числе и в теле метода). Она ссылается на один и тот же объект для всех его экземпляров.

Переменные класса используются для хранения изменяющихся данных, общих для всех экземпляров класса. Обычно переменные класса инициализируются в теле класса и используются в теле его методов. Использование не существующей переменной класса приводит к вызову ошибки.

\paragraph*{Переменные экземпляра:} переменные, объявляемые в области видимости экземпляра класса.

Переменные экземпляра могут быть объявлены в теле метода экземпляров класса. Лексема переменной начинается с символа @. 

Переменная экземпляра может быть использована в теле любого метода экземпляров класса. Она ссылается на разные объекты для каждого отдельного экземпляра.

Переменные экземпляра используются для хранения состояния экземпляров класса. Обычно переменные экземпляра инициализируются в теле метода в момент его вызова. Использование не существующей переменной экземпляра приводит к ее автоматичсекому объявлению.

\subsection{Методы}

Методы - это абстрактные сущности, определяющие действия, которые может выполнять объект. Выполняемые действия делятся на два вида: функции и процедуры. В Ruby их четкого синтаксичекого разграничения не существует - процедуры входят в подмножество функций. С точки зрения языка программирования, метод относится к выражениям.
\begin{description}
  \item[Функция] - это метод, используемый для получения объекта (например математические функции);

  \item[Процедура] - это метод, используемый для выполнения действия (например сохранение данных в файл). В результате выполнения процедуры обычно возвращается статус выполнения (логическая величина) или ссылка на объект, для которого вызывалась процедура.
\end{description}

С точки зрения синтаксиса метод - это именованный фрагмент кода, выполняющий одну конкретную задачу. Методы определяются в теле класса. В результате определения возвращается nil. Каждый метод связан с тем объектом, для которого был определен и не может использоваться без ссылки на него. Использование метода также называют вызовом.

\subsubsection*{Определение метода}

\textbf{Методы экземпляров класса:} методы, определяющие поведение экземпляров класса.
\begin{verbatim}
  def идентификатор_метода(параметры)
    тело_метода
  end
\end{verbatim}

\textbf{Методы класса:} методы, определяющие поведение класса.
\begin{verbatim}
  def класс.идентификатор_метода(параметры)
    тело_метода
  end
\end{verbatim}

\begin{note}
  Вместо идентификатора класса может использоваться псевдопеременная self. Это повышает переносимость кода, определяя метод не для любого текущего класса, а не для какого-то конкретного.
\end{note}

\begin{keylist}{Фрагменты синтаксиса:}
  
  \firstkey{Идентификатор метода:} лексема идентификатора метода аналогична лексеме локальной переменной.

  Обычно имя метода выбирается в соответствии с его целью:
  \begin{itemize}
    \item Для именования процедур обычно используются глаголы;
    \item Имя функции обычно описывает объект, который она возвращает;
    \item Имя методов с побочным эффектом обычно заканчивается восклицательным знаком (добавляется только если существует версия метода без побочного эффекта);
    \item Предикаты - это методы, утверждающие или отрицающие что-либо об объекте. В результате выполнения предиката возвращается логическая величина, характеризующая истинность или ложность утверждения. Имя предиката обычно заканчивается вопросительным знаком.
  \end{itemize}
  
  \key{Параметры:} локальные переменные, которые служат для разделения аргументов (объектов, передаваемых методу при вызове).

  Несколько параметров разделяются запятыми. При вызове метода параметры будут последовательно инициализироваться переданными аргументами с помощью выражения присваивания.
  \begin{itemize}
    \item Если параметр инициализируется при объявлении метода, то он имеет значение по умолчанию. Это значение будет использоваться, если при вызове метода необходимый аргумент не передавался. Значения по умолчанию могут быть произвольными выражениями, переменными экземпляра или даже другими параметрами, объявленными ранее. Параметры, имеющие значение по умолчанию, должны объявляться последовательно;

    \item Если перед параметром используется оператор разименования (\mono{*}), то такой параметр принимает произвольное количество аргументов, которые будут сохранены в индексном массиве и присвоены параметру. Подобный тип параметров объявляется после параметров, имеющих значение по умолчанию, и должен быть единственным для каждого метода;

    \item Если перед последним параметром используется амперсанд (\mono{\&}), то такой параметр принимает блок (вызывая для аргумента метод \method{.to_proc}). В теле метода может использоваться как параметр, так и инструкция yield.
  \end{itemize}

  Для повышения читабельности параметров, ссылающихся на логическую величину может использоваться приставка is.

  \key{Тело метода:} фрагмент кода, выполняемый в момент вызова метода.

  Тело метода создает собственную область видимости. В ней доступны объявленные параметры и переменные экземпляра. В теле метода псевдопеременная self ссылается на объект, для которого метод был вызван.
  
\end{keylist}

\paragraph*{Синонимы:} копия метода, имеющая другой идентификатор.

Для метода может быть определено любое количество синонимов. Синонимы могут быть созданы только в теле класса, объявляющего метод.

Создание синонима выполняется с помощью инструкции alias:
\\\verb!alias синоним идентификатор_метода!

% ``` note
\begin{note}
Запомнить синтаксис выражения создания синонимов будет проще, если рассматривать его относительно выражения присваивания: \verb!синоним = метод!.
\end{note}
% ```

\paragraph*{Удаление метода:} выполняется с помощью инструкции undef. Ее можно использовать только в теле класса, определяющего данный метод или в теле его подклассов (в этом случае метод будет удален только для отдельного подкласса).
\\ \verb!undef идентификатор_метода!

\subsubsection*{Блоки}

Блоки - одна из особенных синтаксических конструкций в Ruby, предоставляющая мощные возможности по выполнению кода.

С точки зрения синтаксиса, блок - это фрагмент кода, связанный с группой параметров. Блоки не могут использоваться сами по себе, а только передаваться методам (они всегда должны передаваться методу последними). Если объект не использует блок, то его передача игнорируется.
\begin{note}
  Методы, позволяющие перебирать элементы составного объекта, не зависимо от их типа, называются итераторами. Перебор элементов выполняется с помощью блока, которому они передаются. Каждое отдельное выполнение блока называется итерацией. В результате выполнения итератора обычно возвращается ссылка на объект, для которого он был вызван.

  Вместо блока итераторы также могут принимать идентификатор метода, начинающийся с амперсанда. В этом случае метод будет вызван для каждого элемента составного объекта.

  Итераторы в Ruby - это синтаксический сахар, использующийся вместо предложения перебора (for in). 
\end{note}
\verb!{ |параметры| тело_блока }!
\\ или
\begin{verbatim}
  do |параметры|
    тело_блока
  end
\end{verbatim}

Открывающая фигурная скобка или инструкция do относятся к предыдущему выражению - остальные аргументы необходимо ограничивать круглыми скобками, иначе блок будет передан последнему аргументу.

\begin{keylist}{Синтаксис блока:}

  \firstkey{Параметры:} локальные переменные, которые служат для разделения аргументов (объектов, передаваемых блоку).

  Несколько параметров разделяются запятыми. При выполнении блока параметры будут последовательно инициализироваться переданными аргументами с помощью выражения присваивания.

  Параметры блока не могут иметь значений по умолчанию или принимать блоки. Однако они могут ссылаться на массив аргументов (с помощью оператора разыименования *).
  
  \key{Тело блока:} создает собственную область видимости. В нем определены объявленные параметры и переменные экземпляра. В теле блока псевдопеременная self ссылается на объект, для которого был вызван метод, принимающий блок. Интерпретатор возвращает результат выполнения последнего выражения.

  Блок относится к замыканиям - в теле блока существуют локаьные переменные, объявленные в окружающем коде. Чтобы явно указать переопределение локальных переменных, их идентификаторы отделяют от параметров блока точкой с запятой (\verb!| x, y; z, k, n |!). Переопределенные локальные переменные в теле блока будут ссылаться на nil.
\end{keylist}

\paragraph*{Выполнение блока:} блок выполняется в момент вызова.

Для вызова блока в теле метода используется инструкция yield, которой передаются аргументы, отправляемые в блок (интсрукция не может принимать блоки). Избыток аргументов игнорируется. Выполнив инструкцию, интерпретатор возвращает результат выполнения блока.

Процесс выполнения блока может изменяться с помощью специальных инструкций в его теле. Необязательный код, передаваемый инструкции становится результатом выполнения. Если он не указан, то в результате возвращается nil.
\begin{keylist}{Процесс выполнения:}
  
  \firstkey{return [код]} - завершает выполнение блока, принимающего блок метода, и метода, в теле которого это происходит;
  
  \key{break [код]} - завершает выполнение блока и принимающего блок метода;
  
  \key{next [код]} - завершает выполнение блока. Итератор, принимающий блок, может начать новую итерацию;
  
  \key{redo} - еще раз выполняет тело блока.
\end{keylist}

\subsubsection*{Вызов метода}

Методы вызываются с помощью бинарного оператора \mono{.} (или \mono{::}, но он обычно не используется или используется только для вызова методов класса), имеющего наивысший приоритет и последовательность выполнения L. В качестве левого операнда используется объект, а в качестве правого операнда — идентификатор метода.
\\\verb!объект.идентификатор_метода(аргументы)!

Аргументы - это группа объектов, инициализрующих параметры. Несколько объектов разделяются запятыми. Недостаток или избыток аргументов приводит к вызову ошибки. Количество требуемых аргументов соотвествует количеству объявленных параметров.

В результате вызова метода возвращается результат выполнения последнего выражения в его теле. Вызов метода без указания объекта вызывает его для псевдопеременной self. 

Аргументы классифицируют по способу их передачи. В Ruby все аргументы передаются по ссылке.
\begin{itemize}
  \item Передача по значению - метод копирует переданный аргумент. Изменение параметра не влияет на передаваемый аргумент;

  \item Передача по адресу - передаваемым значением является адрес, по которому можно найти значение переменной;

  \item Передача по ссылке - метод копирует не переданный аргумент, а его адрес, однако использует синтаксис, при котором работа выполняется с объектом, хранящимся по этому адресу. Изменение параметра также изменит переданный аргумент.
\end{itemize}

\itemtitle{Синтаксис вызова:}
\begin{itemize}
  \item использование круглых скобок при вызове метода не обязательно (кроме случаев, когда методу также передается блок);

  \item если последним аргументом метода передается ссылка на ассоциативный массив, то использование фигурных скобок для выделения массива не требуется;

  \item если методу передается аргумент, перед которым используется звездочка, то из объекта будут извлечены все его элементы (с помощью метода \method{.to_splat}). Это позволяет передавать аргументы в виде составного объекта;

  \item если методу передается аргумент, перед которым используется амперсанд (\mono{\&}), то он обрабатывается также как блок. Такой аргумент должен передаваться методу последним.  
\end{itemize}

Перед вызовом метода интерпретатор должен определить какой именно метод использовать. Поиск осуществляется в следующем порядке:
\begin{enumerate}
  \item в собственном классе объекта;
  \item в теле класса объекта;
  \item в теле модуля, добавленного к классу;
  \item вверх по иерархии классов с выполнением пунктов 2 и 3;
  \item вызов для объекта метода \method{.method_missing}. 
\end{enumerate}

\subsubsection*{Процесс выполнения}

Процесс выполнения метода может изменяться с помощью специальных инструкций в его теле. Необязательный код, передаваемый инструкции становится результатом выполнения. Если он не указан, то в результате возвращается nil.
\begin{keylist}{Процесс выполнения:}
  
  \firstkey{return [код]} - завершает вызов метода;
  
  \key{break [код]} - вызывает ошибку;
  
  \key{next [код]} - вызывает ошибку;
  
  \key{redo} - вызывает ошибку.
\end{keylist}

\subsection{Объекты}

\paragraph*{Экземпляры классов:} объекты, создаваемые с помощью классов.

Для создания объекта вызывается метод \method{::new} того класса, экземпляр которого необходимо получить. Этот метод выполняет два действия: создает область памяти для объекта, вызывая метод \method{.allocate}, и заполняет эту область, вызывая метод \method{.initialize}. 

Метод \method{.initialize} должен определяться классом или будет использован метод базового класса. Определяемый метод автоматически становится частным. Инициализируемые в нем переменные экземпляра доступны в теле любого другого метода экземпляров.

\begin{note}
  Метод .allocate уже определен в классе Class и его переопределение обычно не требуется.
\end{note}

Для создания экземпляра класса может быть определен любой другой метод, в результате. Такие методы называют конструкторами.

\paragraph*{Классы и модули:} могут рассматриваться с точки зрения экземпляров классов Class и Module соответственно.

К ним также применимы методы экземпляров, определенные в этих классах, синтаксис вызова которых аналогичен вызову методов класса. 

Если определить переменную экземпляра в теле класса, а не в теле метода, то она будет связана с классом, а не с его экземплярами. Такие переменные недоступны в теле методов и фактически относятся к переменным экземпляра объекта, принадлежащего к классу Class.

\begin{methodlist}
  \declare{Module::new \{ nil \}}{\# -> module} 
  Создание анонимного модуля. Необязательный блок выполняется в теле модуля. Модуль перестанет быть анонимным, если будет присвоен константе. 

  \declare{Class::new( class = Object )}{\# -> class} 
  Создание анонимного класса, наследующего переданному. Класс перестанет быть анонимным, если будет присвоен константе.
\end{methodlist}

\paragraph*{Собственный класс объекта:} отдельный класс для каждого объекта.

Каждый объект кроме класса, к экземплярам которого относится, имеет еще и свой собственный класс. С помощью собственных классов для объектов определяется уникальное поведение. Собственные классы также называют метаклассами (metaclass).
\begin{verbatim}
  class << объект
    тело_класса
  end
\end{verbatim}

Это предложение определяет собственный класс для переданного объекта. Объект рационально передавать с помощью переменной. В теле класса в этом случае используется псевдопеременная self.

При создании собственный класс помещается в начало иерархии наследования (т.е класс объекта становится базовым для собственного класса объекта). При этом хоть собственные классы и входят в иерархию наследования, но программисту в ней отображаться они не будут.

Интерпретатор возвращает результат выполнения последнего выражения в теле собственного класса объекта (обычно это nil).

\paragraph*{Собственный метод объекта:} метод, определенный в собственном классе объекта.

Собственные методы объекта могут быть определены либо в теле собственного класса (как методы экземпляров), либо с помощью отдельного предложения.

\begin{verbatim}
  def объект.метод
    тело_метода
  end
\end{verbatim}

Определение такого метода возможно только после создания объекта (объект также должен существовать в текущей области видимости). Очевидно, что объект должен быть представлен в виде переменной или константой.

В результате возвращается nil.

Поведение всего класса зависит от набора существующих методов класса. Поэтому, неудивительно, что методы класса также относятся к собственным методам объекта (которым в данном случае является класс). 

\itemtitle{Класс:}
\begin{itemize}
  \item методы экземпляров хранятся в теле класса;
  \item методы класса (собственные методы) хранятся в теле собственного класса объекта (объектом в данном случае является класс).
\end{itemize}

Следовательно главное отличие классов от обычных объектов в возможности хранить методы своих экземпляров.

\subsection{Примеры}

Определение простого класса в теле модуля.

Метод \method{.to_s} используется при отображении экземпляра класса.

\begin{verbatim}
  module OurKlass
    class User
      @@count = 0 # class var.

      # class method.
      def self.count
        @@count
      end

      def initialize( name, age )
        @name = name # instance var.
        @age = age
        @@count += 1
        @id += 1
      end

      # instance method.
      def to_s
        "#\{@name\}: #\{@age\} years old"
      end

    end # class User.
  end # module.
\end{verbatim}

Создание экземпляра класса. Метод \method{.to_a} еще не определен.
\begin{verbatim}
  user = OurKlass::User.new "Timmy", 22 # -> "Timmy: 22 years old"
  OurKlass::User.count # -> 1
  user.to_a # -> error!
\end{verbatim}

Определение метода \method{.to_a}.
\begin{verbatim}
  class OurKlass::User
    def to_a
      [ @name, @age ]
    end
  end

  user.to_a # -> ["Timmy", 22]
\end{verbatim}

Различные способы определения метода класса.
\begin{verbatim}
  class OurKlass::User
    def self.next_count
      @@count + 1
    end
  end

  OurKlass::User.next_count # -> 2

  class OurKlass::User
    class << self
      def prepend_count
        @@count - 1
      end
    end
  end

  OurKlass::User.prepend_count # -> 0
\end{verbatim}

Определение собственного метода объекта. При переопределении переменной для нового объекта метод определен уже не будет.
\begin{verbatim}
  class << user
    def id
      @id
    end
  end

  user.id # -> 1
  user = OurKlass::User.new "Tommy", 33 # -> "Tommy: 33 years old"
  user.id # -> error!
\end{verbatim}

\section{Основные принципы}

\subsection{Инкапсуляция}

Инкапсуляция обеспечивается ограничением области применения методов и ограничением доступа к состоянию объектов.

\subsubsection*{Контроль применения}

Контроль доступа позволяет ограничивать область применения методов.

Методы могут быть как чисто внутренними, обеспечивающими логику функционирования объекта, так и внешними, позволяющими объектам взаимодействовать, требуется реализовать их разделение. Доступ к внутренним методам при этом ограничивается областью видимости класса.

\itemtitle{Классификация методов:}
\begin{description}
  \item[public]    - общие методы. Общие методы позволяют объектам взаимодействовать друг с другом. Они могут быть вызваны в любой области видимости;

  \item[protected] - защищенные методы. Защищенные методы позволяют объектам одного типа взаимодействовать друг с другом. Они могут быть вызваны только в области видимости класса (и его подклассов) или экземпляров класса (и его подклассов) и только для экземпляров того же класса (и его подкласов);

  \item[private]   - частные методы. Частные методы реализуют внутреннюю логику объекта. Они могут быть вызваны только в области видимости  класса (и его подклассов) или экземпляров класса (и его подклассов) и только для текущего экземпляра (частные методы всегда вызываются для псевдопеременной self). Частные методы помогают скрывать реализацию работы программы и предоставлять только API для использования.
\end{description}

Область применения метода объявляется с помощью частных методов экземпляров из класса Module: \method{.public}, \method{.private} и \method{.protected}:
\begin{itemize}
  \item Интерпретатор ограничивает применение всех методов, идентификаторы которых переданы;

  \item Интерпретатор ограничивает применение всех методов, объявляемых после вызова метода без аргументов.
\end{itemize}

\begin{methodlist}
  \declare{module.private_class_method(*name)}{\# -> self} 
  Объявление методов класса частными. Обычно используется для инкапсуляции метода \method{::new}.

  \declare{module.public_class_method(*name)}{\# -> self} 
  Объявление методов класса общими. 

  \declare{module.module_function( *name = nil )}{\# -> self}
  Переданные методы экземпляров объявляются как частные. Для каждого метода также создается аналогичный метод класса. Это позволяет использовать их в теле производного класса без ссылки на модуль (например модуль Math). При вызове без аргументов влияет на все методы, объявленные далее.  
\end{methodlist}

Методы, определяемые вне тела явно определенного класса, относятся к частным методам класса Object.

\subsubsection*{Методы доступа}

По умолчанию состояние объекта не доступно вне тела объекта. Поэтому для получения или изменения значения переменных экземпляра или класса требуется явно определять методы доступа. Существует два вида методов доступа: метод, позволяющий получать состояние объекта (читать значение переменной), и метод, позволяющий изменять состояние объекта (определять значение переменной).

Методы чтения обычно просто возвращают текущее значение переменой. Для этого в конце тела метода, последним выражением используют идентификатор требуемой переменной.

Методы записи изменяют значение переменной. Для этого в конце тела метода, последним выражением используют выражение присваивания, в котором участвуют идентификатор требуемой переменной и переданный методу аргумент. Идентификатор метода доступа при этом обычно заканчивается знаком равенства (\mono{=}).

\paragraph*{Свойства:} синтаксический сахар над методами доступа.

Для облегчения определения методов доступа существуют свойства. Свойства - это методы доступа к состоянию экземпляров класса. При объявлении свойства автоматически объявляются соотвествующие переменные экземпляра и методы доступа к ним.

Объявление свойств выполняется с помощью частных методов экземпляров из класса Module. 
\begin{methodlist}
  \declare{.attr_accessor(*attribute)}{\# -> nil}
  Объявление переменной экземпляра и методов доступа для ее получения и изменения.

  \declare{.attr_reader(*attribute)}{\# -> nil}
  Объявление переменной экземпляра и метода доступа для ее получения.

  \declare{.attr_writer(*attribute)}{\# -> nil}
  Объявление переменной экземпляра и метода доступа для ее изменения.
\end{methodlist}

\subsection{Наследование}

Наследование обеспечивается возможностью изменять существующую иерархию наследования, добавляя к ней новые элементы.

\subsubsection*{Синтаксис наследования}

В Ruby реализовано единичное наследование с возможностью произвольного добавления модулей. Это означает, что любой класс может иметь только один базовый класс и бесконечное количестов добавленных модулей.

\paragraph*{Наследование класса:} может быть выражено словосочетанием "относится к" или "принадлежит к".

При наследовании одного класса другому в начало иерархии наследования добавляется новый класс, который, в свою очередь, будет наследовать классу Object.
\\\verb!class производный_класс < базовый_класс!

\paragraph*{Добавление модуля:} может быть выражено словом "содержит".

При добавлении модуля иерархия наследования он перемещается в начало иерархии наследования. В зависимости от способа добавления это может быть иерархия наследования обычных классов или иерархия наследования собственных классов.

\begin{methodlist}
  \declare{module.include(*a_module)}{\# -> self [PRIVATE]}
  Добавление модулей в начало иерархии наследования. Методы экземпляров, определенные в модуле, становятся методами экземпляров текущего модуля.

  \declare{object.extend(*a_module)}{\# -> object}
  Добавление модулей в начало иерархии наследования собственных классов. Методы экземпляров, определенные в модуле, становятся собственными методами объекта.

  \declare{module.extend_object(object)}{\# -> object [PRIVATE]}
  Аналогично выполнению \verb!object.extend self!
\end{methodlist}

Добавление модулей к иерархии наследования возможно только в теле модуля (или класса), а добавление модулей к иерархии наследования собственных классов в любом фрагменте кода (в теле класса методы экземпляров из модуля становятся методами класса).

\begin{note}
  Вызов \verb!extend self! в теле класса приведет к тому, что для каждого метода экземпляров автоматически объявляется соответствующий метод класса.
\end{note}

\subsubsection*{Иерархия наследования}

На вершине иерархии находится класс BaseObject, от него наследует класс Object, в теле которого выполняется программа. К классу Object добавлен модуль Kernel, в котором определено большинство основных методов. Любой модуль относится к экземплярам класса Module, который наследует классу Object. Методы экземпляров из класса Module могут вызываться в теле модулей. Любой класс относится к экземплярам класса Class, который наследует классу Module. Методы экземпляров из класса Class могут вызываться в теле классов. Методы экземпляров из класса Module могут вызываться в теле классов. Методы экземпляров из класса Class не могут вызываться в теле модулей.

\begin{note}
  Если собственные классы объектов влияют только на объект, то каким-образом наследуются методы класса? Дело в том, что при наследовании собственный класс производного класса наследует собственному классу базового класса. Образуется две равнозначные иерархии наследования - для обычных классов и для собственных.
\end{note}

$$
  \xymatrix{
  Classes \: +Modules &  Metaclasses\\
  BasicObject \ar[d] & <Class\colon BasicObject > \ar@{-->}[l] \ar[d] \\
  Object \ar[d] & <Class\colon Object> \ar@{-->}[l]^(0.75){+Kernel} \ar[d]\\
  Module \ar[d] & <Class\colon Module> \ar@{-->}[l] \ar[d]\\
  Class \ar@/^1pc/@{-->}[ruuu] & <Class\colon Class> \ar@{-->}[l] }
$$

\begin{itemize} 
  \item Переменные экземпляра не наследуются;

  \item Переменные класса наследуются его подклассами. При этом они ссылаются на тот же объект, что и в базовом классе;

  \item Константы наследуются производными классами. При этом они ссылаются на разные объекты для каждого подкласса;

  \item Методы наследуются производными классами. При этом для каждого класса существует своя копия метода.
\end{itemize}

\subsection{Полиморфизм}

Полиморфизм обеспечивается возможностью произвольно изменять унаследованные методы.

\paragraph*{Виртуальные методы:} методы, которые могут быть переопределены производным классом. В Ruby все методы относятся к виртуальным. Для переопределения метода, в теле класса, объявляют метод с тем же идентификатором. 

Чтобы из переопределяемого метода вызвать метод базового класса вызывают инструкцию super, которой передаются неоходимые аргументы. В другом случае методу базового класса будут переданы все аргументы, переданные текущему методу.

\paragraph*{Переопределение операторов:} одной из полезных особенностей в Ruby является то, что большинство операторов на самом деле относятся к методам. Поэтому поведение операторов для разных типов объектов отличается - оно зависит от определения метода в теле класса. Также разрешается определять собственное поведение для различных операторов и переопределять уже существующее. Выражение, составленное с помощью операторов, при этом аналогично вызову метода с тем же идентификатором.
\begin{verbatim}
  op object <-> object.op
  object1 op object2 <-> object1.op(object2)
\end{verbatim}
Операторы, не относящиеся к методам:
\verb!., ::, &&, ||, ?:, =, псевдооператоры, not, and, or, .., ... !

\paragraph*{Абстрактный метод:} метод, который был объявлен, но не определен. В Ruby все абстрактные методы считаются определенными и вовращают ссылку на nil.

\paragraph*{Абстрактный класс:} класс, соержащий хотя бы один виртуальный метод. Абстрактные классы используются только в иерархии наследования и не предназначены для создания экземпляров.

В Ruby создание экземпляров абстрактных классов не ограничивается, и фактически абстрактные классы не отличаются от обычных.
\begin{note}
  Класс Numeric, к которому относятся все числа - типичный абстрактный класс, а класс IO, к которому относятся файлы и потоки, абстрактным не является. В любом случае синтаксис определения этих классов не отличается.
\end{note}

Абстрактные классы можно рассматривать в качестве интерфейса к группе производных классов, но, в отличии от интерфейсов, абстрактные классы могут иметь определенные методы и свойства.

\paragraph*{Интерфейс:} модуль, содержащий только абстрактные методы. Интерфейсы описывают функциональность, предоставляемую классом, реализующим интерфейс. Класс, реализующий интерфейс, должен определять все его методы. Один класс может реализовывать несколько интерфейсов одновременно.
Пример интерфейса:
\begin{verbatim}
  module Openable
    def open; end
    def close; end
  end
\end{verbatim}