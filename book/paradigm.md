# Парадигмы программирования

Парадигма программирования - это система идей и понятий, определяющих стиль написания компьютерных программ. Отдельные парадигмы программирования не являются взаимоисключающими и, следовательно, могут сочетаться.


## ООП

*Объектно-ориентированная парадигма (ООП)* - это парадигма программирования, предоставляющая концепцию "объектов", связанных с данными (свойствами объектов) и способами их обработки (методами объектов). Большинство основных положений ООП было развито в языке программирования Smalltalk, сильно повлиявшем на Ruby. В настоящее время количество прикладных языков программирования, реализующих ООП, преобладает над остальными парадигмами.

ООП развивает идеологию процедурного программирования, где данные и способы их обработки формально не связаны.

ООП - это не только набор конкретных методик, а также еще и философия проектирования приложений. Как и любая сложная парадигма, ООП состоит из нескольких уровней понимания. Следует заметить, что применение объектно-ориентированного языка Ruby не означает, что код автоматически становится объектно-ориентированным - требуется явная реализация и использование объектно-ориентированных концепций.

Основные понятия, используемые в ООП - это абстракция, класс, объект, свойство, метод, инкапсуляция, наследование и полиморфизм.

*Объектно-ориентированный дизайн* - это дисциплина, описывающая способы создания объектов и взаимодействие между ними для решения поставленной задачи. Таким образом, поведение программы формируется с помощью группы объектов, обменивающихся сообщениями для взаимодействия.


~~~~~ note
Хоть ООП и является достаточно удобной парадигмой, не стоит забывать, что она далеко не единственная. В некоторых случаях применение объектного подхода не оправдано и снижает производительность и удобство создания программ. В любом случае необдуманное и чрезмерное применение концепций ООП усложняет и замедляет выполнение кода, превращая его в бесполезный, малопонятный набор выражений.
~~~~~


#### Абстракция:

*Абстрагирование* - это способ выделить существенные свойства и игнорировать несущественные. Соответственно, *абстракция* - это набор выделенных существенных свойств.

Существенные свойства - это свойства, которыми сущность обязана обладать, чтобы быть именно этой сущностью. Несущественные свойства - свойства, обладание которыми необязательно.

С точки зрения сложности, главное достоинство абстракции в том, что она позволяет игнорировать несущественные детали (не имеющие значения для программы). Абстракция - это один из главных способов борьбы со сложностью реального мира.


#### Объект:

В основе ООП находится понятие объекта. Объект - это абстракция определенного участка памяти компьютера. Обычно объекты относятся к динамичным сущностям, создаваемым и изменяемым в процессе выполнения программы.

Объекты обладают состоянием и поведением.

Состояние объекта - это совокупность значений свойств (хранимых объектом данных).

Поведение объекта - это набора доступных ему методов. Методы - это сообщения, которыми обмениваются объекты. Это абстрактные сущности, определяющие действия, которые можно выполнить над объектом и действия, которые сам объект может выполнять. Пользуясь методами объекта мы можем влиять на его состояние и состояние программы в целом.

Таким образом ООП оперирует состоянием, заключенным внутри объекта, и позволяет влиять на него с помощью предоставленных методов.

Создание объектов позволяет уменьшить сложность программы, акцентируя внимание только на использующихся сущностях и  взаимодействии между ними.


#### Класс:

*Класс* - это абстрактная (виртуальная) модель, еще несуществующей сущности. Фактически класс является образцом для создания новых объектов (формулой или руководством по эксплуатации) и содержит описание их структуры (название свойств и доступные методы). Обычно классы относятся к статичным сущностям, существующим в коде и неизменным в процессе выполнения.

В отличии от объектов, классы обычно не содержат данных (если не считать данные о структуре объектов). Передача данных классу позволяет создавать объекты с заранее известной структурой.

Объект, созданный по образцу класса называют экземпляром этого класса. Основное предназначение классов - определять поведение своих экземпляров. Обычно классы создают таким образом, чтобы они описывали объекты предметной области (объекты реального мира).

Классы позволяют объединять схожие сущности, уменьшая этим размеры и сложность программы.


#### Типизация данных:

Тип данных - это информация об объекте, идентифицирующая совокупность остальных его свойств, определяющих его место и роль в рамках программы. Разделение объектов на типы позволяет контролировать допустимость их применения в той или иной ситуации.

~~~~~ note
Существуют также нетипизированные языки. В них все сущности считаются просто последовательностями бит различной длинны. Обычно это низкоуровневые языки.
~~~~~


###### Статическая и динамическая типизация

При статической (static typing) типизации конечные типы переменных устанавливаются на этапе компиляции.

+ Проверка типов выполняется только один раз;
+ Потенциальные ошибки можно обнаружить уже на этапе компиляции;
+ Ускорение разработки при поддержке IDE.

При динамической (dynamic typing) типизации конечные типы переменных устанавливаются во время выполнения программы.

+ Облегчение создания составных объектов, содержащих элементы произвольных типов;
+ Облегчение создания обобщенных алгоритмов, работающих с любыми типами;
+ Облегчение освоения языка.

Некоторые языки реализуют оба вида типизации.


###### Сильная и слабая типизация (строгая и нестрогая)

При сильной типизации (strong typing) не позволяется смешивать в выражениях различные типы и не выполняется неявных преобразований.

+ Неправильное поведение будет считаться ошибкой или исключением;
+ Явные преобразования вместо скрытых;
+ Облегчение понимания кода;
+ Определенность преобразований.

При слабой типизации (weak typing) выполняется множество неявных преобразований, даже если может произойти потеря точности или преобразование неоднозначно.

+ Удобство использования смешанных выражений;
+ Абстрагирование от типа сущности;
+ Сокращение объема кода.


###### Явная и неявная типизация

При явной типизации (explicit typing) тип сущности нужно задавать самостоятельно.

+ Облегчение понимания кода.

При неявной типизации (implicit typing) тип сущности определяется компилятором или интерпретатором.

+ Уменьшение объема кода;
+ Облегчение изменений.


###### Утиная типизация

> "Если что-то выглядит как утка, плавает как утка и крякает как утка, то, вероятно, это утка".

Это способ типизации данных, основанный на проверке текущего набора методов объекта, в отличии от принадлежности к определенному классу. Для этого проверяется реакция объекта на вызов определенных методов в текущий момент. Если она удовлетворяет заданным условиям, то использование типа разрешается. В другом случае, использование такого типа данных, считается ошибкой.


~~~~~ note
Напомню, что в Ruby используется динамическая сильная неявная типизация. Типы определяются во время выполнения программы, смешивание различных типов не позволяется, тип сущности определяется интерпретатором автоматически. При этом часто используются принципы "утиной" типизации.
~~~~~


#### Инкапсуляция:

Инкапсуляция - это механизм языка, позволяющий сущности (объекту) объединять в себе данные и методы для работы с этими данными. Данные при этом скрыты от других частей программы, а методы доступны для взаимодействия между объектами (и, соответственно, могут предоставлять доступ к данным). Объект не считается отдельной сущностью, если его состояние может быть изменено без явного использования ссылки на объект (метода объекта).

+ Инкапсуляция позволяет распараллелить процессы создания программы, ускоряя разработку ПО;

+ Инкапсуляция снижает сложность разработки, позволяя сосредоточиться на небольших фрагментах программы;

+ Инкапсуляция помогает сокрытию деталей реализации, необходимых программе, но выходящих за рамки абстракции.

+ Инкапсуляция помогает управлять сложностью, скрывая доступ к ней.


#### Наследование:

Наследование - это механизм языка, позволяющий сущности (классу) использовать структуру другой сущности, заимствуя и расширяя уже имеющуюся функциональность (методы). Класс, который заимствуется (наследуется) называется базовым или суперклассом, а класс, который заимствует (наследует) - производным или подклассом. Все базовые и производные классы в общем создают иерархию классов программы.

+ Наследование снижает время на разработку за счет повторного использования кода;

+ Наследование снижает сложность, позволяя использовать уже известные фрагменты программы. Однако при сложной иерархии повышается объем кода, с которым работает программист в отдельный момент времени;

+ Наследование дополняет абстракцию, выделяя сущности с незначительным уровнем различий. Наследование позволяет создавать абстракции с различным уровнем реализации (дополнительными группами существенных свойств).


#### Полиморфизм:

Полиморфизм - это механизм языка, позволяющий производным классам изменять унаследованное поведение с сохранением общей структуры.

+ Полиморфизм повышает скорость разработки, позволяя быстро подстраиваться под требования заказчика;

+ Полиморфизм снижает сложность, позволяя скрывать внутреннюю структуру объектов;

+ Полиморфизм поддерживает возможность отдельной реализации базовых методов для производных классов.


