\chapter{Выражения}

Стандартные объекты и идентификаторы относятся к простым выражениям. В результате их выполнения возвращается объект. Для выполнения вычислений из простых выражений создаются сложные выражения и предложения (которые являются одной из разновидностей сложных выражений). Части сложного выражения соединяются с помощью операторов и инструкций.

\section{Операторы}

Простейший способ создания сложных выражений - объединение простых с помощью операторов. Лексема оператора - это группа математических символов или знаков препинания. Составные части сложного выражения называют операндами. Операнды, в свою очередь, также относятся к выражениям и могут быть как простыми выражениями так и сложными.

\itemtitle{Операторы делятся на:}
\begin{itemize}
	\item Унарные (У) 	- оперируют одним операндом;
	\item Бинарные (Б) 	- оперируют двумя операндами;
	\item Тернарные (Т) - оперируют тремя операндами.
\end{itemize}

Операторы также отличаются приоритетом и последовательностью выполнения операндов. 

В сложных выражениях, содержащих несколько операторов, операнды будут выполняться в порядке увеличения приоритета их операторов.

Если существует несколько операторов с одинаковым приоритетом (или только один оператор), то операнды выполняются в том порядке, в котором были записаны. При R-последовательности это будет происходит справа налево, а при L-последовательности - слева направо.

Чтобы изменить процесс выполнения выражения, операнды, которые необходимо выполнить в первую очередь, отделяют двумя круглыми скобками.

\pagebreak
\begin{longtable}{ | * {5} { l |}}
\hline
  Приор. & Лексема & Послед. & Тип & Название выражения \\ \hline

  1 & \verb#! ~ +# & R & У Б У & логическое отрицание; \\* &&&& побитовое отрицание; \\* &&&& унарный плюс \\ \hline

  2 & ** & R & Б & возведение в степень \\ \hline

  3 & \verb!-! & R & У & унарный минус \\ \hline

  4 & \verb!* / %! & L & Б & произведение (копирование); деление; \\* &&&& остаток от деления (форматирование) \\ \hline

  5 & \verb!+ -! & L & Б & сложение (объединение); \\* &&&& вычитание (удаление) \\ \hline

  6 & \verb!<< >>! & L & Б & побитовый сдвиг влево (добавление) \\* &&&& побитовый сдвиг вправо \\ \hline

  7 & \verb!&! & L & Б & побитовое И (пересечение множест) \\ \hline

  8 & \verb!| ^! & L & Б & побитовое ИЛИ (объединение множеств); \\* &&&& побитовое исключающее ИЛИ \\ \hline

  9 & < <= > >= & L & Б & отношение \\ \hline

  10 & <=> ! = \verb#=~# & L & Б & сравнение; неравенство; поиск совпадений \\ \hline

  10 & \verb#!~# == === & L & Б & отсутствие совпадений; равенство \\ \hline

  11 & \verb!&&! & L & Б & логическое И \\ \hline

  12 & || & L & Б & логическое ИЛИ \\ \hline

  13 & ?: & R & Т & логическое условие \\ \hline

  14 & = & R & Б & присваивание \\ \hline

  15 & not & R & У & логичекое отрицание \\ \hline

  16 & and or & L & Б & логичекое И; логическое ИЛИ \\ \hline  
\end{longtable}
\pagebreak

\begin{enumerate} % Перечисление по приоритету.

  \item %1
  \begin{operator}
    \define{!obj}{логическое отрицание}
    Возвращается ссылка на логическую величину, противоположную по значению.
    \begin{verbatim}
    !1 # -> false
    !nil # -> true\
    \end{verbatim}
  \end{operator}

  \begin{operator}
    \define{\textasciitilde\-, integer}{побитовое отрицание}
    Каждый бит числа изменяется на противоположный и дополняется до 1. В результате возвращается десятичное число, необходимое для дополнения. Аналогично выполнению выражения \verb!-number-1!.
    \begin{verbatim}
    ~1 # -> -2
    ~0b01 # -> -2\
    \end{verbatim}
  \end{operator}

  \begin{operator}
    \define{+ number}{унарный плюс}
    Возвращает число в десятичной системе счисления.
    \\\verb!+0b01 # -> 1!
  \end{operator}

  \item %2
  \begin{operator}
    \define{number**number}{возведение в степень}
    Возведение числа в степень. Первое число - основание степени, а второе - показатель.
    \\\verb!2**3 # -> 8!
  \end{operator}

  \item %3
  \begin{operator}
    \define{- number}{унарный минус}
    Знак числа изменяется на противоположный.
    \\\verb!-0b01 # -> -1!
  \end{operator}

  \item %4
  \begin{operator}
    \define{number * number}{произведение}
    Произведение двух чисел.
    \\\verb!1 * 2 # -> 2!
  \end{operator}

  \begin{operator}
    \define{string * integer}{копирование текста}
    Текст копируется указанное число раз и все копии соединяются.
    \\\verb!"R" * 3 # -> "RRR"!
  \end{operator}

  \begin{operator}
    \define{array * integer}{копирование массива}
    Элементы массива копируются указанное число раз и все копии объединяются.
    \\\verb![ 1, ?R ] * 2 # -> [ 1, "R", 1, "R" ]!
  \end{operator}

  \begin{operator}
    \define{[*object]}{извлечение элементов}
    Извлекаются элементы составного объекта.
    \begin{verbatim}
    a = [ 1, 2, 3 ]
    [*a] # -> [ 1, 2, 3 ]
    [ *a, 1 ] # -> [ 1, 2, 3, 1 ]
    b = \{ a: 1, b: 2 \}
    [*b] # -> [ [:a, 1], [:b, 2] ]
    c = 1..4
    [*c] # -> [ 1, 2, 3, 4 ]
    [*1] # -> [1]
    [*nil] # -> []
    [*?a] # -> ["a"]\
    \end{verbatim}    
  \end{operator}

  \begin{operator}
    \define{number / number}{деление}
    Возвращается частное от деления двух чисел.
    \\\verb!-6 / 3 # -> -2!
  \end{operator}

  \begin{operator}
    \define{number \% number}{остаток от деления}
    Возвращается остаток от деления двух чисел. Результат может изменяться в зависимости от знаков операндов.
    \begin{verbatim}
    7 % 3 # -> 1
    -7 % 3 # -> 2
    7 % -3 # -> -2\
    \end{verbatim}
  \end{operator}

  \begin{operator}
    \define{string \% object}{форматирование}
    Объект преобразуется в текст и форматируется согласно правилам, заданным \hyperlink{appformat}{\underline{форматной строкой}}. В качестве объектов могут быть использованы числа, текст, индексный и ассоциативный массивы.
  \end{operator}

  \item %5
  \begin{operator}
    \define{number + number}{сумма двух чисел}
    Сумма двух чисел.
    \\\verb!1 + 3 # -> 4!
  \end{operator}

  \begin{operator}
    \define{string + string}{объединение текста}
    Объединение двух текстов.
    \\\verb|"Ruby" + ?! # -> "Ruby!"|
  \end{operator}

  \begin{operator}
    \define{array + array}{объединение массивов}
    Объединение двух массивов.
    \\\verb![ 1, 2 ] + [ 3, 4 ] # -> [ 1, 2, 3, 4 ]!
  \end{operator}

  \begin{operator}
    \define{number - number}{вычитание}
    Возвращается разность двух чисел.
    \\\verb!2 - 1 # -> 1!
  \end{operator}

  \begin{operator}
    \define{array - array}{удаление элементов}
    Из первого массива удаляются все элементы, содержащиеся во втором массиве.
    \\\verb![ 1, 2, 2, ?R ] - [ 2, ?1 ] # -> [1, "R"]!
  \end{operator}

  \item %6
  \begin{operator}
    \define{number \twoless integer; number \twogreat integer}{побитовый сдвиг}
    Сдвиг влево или вправо каждого бита на указанное количество разрядов.
    \\\verb!1 << 2 # -> 4!
  \end{operator}

  \begin{operator}
    \define{string \twoless string}{добавление текста}
    В конец первого текста добавляется второй. 

    Если вместо второго операнда передается целое число, то оно обрабатывается как кодовоя позиция символа.
    \begin{verbatim}
    "Ruby" << ?! # -> "Ruby!"
    "Ruby" << 33 # -> "Ruby!"\
    \end{verbatim}
  \end{operator}

  \begin{operator}
    \define{array \twoless object}{добавление элемента}
    В массив добавляется новый объект.
    \\\verb![1] << 2 # -> [ 1, 2 ]!
  \end{operator}

  \item %7
  \begin{operator}
    \define{integer \& integer}{побитовое И}
    Возвращается результат сравнения каждого бита двух чисел.

    Если биты в одинаковых разрядах установлены в 1, то результирующий бит также устанавливается в 1.
    \\\verb!0b01 & 0b10 # -> 0!
  \end{operator}

  \begin{operator}
    \define{array \& array}{пересечение множеств}
    Возвращается массив, содержащий одну копию каждого элемента, входящего в оба массива.
    \\\verb![ 1, 2, 2, 3] & [ 2, 3 ] # -> [ 2, 3 ]!
  \end{operator}

  \item %8
  \begin{operator}
    \define{integer | integer}{побитовое ИЛИ}
    Возвращается результат сравнения каждого бита двух чисел.

    Если любой из битов в одинаковых разрядах установлены в 1, то результирующий бит также устанавливается в 1.
    \\\verb!0b01 | 0b10 # -> 3!
  \end{operator}

  \begin{operator}
    \define{array | array}{объединение множеств}
    Возвращается массив, содержащий одну копию каждого элемента, входящего в любой из массивов.
    \\\verb![ 1, 2, 2, 3 ] | [ 2, 3 ] # -> [ 1, 2, 3 ]!
  \end{operator}

  \begin{operator}
    \define{integer \textasciicircum\-, integer}{побитовое исключающее ИЛИ}
    Возвращается результат сравнения каждого бита двух чисел.

    Если один (и только один) из битов в одинаковых разрядах установлены в 1, то результирующий бит также устанавливается в 1.
    \\\verb!0b01 ^ 0b10 # -> 3!
  \end{operator}

  \item %9
  \begin{operator}
    \define{< <= >= >}{отношение}
    Проверка отношения двух объектов.

    Для чисел:
    \begin{verbatim}
    1 <= 2 # -> true
    1 > 2 # -> false\
    \end{verbatim}

    Для текста:

    При проверке текста последовательно проверяется каждый байт. Первый отрицательный результат станет результатом выполнения всего выражения.

    Каждая следующая буква алфавита считается больше, чем предшественница.

    Любая строчная буква считается больше, чем любая прописная буква.
    \begin{verbatim}
    "а" < "б" # -> true
    "а" < "Б" # -> false
    "1" <= "2" # -> true\
    \end{verbatim}
  \end{operator}

  \item %10
  \begin{operator}
    \define{object == object}{равенство}
    Проверка равенства двух объектов. Объекты считаются равными, если их значения и типы равны.
    \begin{verbatim}
    1 == 1.0 # -> true
    1 == "1" # -> false\
    \end{verbatim}
  \end{operator}

  \begin{operator}
    \define{object != object}{неравенство}
    Проверка равенства двух объектов. Возвращается ссылка на логическую величину, противоположную по значению.
    \begin{verbatim}
    1 != 1.0 # -> false
    1 != "1" # -> true\
    \end{verbatim}
  \end{operator}

  \begin{operator}
    \define{object === object}{равенство}
    Аналогично проверке на равенство, кроме случаев, которые будут описаны отдельно.
    \begin{verbatim}
    1 === 1.0 # -> true
    1 === "1" # -> false\
    \end{verbatim}
  \end{operator}

  \begin{operator}
    \define{string =\textasciitilde\-, regexp; regexp =\textasciitilde\-, string}{поиск совпадений}
    Поиск в тексте совпадений с \hyperlink{appregexp}{\underline{образцом}}. В результате возвращается индекс символа, с которого начинается найденное совпадение, или ссылка на nil, если совпадений не найдено.
  \end{operator}

  \begin{operator}
    \define{!\textasciitilde}{отсутствие совпадений}
    Проверка отсутствия совпадений.
  \end{operator}

  \begin{operator}
    \define{object <=> object}{сравнение}
    Сравнение двух объектов.
    \begin{verbatim}
          < = >
    # ->	-1 0 1\
    \end{verbatim}
    \begin{description}
      \item[-1:]  если первый операнд меньше второго;
      \item[0:]   если операнды равны;
      \item[1:]   если первый операнд больше второго.
      \item[nil:] если сравнение операндов невозможно (разные типы операндов).
    \end{description}

    Сравнить можно два числа, текста, индексных массива (последовательно сравнивается каждый элемент).
    \begin{verbatim}
    1 <=> 1.0 # -> 0
    1 <=> ?2 # -> nil\
    \end{verbatim}
  \end{operator}

  \item %11
  \begin{operator}
    \define{expression \&\& expression}{лоическое И}
    Выполняется первое выражение, если его логическое значение false, или второе выражение в другом случае.
    \begin{verbatim}
    4 && 2 - 1 # -> 1
    3 > 4 && 2 - 1 # -> false\
    \end{verbatim}
  \end{operator}

  \item %12
  \begin{operator}
    \define{expression || expression}{лоическое ИЛИ}
    Выполняется первое выражение, если его логическое значение true, или второе выражение в другом случае.
    \begin{verbatim}
    4 || 2 - 1 # -> 4
    3 > 4 || 2 - 1 # -> 1\
    \end{verbatim}
  \end{operator}

  \item %13
  \begin{operator}
    \define{expression ? expression : expression}{лоическое условие}
    Выполняется первое выражение. Если его логическое значение true, то выполняется второе выражение, или третье выражение в другом случае.
    \begin{verbatim}
    1 > 2 ? true : false # -> false
    1 < 2 ? true : false # -> true\
    \end{verbatim}
  \end{operator}

  \item %14
  \begin{operator}
    \define{identificator = object}{присваивание}
    \hyperlink{appequal}{\underline{Присваивание}} идентификаторов объектам.
  \end{operator}

  \begin{operator}
    \define{**= *= /= \%= += -= \textless\textless= \textgreater\textgreater= \&\&= \&= ||= |= \textasciitilde=}{псевдооператоры}
    Псевдооператоры - это операторы, получившиеся в результате объединения с оператором присваивания.
    \\\verb!object1 op= object2! аналогично \verb!object1 = object1 op object2!
  \end{operator}

  \item %15
  \begin{operator}
    \define{not object}{логическое отрицание}
    Аналогично \verb|!object| с меньшим приоритетом.
  \end{operator}

  \item %16
  \begin{operator}
    \define{expression and expression}{логическое И}
    Аналогично \verb!expression && expression! с меньшим приоритетом.
  \end{operator}

  \begin{operator}
    \define{experssion or expression}{логическое ИЛИ}
    Аналогично \verb!expression || expression! с меньшим приоритетом.
  \end{operator}
\end{enumerate}

\section{Предложения}

Предложения - это одна из разновидностей сложных выражений, создаваемая с помощью инструкций (поэтому количество возможных видов предложений строго ограничено). Каждое предложение начинается с инструкции, объявляющей тип предложения и заканчивается инструкцией end, объявляющей конец предложения. Между этими двумя инструкциями находится фрагмент кода, называемый телом предложения, процессом выполнения которого манипулирует предложение.

\subsection{Условное предложение}

Условные предложения управляют процессом выполнения в зависимости от логического значения переданного условия. В результате выполнения предложения возвращается результат выполнения последнего выражения в его теле (или nil).

\paragraph*{Синтаксис предложения:} тело предложения выполняется, если логическое значение условия true.

\begin{verbatim}
  if условие
    тело_предложения
  end\
\end{verbatim}

Тело предложения должно быть отделено от условия либо переводом строки, либо точкой с запятой, либо инструкцией then.

\paragraph*{Инструкция else:} содержит фрагмент кода, который выполняется, если логическое значение условия false.

\begin{verbatim}
  ...
    тело_предложения
  else
    код
  end\
\end{verbatim}

При необходимости записать подряд инструкцию else и новое условное предложение используется инструкция elsif.

\paragraph*{Краткий синтаксис:} \verb!тело_предложения if условие!

Тело предложения либо должно находиться на одной строке с условием, либо быть ограничено инстуркциями begin и end, либо быть ограничено двумя круглыми скобками.
\begin{verbatim}
  begin
    тело_предложения
  end if условие\
\end{verbatim}
или
\begin{verbatim}
  ( тело_предложения
  ) if условие\
\end{verbatim}

Если вместо инструкции if использовать инструкцию unless, то тело предложения будет выполняться, только если логическое значение условия false. Инструкция elsif в этом случае не используется.

\subsection{Разветвленное условие}

Разветвленные условия аналогичны условному предложению, но проверяют сразу несколько условий. Условия проверяются последовательно. Обычно наиболее вероятные варианты записывают раньше остальных - это уменьшит время выполнения предложения. В результате выполнения предложения возвращается результат выполнения последнего выражения в его теле (или nil).

\paragraph*{Синтаксис предложения:} выполняется фрагмент кода, логическое значение условия которого true.

\begin{verbatim}
  case
    when условие
      код
    when условие
      код
    ...
  end\
\end{verbatim}

Условие может состоять из нескольких выражений, разделенных запятыми. Любое из них может послужить причиной для выполнения кода.

\paragraph*{Специальный синтаксис:} проверяется равенство условия и выражений (===).

\begin{verbatim}
  case условие
  when выражение
    код
  when выражение
    код
  ...
  end\
\end{verbatim}

В любой форме можно использовать инструкцию else.

\subsection{Цикл}

Цикл - это предложение итеративного типа (заставляющее программу повторно выполнять некоторый фрагмент кода). Циклы используются в том случае, когда число итераций неизвестно заранее. В результате выполнения цикла возвращается ссылка на nil.

Цикл while не соотвествует слову "пока" в естественном языке. Условие цикла не проверяется непрерывно, а только до или после каждой итеарции.

\paragraph*{Синтаксис предложения:} тело предложения выполняется до тех пор пока логическое значение условия true (условие проверяется до итерации).

\begin{verbatim}
  while условие
    тело_цикла
  end\
\end{verbatim}

Тело цикла должно быть отделено от условия либо переводом строки, либо точкой с запятой, либо инструкицей do.

\paragraph*{Сокращенный синтаксис:} \verb!тело_цикла while условие!

Тело цикла и условие обязательно должны находиться на одной строке кода. Если тело цикла ограничено инструкциями begin и end, то условие проверяется после итерации. Также тело цикла может быть ограничено двумя круглыми скобками.
\begin{verbatim}
  begin 
    тело_цикла
  end while условие\
\end{verbatim}
или
\begin{verbatim}
  ( тело_цикла
  ) while условие\
\end{verbatim}
	
Если вместо инструкции while использовать инструкцию until, то тело цикла будет выполняться если логическое значение условия false. 

\subsection{Перебор элементов}

Перебор элементов - это предложение итеративного типа, выполняющее тело перебора для каждого элемента составного объекта.
\begin{verbatim}
  for параметр in объект
    тело_перебора
  end\
\end{verbatim}

Параметр в теле перебора ссылается на элементы составного объекта (может быть использовано несколько параметров, разделенных запятыми).

Для составного объекта должен существовать метод \method{.each}, который будет использоваться в ходе выполнения предложения.

Тело предложения должно быть отделено либо переводом строки, либо точкой с запятой, либо инструкцией do. 

\subsection{Процесс выполнения}

Процесс выполнения предложения может быть изменен с помощью специальных инструкций в его теле. Необязательный код, передаваемый инструкции возвращается в результате выполнения предложения. Если код отсутствует, то возвращается ссылка на nil.

\begin{keylist}{Список инструкций:}  
  \firstkey{return [код]} - завершает выполнение предложения и всех методов, в теле которых оно выполняется, продвигаясь вверх по областям видимости;
  
  \key{break [код]} - завершает выполнение предложения;
  
  \key{next [код]} - завершает текущую итерацию цикла и переходит к следующей;
  
  \key{redo} - еще раз выполняет тело предложения. Проверка условия при этом не выполняется.
\end{keylist}

\section{Триггеры}

В качестве условия могут быть использованы триггеры. Триггер - это сложное выражение, составленное с помощью операторов \mono{..} или \mono{...} . Эти операторы имеют приоритет выполнения больше, чем у оператора условия и меньше, чем у оператора логического ИЛИ (примерно 12.5). В условии может использоваться только один триггер. 

Как и обычные условия, триггеры имеют некоторое логическое значение. Его особенность в том, что оно может изменяться в зависимости от результатов предыдущих вычислений, т.е. сохраняет состояние выполнения.

Обычно триггеры применяются вместе с регулярными выражениями для обработки текста между начальными и конечными шаблонами.

\paragraph*{Синтаксис триггера:} \verb!условие..условие!; \verb!условие...условие!

Операнды триггера - это два условия, при проверке которых логичсекое значение триггера либо остается неизменным, либо изменяется на противоположное. Порядок проверки условий зависит от оператора, используемого для создания триггера.

Логическое значение триггера false до тех пор пока логическое значение первого условия false. После смены логического значения первого условия изменяется и логическое значение триггера. Оно будет сохраняться до тех пор пока логическое значение второго условия false. После смены логического значения второго условия, изменяется и логическое значение триггера и проверка условий начинается сначала.

\itemtitle{Процесс выполнения триггера:}
\begin{enumerate}
  \item Если логическое значение триггера false, то проверяется первое условие. В зависимости от его логического значения изменяется логическое значение триггера. После его возвращения для оператора \mono{..} также проверяется второе условие.

  \item Если логическое значение триггера true, то проверяется второе условие. Если логическое значение второго условия true, то логическое значение триггера меняется.
\end{enumerate}

\begin{note}
  По смыслу триггеры довольно похожи на диапазоны. Они верны до тех пор пока существующее состояние выполнения находится от достижения первого условия и до достижения второго условия. Оператор \mono{...} включает состояние достигнувшее второе условие, а оператор \mono{..} - нет. 
\end{note}